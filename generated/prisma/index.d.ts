
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model MetaAccount
 * 
 */
export type MetaAccount = $Result.DefaultSelection<Prisma.$MetaAccountPayload>
/**
 * Model AdAccount
 * 
 */
export type AdAccount = $Result.DefaultSelection<Prisma.$AdAccountPayload>
/**
 * Model Campaign
 * 
 */
export type Campaign = $Result.DefaultSelection<Prisma.$CampaignPayload>
/**
 * Model CampaignMetrics
 * 
 */
export type CampaignMetrics = $Result.DefaultSelection<Prisma.$CampaignMetricsPayload>
/**
 * Model AdSet
 * 
 */
export type AdSet = $Result.DefaultSelection<Prisma.$AdSetPayload>
/**
 * Model AdSetMetrics
 * 
 */
export type AdSetMetrics = $Result.DefaultSelection<Prisma.$AdSetMetricsPayload>
/**
 * Model Ad
 * 
 */
export type Ad = $Result.DefaultSelection<Prisma.$AdPayload>
/**
 * Model AdMetrics
 * 
 */
export type AdMetrics = $Result.DefaultSelection<Prisma.$AdMetricsPayload>
/**
 * Model Schedule
 * 
 */
export type Schedule = $Result.DefaultSelection<Prisma.$SchedulePayload>
/**
 * Model AdsPlanner
 * 
 */
export type AdsPlanner = $Result.DefaultSelection<Prisma.$AdsPlannerPayload>
/**
 * Model PlannerItem
 * 
 */
export type PlannerItem = $Result.DefaultSelection<Prisma.$PlannerItemPayload>
/**
 * Model SocialMediaAccount
 * 
 */
export type SocialMediaAccount = $Result.DefaultSelection<Prisma.$SocialMediaAccountPayload>
/**
 * Model PlatformMetrics
 * 
 */
export type PlatformMetrics = $Result.DefaultSelection<Prisma.$PlatformMetricsPayload>
/**
 * Model EngagementMetrics
 * 
 */
export type EngagementMetrics = $Result.DefaultSelection<Prisma.$EngagementMetricsPayload>
/**
 * Model Influencer
 * 
 */
export type Influencer = $Result.DefaultSelection<Prisma.$InfluencerPayload>
/**
 * Model InfluencerCampaigns
 * 
 */
export type InfluencerCampaigns = $Result.DefaultSelection<Prisma.$InfluencerCampaignsPayload>
/**
 * Model Clinic
 * 
 */
export type Clinic = $Result.DefaultSelection<Prisma.$ClinicPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Income
 * 
 */
export type Income = $Result.DefaultSelection<Prisma.$IncomePayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model ROASMetrics
 * 
 */
export type ROASMetrics = $Result.DefaultSelection<Prisma.$ROASMetricsPayload>
/**
 * Model ConversionMetrics
 * 
 */
export type ConversionMetrics = $Result.DefaultSelection<Prisma.$ConversionMetricsPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model TagsOnCampaigns
 * 
 */
export type TagsOnCampaigns = $Result.DefaultSelection<Prisma.$TagsOnCampaignsPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Setting
 * 
 */
export type Setting = $Result.DefaultSelection<Prisma.$SettingPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  USER: 'USER',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const CampaignStatus: {
  ACTIVE: 'ACTIVE',
  PAUSED: 'PAUSED',
  DELETED: 'DELETED',
  COMPLETED: 'COMPLETED',
  DRAFT: 'DRAFT'
};

export type CampaignStatus = (typeof CampaignStatus)[keyof typeof CampaignStatus]


export const BudgetType: {
  DAILY: 'DAILY',
  LIFETIME: 'LIFETIME'
};

export type BudgetType = (typeof BudgetType)[keyof typeof BudgetType]


export const AdSetStatus: {
  ACTIVE: 'ACTIVE',
  PAUSED: 'PAUSED',
  DELETED: 'DELETED',
  DRAFT: 'DRAFT'
};

export type AdSetStatus = (typeof AdSetStatus)[keyof typeof AdSetStatus]


export const AdStatus: {
  ACTIVE: 'ACTIVE',
  PAUSED: 'PAUSED',
  DELETED: 'DELETED',
  DRAFT: 'DRAFT',
  REVIEW: 'REVIEW',
  REJECTED: 'REJECTED'
};

export type AdStatus = (typeof AdStatus)[keyof typeof AdStatus]


export const CreativeType: {
  IMAGE: 'IMAGE',
  VIDEO: 'VIDEO',
  CAROUSEL: 'CAROUSEL',
  COLLECTION: 'COLLECTION',
  STORY: 'STORY',
  REEL: 'REEL'
};

export type CreativeType = (typeof CreativeType)[keyof typeof CreativeType]


export const ScheduleStatus: {
  SCHEDULED: 'SCHEDULED',
  ACTIVE: 'ACTIVE',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type ScheduleStatus = (typeof ScheduleStatus)[keyof typeof ScheduleStatus]


export const SchedulePriority: {
  STANDARD: 'STANDARD',
  PRIORITY: 'PRIORITY'
};

export type SchedulePriority = (typeof SchedulePriority)[keyof typeof SchedulePriority]


export const ScheduleCategory: {
  PRODUCT: 'PRODUCT',
  CLINIC: 'CLINIC',
  OTHER: 'OTHER'
};

export type ScheduleCategory = (typeof ScheduleCategory)[keyof typeof ScheduleCategory]


export const RecurrencePattern: {
  NONE: 'NONE',
  DAILY: 'DAILY',
  WEEKLY: 'WEEKLY',
  MONTHLY: 'MONTHLY'
};

export type RecurrencePattern = (typeof RecurrencePattern)[keyof typeof RecurrencePattern]


export const CampaignObjective: {
  TRAFFIC: 'TRAFFIC',
  LEADS: 'LEADS',
  ENGAGEMENT: 'ENGAGEMENT',
  BRAND_AWARENESS: 'BRAND_AWARENESS',
  REACH: 'REACH',
  APP_INSTALLS: 'APP_INSTALLS',
  VIDEO_VIEWS: 'VIDEO_VIEWS',
  CONVERSIONS: 'CONVERSIONS',
  CATALOG_SALES: 'CATALOG_SALES',
  STORE_TRAFFIC: 'STORE_TRAFFIC',
  MESSAGES: 'MESSAGES'
};

export type CampaignObjective = (typeof CampaignObjective)[keyof typeof CampaignObjective]


export const GenderTarget: {
  ALL: 'ALL',
  MEN: 'MEN',
  WOMEN: 'WOMEN'
};

export type GenderTarget = (typeof GenderTarget)[keyof typeof GenderTarget]


export const PlannerItemStatus: {
  DRAFT: 'DRAFT',
  PLANNED: 'PLANNED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type PlannerItemStatus = (typeof PlannerItemStatus)[keyof typeof PlannerItemStatus]


export const PlatformType: {
  FACEBOOK: 'FACEBOOK',
  INSTAGRAM: 'INSTAGRAM',
  TWITTER: 'TWITTER',
  LINKEDIN: 'LINKEDIN',
  TIKTOK: 'TIKTOK',
  YOUTUBE: 'YOUTUBE',
  PINTEREST: 'PINTEREST',
  SNAPCHAT: 'SNAPCHAT',
  OTHER: 'OTHER'
};

export type PlatformType = (typeof PlatformType)[keyof typeof PlatformType]


export const InfluencerStatus: {
  POTENTIAL: 'POTENTIAL',
  CONTACTED: 'CONTACTED',
  ACTIVE: 'ACTIVE',
  PREVIOUS: 'PREVIOUS',
  BLACKLISTED: 'BLACKLISTED'
};

export type InfluencerStatus = (typeof InfluencerStatus)[keyof typeof InfluencerStatus]


export const InfluencerCampaignStatus: {
  PLANNED: 'PLANNED',
  ACTIVE: 'ACTIVE',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type InfluencerCampaignStatus = (typeof InfluencerCampaignStatus)[keyof typeof InfluencerCampaignStatus]


export const IncomeCategory: {
  ADS_REVENUE: 'ADS_REVENUE',
  CLIENT_PAYMENT: 'CLIENT_PAYMENT',
  AFFILIATE: 'AFFILIATE',
  OTHER: 'OTHER'
};

export type IncomeCategory = (typeof IncomeCategory)[keyof typeof IncomeCategory]


export const PaymentStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const PaymentMethod: {
  CREDIT_CARD: 'CREDIT_CARD',
  PAYPAL: 'PAYPAL',
  BANK_TRANSFER: 'BANK_TRANSFER',
  CRYPTO: 'CRYPTO',
  OTHER: 'OTHER'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const InvoiceStatus: {
  DRAFT: 'DRAFT',
  SENT: 'SENT',
  PAID: 'PAID',
  OVERDUE: 'OVERDUE',
  CANCELLED: 'CANCELLED'
};

export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus]


export const NotificationType: {
  INFO: 'INFO',
  WARNING: 'WARNING',
  ERROR: 'ERROR',
  SUCCESS: 'SUCCESS'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type CampaignStatus = $Enums.CampaignStatus

export const CampaignStatus: typeof $Enums.CampaignStatus

export type BudgetType = $Enums.BudgetType

export const BudgetType: typeof $Enums.BudgetType

export type AdSetStatus = $Enums.AdSetStatus

export const AdSetStatus: typeof $Enums.AdSetStatus

export type AdStatus = $Enums.AdStatus

export const AdStatus: typeof $Enums.AdStatus

export type CreativeType = $Enums.CreativeType

export const CreativeType: typeof $Enums.CreativeType

export type ScheduleStatus = $Enums.ScheduleStatus

export const ScheduleStatus: typeof $Enums.ScheduleStatus

export type SchedulePriority = $Enums.SchedulePriority

export const SchedulePriority: typeof $Enums.SchedulePriority

export type ScheduleCategory = $Enums.ScheduleCategory

export const ScheduleCategory: typeof $Enums.ScheduleCategory

export type RecurrencePattern = $Enums.RecurrencePattern

export const RecurrencePattern: typeof $Enums.RecurrencePattern

export type CampaignObjective = $Enums.CampaignObjective

export const CampaignObjective: typeof $Enums.CampaignObjective

export type GenderTarget = $Enums.GenderTarget

export const GenderTarget: typeof $Enums.GenderTarget

export type PlannerItemStatus = $Enums.PlannerItemStatus

export const PlannerItemStatus: typeof $Enums.PlannerItemStatus

export type PlatformType = $Enums.PlatformType

export const PlatformType: typeof $Enums.PlatformType

export type InfluencerStatus = $Enums.InfluencerStatus

export const InfluencerStatus: typeof $Enums.InfluencerStatus

export type InfluencerCampaignStatus = $Enums.InfluencerCampaignStatus

export const InfluencerCampaignStatus: typeof $Enums.InfluencerCampaignStatus

export type IncomeCategory = $Enums.IncomeCategory

export const IncomeCategory: typeof $Enums.IncomeCategory

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type InvoiceStatus = $Enums.InvoiceStatus

export const InvoiceStatus: typeof $Enums.InvoiceStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.metaAccount`: Exposes CRUD operations for the **MetaAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MetaAccounts
    * const metaAccounts = await prisma.metaAccount.findMany()
    * ```
    */
  get metaAccount(): Prisma.MetaAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adAccount`: Exposes CRUD operations for the **AdAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdAccounts
    * const adAccounts = await prisma.adAccount.findMany()
    * ```
    */
  get adAccount(): Prisma.AdAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.campaign`: Exposes CRUD operations for the **Campaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Campaigns
    * const campaigns = await prisma.campaign.findMany()
    * ```
    */
  get campaign(): Prisma.CampaignDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.campaignMetrics`: Exposes CRUD operations for the **CampaignMetrics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignMetrics
    * const campaignMetrics = await prisma.campaignMetrics.findMany()
    * ```
    */
  get campaignMetrics(): Prisma.CampaignMetricsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adSet`: Exposes CRUD operations for the **AdSet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdSets
    * const adSets = await prisma.adSet.findMany()
    * ```
    */
  get adSet(): Prisma.AdSetDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adSetMetrics`: Exposes CRUD operations for the **AdSetMetrics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdSetMetrics
    * const adSetMetrics = await prisma.adSetMetrics.findMany()
    * ```
    */
  get adSetMetrics(): Prisma.AdSetMetricsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ad`: Exposes CRUD operations for the **Ad** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ads
    * const ads = await prisma.ad.findMany()
    * ```
    */
  get ad(): Prisma.AdDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adMetrics`: Exposes CRUD operations for the **AdMetrics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdMetrics
    * const adMetrics = await prisma.adMetrics.findMany()
    * ```
    */
  get adMetrics(): Prisma.AdMetricsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.schedule`: Exposes CRUD operations for the **Schedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schedules
    * const schedules = await prisma.schedule.findMany()
    * ```
    */
  get schedule(): Prisma.ScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adsPlanner`: Exposes CRUD operations for the **AdsPlanner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdsPlanners
    * const adsPlanners = await prisma.adsPlanner.findMany()
    * ```
    */
  get adsPlanner(): Prisma.AdsPlannerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plannerItem`: Exposes CRUD operations for the **PlannerItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlannerItems
    * const plannerItems = await prisma.plannerItem.findMany()
    * ```
    */
  get plannerItem(): Prisma.PlannerItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.socialMediaAccount`: Exposes CRUD operations for the **SocialMediaAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SocialMediaAccounts
    * const socialMediaAccounts = await prisma.socialMediaAccount.findMany()
    * ```
    */
  get socialMediaAccount(): Prisma.SocialMediaAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.platformMetrics`: Exposes CRUD operations for the **PlatformMetrics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlatformMetrics
    * const platformMetrics = await prisma.platformMetrics.findMany()
    * ```
    */
  get platformMetrics(): Prisma.PlatformMetricsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.engagementMetrics`: Exposes CRUD operations for the **EngagementMetrics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EngagementMetrics
    * const engagementMetrics = await prisma.engagementMetrics.findMany()
    * ```
    */
  get engagementMetrics(): Prisma.EngagementMetricsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.influencer`: Exposes CRUD operations for the **Influencer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Influencers
    * const influencers = await prisma.influencer.findMany()
    * ```
    */
  get influencer(): Prisma.InfluencerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.influencerCampaigns`: Exposes CRUD operations for the **InfluencerCampaigns** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InfluencerCampaigns
    * const influencerCampaigns = await prisma.influencerCampaigns.findMany()
    * ```
    */
  get influencerCampaigns(): Prisma.InfluencerCampaignsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clinic`: Exposes CRUD operations for the **Clinic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clinics
    * const clinics = await prisma.clinic.findMany()
    * ```
    */
  get clinic(): Prisma.ClinicDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.income`: Exposes CRUD operations for the **Income** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Incomes
    * const incomes = await prisma.income.findMany()
    * ```
    */
  get income(): Prisma.IncomeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rOASMetrics`: Exposes CRUD operations for the **ROASMetrics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ROASMetrics
    * const rOASMetrics = await prisma.rOASMetrics.findMany()
    * ```
    */
  get rOASMetrics(): Prisma.ROASMetricsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversionMetrics`: Exposes CRUD operations for the **ConversionMetrics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConversionMetrics
    * const conversionMetrics = await prisma.conversionMetrics.findMany()
    * ```
    */
  get conversionMetrics(): Prisma.ConversionMetricsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tagsOnCampaigns`: Exposes CRUD operations for the **TagsOnCampaigns** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TagsOnCampaigns
    * const tagsOnCampaigns = await prisma.tagsOnCampaigns.findMany()
    * ```
    */
  get tagsOnCampaigns(): Prisma.TagsOnCampaignsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.setting`: Exposes CRUD operations for the **Setting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.setting.findMany()
    * ```
    */
  get setting(): Prisma.SettingDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.9.0
   * Query Engine version: 81e4af48011447c3cc503a190e86995b66d2a28e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    MetaAccount: 'MetaAccount',
    AdAccount: 'AdAccount',
    Campaign: 'Campaign',
    CampaignMetrics: 'CampaignMetrics',
    AdSet: 'AdSet',
    AdSetMetrics: 'AdSetMetrics',
    Ad: 'Ad',
    AdMetrics: 'AdMetrics',
    Schedule: 'Schedule',
    AdsPlanner: 'AdsPlanner',
    PlannerItem: 'PlannerItem',
    SocialMediaAccount: 'SocialMediaAccount',
    PlatformMetrics: 'PlatformMetrics',
    EngagementMetrics: 'EngagementMetrics',
    Influencer: 'Influencer',
    InfluencerCampaigns: 'InfluencerCampaigns',
    Clinic: 'Clinic',
    Product: 'Product',
    Income: 'Income',
    Payment: 'Payment',
    Invoice: 'Invoice',
    ROASMetrics: 'ROASMetrics',
    ConversionMetrics: 'ConversionMetrics',
    Tag: 'Tag',
    TagsOnCampaigns: 'TagsOnCampaigns',
    Notification: 'Notification',
    Setting: 'Setting'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "metaAccount" | "adAccount" | "campaign" | "campaignMetrics" | "adSet" | "adSetMetrics" | "ad" | "adMetrics" | "schedule" | "adsPlanner" | "plannerItem" | "socialMediaAccount" | "platformMetrics" | "engagementMetrics" | "influencer" | "influencerCampaigns" | "clinic" | "product" | "income" | "payment" | "invoice" | "rOASMetrics" | "conversionMetrics" | "tag" | "tagsOnCampaigns" | "notification" | "setting"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      MetaAccount: {
        payload: Prisma.$MetaAccountPayload<ExtArgs>
        fields: Prisma.MetaAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MetaAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MetaAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaAccountPayload>
          }
          findFirst: {
            args: Prisma.MetaAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MetaAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaAccountPayload>
          }
          findMany: {
            args: Prisma.MetaAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaAccountPayload>[]
          }
          create: {
            args: Prisma.MetaAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaAccountPayload>
          }
          createMany: {
            args: Prisma.MetaAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MetaAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaAccountPayload>[]
          }
          delete: {
            args: Prisma.MetaAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaAccountPayload>
          }
          update: {
            args: Prisma.MetaAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaAccountPayload>
          }
          deleteMany: {
            args: Prisma.MetaAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MetaAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MetaAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaAccountPayload>[]
          }
          upsert: {
            args: Prisma.MetaAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MetaAccountPayload>
          }
          aggregate: {
            args: Prisma.MetaAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMetaAccount>
          }
          groupBy: {
            args: Prisma.MetaAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<MetaAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.MetaAccountCountArgs<ExtArgs>
            result: $Utils.Optional<MetaAccountCountAggregateOutputType> | number
          }
        }
      }
      AdAccount: {
        payload: Prisma.$AdAccountPayload<ExtArgs>
        fields: Prisma.AdAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdAccountPayload>
          }
          findFirst: {
            args: Prisma.AdAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdAccountPayload>
          }
          findMany: {
            args: Prisma.AdAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdAccountPayload>[]
          }
          create: {
            args: Prisma.AdAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdAccountPayload>
          }
          createMany: {
            args: Prisma.AdAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdAccountPayload>[]
          }
          delete: {
            args: Prisma.AdAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdAccountPayload>
          }
          update: {
            args: Prisma.AdAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdAccountPayload>
          }
          deleteMany: {
            args: Prisma.AdAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdAccountPayload>[]
          }
          upsert: {
            args: Prisma.AdAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdAccountPayload>
          }
          aggregate: {
            args: Prisma.AdAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdAccount>
          }
          groupBy: {
            args: Prisma.AdAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdAccountCountArgs<ExtArgs>
            result: $Utils.Optional<AdAccountCountAggregateOutputType> | number
          }
        }
      }
      Campaign: {
        payload: Prisma.$CampaignPayload<ExtArgs>
        fields: Prisma.CampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findFirst: {
            args: Prisma.CampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          findMany: {
            args: Prisma.CampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          create: {
            args: Prisma.CampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          createMany: {
            args: Prisma.CampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          delete: {
            args: Prisma.CampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          update: {
            args: Prisma.CampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          deleteMany: {
            args: Prisma.CampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CampaignUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>[]
          }
          upsert: {
            args: Prisma.CampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignPayload>
          }
          aggregate: {
            args: Prisma.CampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaign>
          }
          groupBy: {
            args: Prisma.CampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignCountAggregateOutputType> | number
          }
        }
      }
      CampaignMetrics: {
        payload: Prisma.$CampaignMetricsPayload<ExtArgs>
        fields: Prisma.CampaignMetricsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignMetricsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMetricsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignMetricsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMetricsPayload>
          }
          findFirst: {
            args: Prisma.CampaignMetricsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMetricsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignMetricsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMetricsPayload>
          }
          findMany: {
            args: Prisma.CampaignMetricsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMetricsPayload>[]
          }
          create: {
            args: Prisma.CampaignMetricsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMetricsPayload>
          }
          createMany: {
            args: Prisma.CampaignMetricsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignMetricsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMetricsPayload>[]
          }
          delete: {
            args: Prisma.CampaignMetricsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMetricsPayload>
          }
          update: {
            args: Prisma.CampaignMetricsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMetricsPayload>
          }
          deleteMany: {
            args: Prisma.CampaignMetricsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignMetricsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CampaignMetricsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMetricsPayload>[]
          }
          upsert: {
            args: Prisma.CampaignMetricsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignMetricsPayload>
          }
          aggregate: {
            args: Prisma.CampaignMetricsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignMetrics>
          }
          groupBy: {
            args: Prisma.CampaignMetricsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignMetricsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignMetricsCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignMetricsCountAggregateOutputType> | number
          }
        }
      }
      AdSet: {
        payload: Prisma.$AdSetPayload<ExtArgs>
        fields: Prisma.AdSetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdSetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdSetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdSetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdSetPayload>
          }
          findFirst: {
            args: Prisma.AdSetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdSetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdSetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdSetPayload>
          }
          findMany: {
            args: Prisma.AdSetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdSetPayload>[]
          }
          create: {
            args: Prisma.AdSetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdSetPayload>
          }
          createMany: {
            args: Prisma.AdSetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdSetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdSetPayload>[]
          }
          delete: {
            args: Prisma.AdSetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdSetPayload>
          }
          update: {
            args: Prisma.AdSetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdSetPayload>
          }
          deleteMany: {
            args: Prisma.AdSetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdSetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdSetUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdSetPayload>[]
          }
          upsert: {
            args: Prisma.AdSetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdSetPayload>
          }
          aggregate: {
            args: Prisma.AdSetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdSet>
          }
          groupBy: {
            args: Prisma.AdSetGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdSetGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdSetCountArgs<ExtArgs>
            result: $Utils.Optional<AdSetCountAggregateOutputType> | number
          }
        }
      }
      AdSetMetrics: {
        payload: Prisma.$AdSetMetricsPayload<ExtArgs>
        fields: Prisma.AdSetMetricsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdSetMetricsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdSetMetricsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdSetMetricsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdSetMetricsPayload>
          }
          findFirst: {
            args: Prisma.AdSetMetricsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdSetMetricsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdSetMetricsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdSetMetricsPayload>
          }
          findMany: {
            args: Prisma.AdSetMetricsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdSetMetricsPayload>[]
          }
          create: {
            args: Prisma.AdSetMetricsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdSetMetricsPayload>
          }
          createMany: {
            args: Prisma.AdSetMetricsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdSetMetricsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdSetMetricsPayload>[]
          }
          delete: {
            args: Prisma.AdSetMetricsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdSetMetricsPayload>
          }
          update: {
            args: Prisma.AdSetMetricsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdSetMetricsPayload>
          }
          deleteMany: {
            args: Prisma.AdSetMetricsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdSetMetricsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdSetMetricsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdSetMetricsPayload>[]
          }
          upsert: {
            args: Prisma.AdSetMetricsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdSetMetricsPayload>
          }
          aggregate: {
            args: Prisma.AdSetMetricsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdSetMetrics>
          }
          groupBy: {
            args: Prisma.AdSetMetricsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdSetMetricsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdSetMetricsCountArgs<ExtArgs>
            result: $Utils.Optional<AdSetMetricsCountAggregateOutputType> | number
          }
        }
      }
      Ad: {
        payload: Prisma.$AdPayload<ExtArgs>
        fields: Prisma.AdFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>
          }
          findFirst: {
            args: Prisma.AdFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>
          }
          findMany: {
            args: Prisma.AdFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>[]
          }
          create: {
            args: Prisma.AdCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>
          }
          createMany: {
            args: Prisma.AdCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>[]
          }
          delete: {
            args: Prisma.AdDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>
          }
          update: {
            args: Prisma.AdUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>
          }
          deleteMany: {
            args: Prisma.AdDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>[]
          }
          upsert: {
            args: Prisma.AdUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>
          }
          aggregate: {
            args: Prisma.AdAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAd>
          }
          groupBy: {
            args: Prisma.AdGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdCountArgs<ExtArgs>
            result: $Utils.Optional<AdCountAggregateOutputType> | number
          }
        }
      }
      AdMetrics: {
        payload: Prisma.$AdMetricsPayload<ExtArgs>
        fields: Prisma.AdMetricsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdMetricsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdMetricsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdMetricsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdMetricsPayload>
          }
          findFirst: {
            args: Prisma.AdMetricsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdMetricsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdMetricsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdMetricsPayload>
          }
          findMany: {
            args: Prisma.AdMetricsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdMetricsPayload>[]
          }
          create: {
            args: Prisma.AdMetricsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdMetricsPayload>
          }
          createMany: {
            args: Prisma.AdMetricsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdMetricsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdMetricsPayload>[]
          }
          delete: {
            args: Prisma.AdMetricsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdMetricsPayload>
          }
          update: {
            args: Prisma.AdMetricsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdMetricsPayload>
          }
          deleteMany: {
            args: Prisma.AdMetricsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdMetricsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdMetricsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdMetricsPayload>[]
          }
          upsert: {
            args: Prisma.AdMetricsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdMetricsPayload>
          }
          aggregate: {
            args: Prisma.AdMetricsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdMetrics>
          }
          groupBy: {
            args: Prisma.AdMetricsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdMetricsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdMetricsCountArgs<ExtArgs>
            result: $Utils.Optional<AdMetricsCountAggregateOutputType> | number
          }
        }
      }
      Schedule: {
        payload: Prisma.$SchedulePayload<ExtArgs>
        fields: Prisma.ScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          findFirst: {
            args: Prisma.ScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          findMany: {
            args: Prisma.ScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          create: {
            args: Prisma.ScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          createMany: {
            args: Prisma.ScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          delete: {
            args: Prisma.ScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          update: {
            args: Prisma.ScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          deleteMany: {
            args: Prisma.ScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScheduleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          upsert: {
            args: Prisma.ScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          aggregate: {
            args: Prisma.ScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchedule>
          }
          groupBy: {
            args: Prisma.ScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduleCountAggregateOutputType> | number
          }
        }
      }
      AdsPlanner: {
        payload: Prisma.$AdsPlannerPayload<ExtArgs>
        fields: Prisma.AdsPlannerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdsPlannerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsPlannerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdsPlannerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsPlannerPayload>
          }
          findFirst: {
            args: Prisma.AdsPlannerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsPlannerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdsPlannerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsPlannerPayload>
          }
          findMany: {
            args: Prisma.AdsPlannerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsPlannerPayload>[]
          }
          create: {
            args: Prisma.AdsPlannerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsPlannerPayload>
          }
          createMany: {
            args: Prisma.AdsPlannerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdsPlannerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsPlannerPayload>[]
          }
          delete: {
            args: Prisma.AdsPlannerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsPlannerPayload>
          }
          update: {
            args: Prisma.AdsPlannerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsPlannerPayload>
          }
          deleteMany: {
            args: Prisma.AdsPlannerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdsPlannerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdsPlannerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsPlannerPayload>[]
          }
          upsert: {
            args: Prisma.AdsPlannerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdsPlannerPayload>
          }
          aggregate: {
            args: Prisma.AdsPlannerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdsPlanner>
          }
          groupBy: {
            args: Prisma.AdsPlannerGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdsPlannerGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdsPlannerCountArgs<ExtArgs>
            result: $Utils.Optional<AdsPlannerCountAggregateOutputType> | number
          }
        }
      }
      PlannerItem: {
        payload: Prisma.$PlannerItemPayload<ExtArgs>
        fields: Prisma.PlannerItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlannerItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlannerItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlannerItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlannerItemPayload>
          }
          findFirst: {
            args: Prisma.PlannerItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlannerItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlannerItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlannerItemPayload>
          }
          findMany: {
            args: Prisma.PlannerItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlannerItemPayload>[]
          }
          create: {
            args: Prisma.PlannerItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlannerItemPayload>
          }
          createMany: {
            args: Prisma.PlannerItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlannerItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlannerItemPayload>[]
          }
          delete: {
            args: Prisma.PlannerItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlannerItemPayload>
          }
          update: {
            args: Prisma.PlannerItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlannerItemPayload>
          }
          deleteMany: {
            args: Prisma.PlannerItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlannerItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlannerItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlannerItemPayload>[]
          }
          upsert: {
            args: Prisma.PlannerItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlannerItemPayload>
          }
          aggregate: {
            args: Prisma.PlannerItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlannerItem>
          }
          groupBy: {
            args: Prisma.PlannerItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlannerItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlannerItemCountArgs<ExtArgs>
            result: $Utils.Optional<PlannerItemCountAggregateOutputType> | number
          }
        }
      }
      SocialMediaAccount: {
        payload: Prisma.$SocialMediaAccountPayload<ExtArgs>
        fields: Prisma.SocialMediaAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SocialMediaAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SocialMediaAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaAccountPayload>
          }
          findFirst: {
            args: Prisma.SocialMediaAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SocialMediaAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaAccountPayload>
          }
          findMany: {
            args: Prisma.SocialMediaAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaAccountPayload>[]
          }
          create: {
            args: Prisma.SocialMediaAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaAccountPayload>
          }
          createMany: {
            args: Prisma.SocialMediaAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SocialMediaAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaAccountPayload>[]
          }
          delete: {
            args: Prisma.SocialMediaAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaAccountPayload>
          }
          update: {
            args: Prisma.SocialMediaAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaAccountPayload>
          }
          deleteMany: {
            args: Prisma.SocialMediaAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SocialMediaAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SocialMediaAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaAccountPayload>[]
          }
          upsert: {
            args: Prisma.SocialMediaAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SocialMediaAccountPayload>
          }
          aggregate: {
            args: Prisma.SocialMediaAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSocialMediaAccount>
          }
          groupBy: {
            args: Prisma.SocialMediaAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<SocialMediaAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.SocialMediaAccountCountArgs<ExtArgs>
            result: $Utils.Optional<SocialMediaAccountCountAggregateOutputType> | number
          }
        }
      }
      PlatformMetrics: {
        payload: Prisma.$PlatformMetricsPayload<ExtArgs>
        fields: Prisma.PlatformMetricsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlatformMetricsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformMetricsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlatformMetricsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformMetricsPayload>
          }
          findFirst: {
            args: Prisma.PlatformMetricsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformMetricsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlatformMetricsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformMetricsPayload>
          }
          findMany: {
            args: Prisma.PlatformMetricsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformMetricsPayload>[]
          }
          create: {
            args: Prisma.PlatformMetricsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformMetricsPayload>
          }
          createMany: {
            args: Prisma.PlatformMetricsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlatformMetricsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformMetricsPayload>[]
          }
          delete: {
            args: Prisma.PlatformMetricsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformMetricsPayload>
          }
          update: {
            args: Prisma.PlatformMetricsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformMetricsPayload>
          }
          deleteMany: {
            args: Prisma.PlatformMetricsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlatformMetricsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlatformMetricsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformMetricsPayload>[]
          }
          upsert: {
            args: Prisma.PlatformMetricsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformMetricsPayload>
          }
          aggregate: {
            args: Prisma.PlatformMetricsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlatformMetrics>
          }
          groupBy: {
            args: Prisma.PlatformMetricsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlatformMetricsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlatformMetricsCountArgs<ExtArgs>
            result: $Utils.Optional<PlatformMetricsCountAggregateOutputType> | number
          }
        }
      }
      EngagementMetrics: {
        payload: Prisma.$EngagementMetricsPayload<ExtArgs>
        fields: Prisma.EngagementMetricsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EngagementMetricsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementMetricsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EngagementMetricsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementMetricsPayload>
          }
          findFirst: {
            args: Prisma.EngagementMetricsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementMetricsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EngagementMetricsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementMetricsPayload>
          }
          findMany: {
            args: Prisma.EngagementMetricsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementMetricsPayload>[]
          }
          create: {
            args: Prisma.EngagementMetricsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementMetricsPayload>
          }
          createMany: {
            args: Prisma.EngagementMetricsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EngagementMetricsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementMetricsPayload>[]
          }
          delete: {
            args: Prisma.EngagementMetricsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementMetricsPayload>
          }
          update: {
            args: Prisma.EngagementMetricsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementMetricsPayload>
          }
          deleteMany: {
            args: Prisma.EngagementMetricsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EngagementMetricsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EngagementMetricsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementMetricsPayload>[]
          }
          upsert: {
            args: Prisma.EngagementMetricsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementMetricsPayload>
          }
          aggregate: {
            args: Prisma.EngagementMetricsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEngagementMetrics>
          }
          groupBy: {
            args: Prisma.EngagementMetricsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EngagementMetricsGroupByOutputType>[]
          }
          count: {
            args: Prisma.EngagementMetricsCountArgs<ExtArgs>
            result: $Utils.Optional<EngagementMetricsCountAggregateOutputType> | number
          }
        }
      }
      Influencer: {
        payload: Prisma.$InfluencerPayload<ExtArgs>
        fields: Prisma.InfluencerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InfluencerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluencerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InfluencerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluencerPayload>
          }
          findFirst: {
            args: Prisma.InfluencerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluencerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InfluencerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluencerPayload>
          }
          findMany: {
            args: Prisma.InfluencerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluencerPayload>[]
          }
          create: {
            args: Prisma.InfluencerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluencerPayload>
          }
          createMany: {
            args: Prisma.InfluencerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InfluencerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluencerPayload>[]
          }
          delete: {
            args: Prisma.InfluencerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluencerPayload>
          }
          update: {
            args: Prisma.InfluencerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluencerPayload>
          }
          deleteMany: {
            args: Prisma.InfluencerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InfluencerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InfluencerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluencerPayload>[]
          }
          upsert: {
            args: Prisma.InfluencerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluencerPayload>
          }
          aggregate: {
            args: Prisma.InfluencerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInfluencer>
          }
          groupBy: {
            args: Prisma.InfluencerGroupByArgs<ExtArgs>
            result: $Utils.Optional<InfluencerGroupByOutputType>[]
          }
          count: {
            args: Prisma.InfluencerCountArgs<ExtArgs>
            result: $Utils.Optional<InfluencerCountAggregateOutputType> | number
          }
        }
      }
      InfluencerCampaigns: {
        payload: Prisma.$InfluencerCampaignsPayload<ExtArgs>
        fields: Prisma.InfluencerCampaignsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InfluencerCampaignsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluencerCampaignsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InfluencerCampaignsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluencerCampaignsPayload>
          }
          findFirst: {
            args: Prisma.InfluencerCampaignsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluencerCampaignsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InfluencerCampaignsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluencerCampaignsPayload>
          }
          findMany: {
            args: Prisma.InfluencerCampaignsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluencerCampaignsPayload>[]
          }
          create: {
            args: Prisma.InfluencerCampaignsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluencerCampaignsPayload>
          }
          createMany: {
            args: Prisma.InfluencerCampaignsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InfluencerCampaignsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluencerCampaignsPayload>[]
          }
          delete: {
            args: Prisma.InfluencerCampaignsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluencerCampaignsPayload>
          }
          update: {
            args: Prisma.InfluencerCampaignsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluencerCampaignsPayload>
          }
          deleteMany: {
            args: Prisma.InfluencerCampaignsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InfluencerCampaignsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InfluencerCampaignsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluencerCampaignsPayload>[]
          }
          upsert: {
            args: Prisma.InfluencerCampaignsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfluencerCampaignsPayload>
          }
          aggregate: {
            args: Prisma.InfluencerCampaignsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInfluencerCampaigns>
          }
          groupBy: {
            args: Prisma.InfluencerCampaignsGroupByArgs<ExtArgs>
            result: $Utils.Optional<InfluencerCampaignsGroupByOutputType>[]
          }
          count: {
            args: Prisma.InfluencerCampaignsCountArgs<ExtArgs>
            result: $Utils.Optional<InfluencerCampaignsCountAggregateOutputType> | number
          }
        }
      }
      Clinic: {
        payload: Prisma.$ClinicPayload<ExtArgs>
        fields: Prisma.ClinicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClinicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClinicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>
          }
          findFirst: {
            args: Prisma.ClinicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClinicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>
          }
          findMany: {
            args: Prisma.ClinicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>[]
          }
          create: {
            args: Prisma.ClinicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>
          }
          createMany: {
            args: Prisma.ClinicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClinicCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>[]
          }
          delete: {
            args: Prisma.ClinicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>
          }
          update: {
            args: Prisma.ClinicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>
          }
          deleteMany: {
            args: Prisma.ClinicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClinicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClinicUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>[]
          }
          upsert: {
            args: Prisma.ClinicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>
          }
          aggregate: {
            args: Prisma.ClinicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClinic>
          }
          groupBy: {
            args: Prisma.ClinicGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClinicGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClinicCountArgs<ExtArgs>
            result: $Utils.Optional<ClinicCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Income: {
        payload: Prisma.$IncomePayload<ExtArgs>
        fields: Prisma.IncomeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IncomeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IncomeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomePayload>
          }
          findFirst: {
            args: Prisma.IncomeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IncomeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomePayload>
          }
          findMany: {
            args: Prisma.IncomeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomePayload>[]
          }
          create: {
            args: Prisma.IncomeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomePayload>
          }
          createMany: {
            args: Prisma.IncomeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IncomeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomePayload>[]
          }
          delete: {
            args: Prisma.IncomeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomePayload>
          }
          update: {
            args: Prisma.IncomeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomePayload>
          }
          deleteMany: {
            args: Prisma.IncomeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IncomeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IncomeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomePayload>[]
          }
          upsert: {
            args: Prisma.IncomeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IncomePayload>
          }
          aggregate: {
            args: Prisma.IncomeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIncome>
          }
          groupBy: {
            args: Prisma.IncomeGroupByArgs<ExtArgs>
            result: $Utils.Optional<IncomeGroupByOutputType>[]
          }
          count: {
            args: Prisma.IncomeCountArgs<ExtArgs>
            result: $Utils.Optional<IncomeCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      ROASMetrics: {
        payload: Prisma.$ROASMetricsPayload<ExtArgs>
        fields: Prisma.ROASMetricsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ROASMetricsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ROASMetricsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ROASMetricsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ROASMetricsPayload>
          }
          findFirst: {
            args: Prisma.ROASMetricsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ROASMetricsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ROASMetricsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ROASMetricsPayload>
          }
          findMany: {
            args: Prisma.ROASMetricsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ROASMetricsPayload>[]
          }
          create: {
            args: Prisma.ROASMetricsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ROASMetricsPayload>
          }
          createMany: {
            args: Prisma.ROASMetricsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ROASMetricsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ROASMetricsPayload>[]
          }
          delete: {
            args: Prisma.ROASMetricsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ROASMetricsPayload>
          }
          update: {
            args: Prisma.ROASMetricsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ROASMetricsPayload>
          }
          deleteMany: {
            args: Prisma.ROASMetricsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ROASMetricsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ROASMetricsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ROASMetricsPayload>[]
          }
          upsert: {
            args: Prisma.ROASMetricsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ROASMetricsPayload>
          }
          aggregate: {
            args: Prisma.ROASMetricsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateROASMetrics>
          }
          groupBy: {
            args: Prisma.ROASMetricsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ROASMetricsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ROASMetricsCountArgs<ExtArgs>
            result: $Utils.Optional<ROASMetricsCountAggregateOutputType> | number
          }
        }
      }
      ConversionMetrics: {
        payload: Prisma.$ConversionMetricsPayload<ExtArgs>
        fields: Prisma.ConversionMetricsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversionMetricsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionMetricsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversionMetricsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionMetricsPayload>
          }
          findFirst: {
            args: Prisma.ConversionMetricsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionMetricsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversionMetricsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionMetricsPayload>
          }
          findMany: {
            args: Prisma.ConversionMetricsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionMetricsPayload>[]
          }
          create: {
            args: Prisma.ConversionMetricsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionMetricsPayload>
          }
          createMany: {
            args: Prisma.ConversionMetricsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversionMetricsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionMetricsPayload>[]
          }
          delete: {
            args: Prisma.ConversionMetricsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionMetricsPayload>
          }
          update: {
            args: Prisma.ConversionMetricsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionMetricsPayload>
          }
          deleteMany: {
            args: Prisma.ConversionMetricsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversionMetricsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConversionMetricsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionMetricsPayload>[]
          }
          upsert: {
            args: Prisma.ConversionMetricsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversionMetricsPayload>
          }
          aggregate: {
            args: Prisma.ConversionMetricsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversionMetrics>
          }
          groupBy: {
            args: Prisma.ConversionMetricsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversionMetricsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversionMetricsCountArgs<ExtArgs>
            result: $Utils.Optional<ConversionMetricsCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      TagsOnCampaigns: {
        payload: Prisma.$TagsOnCampaignsPayload<ExtArgs>
        fields: Prisma.TagsOnCampaignsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagsOnCampaignsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsOnCampaignsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagsOnCampaignsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsOnCampaignsPayload>
          }
          findFirst: {
            args: Prisma.TagsOnCampaignsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsOnCampaignsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagsOnCampaignsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsOnCampaignsPayload>
          }
          findMany: {
            args: Prisma.TagsOnCampaignsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsOnCampaignsPayload>[]
          }
          create: {
            args: Prisma.TagsOnCampaignsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsOnCampaignsPayload>
          }
          createMany: {
            args: Prisma.TagsOnCampaignsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagsOnCampaignsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsOnCampaignsPayload>[]
          }
          delete: {
            args: Prisma.TagsOnCampaignsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsOnCampaignsPayload>
          }
          update: {
            args: Prisma.TagsOnCampaignsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsOnCampaignsPayload>
          }
          deleteMany: {
            args: Prisma.TagsOnCampaignsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagsOnCampaignsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagsOnCampaignsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsOnCampaignsPayload>[]
          }
          upsert: {
            args: Prisma.TagsOnCampaignsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsOnCampaignsPayload>
          }
          aggregate: {
            args: Prisma.TagsOnCampaignsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTagsOnCampaigns>
          }
          groupBy: {
            args: Prisma.TagsOnCampaignsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagsOnCampaignsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagsOnCampaignsCountArgs<ExtArgs>
            result: $Utils.Optional<TagsOnCampaignsCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Setting: {
        payload: Prisma.$SettingPayload<ExtArgs>
        fields: Prisma.SettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findFirst: {
            args: Prisma.SettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findMany: {
            args: Prisma.SettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          create: {
            args: Prisma.SettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          createMany: {
            args: Prisma.SettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          delete: {
            args: Prisma.SettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          update: {
            args: Prisma.SettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          deleteMany: {
            args: Prisma.SettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SettingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          upsert: {
            args: Prisma.SettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          aggregate: {
            args: Prisma.SettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSetting>
          }
          groupBy: {
            args: Prisma.SettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingCountArgs<ExtArgs>
            result: $Utils.Optional<SettingCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    metaAccount?: MetaAccountOmit
    adAccount?: AdAccountOmit
    campaign?: CampaignOmit
    campaignMetrics?: CampaignMetricsOmit
    adSet?: AdSetOmit
    adSetMetrics?: AdSetMetricsOmit
    ad?: AdOmit
    adMetrics?: AdMetricsOmit
    schedule?: ScheduleOmit
    adsPlanner?: AdsPlannerOmit
    plannerItem?: PlannerItemOmit
    socialMediaAccount?: SocialMediaAccountOmit
    platformMetrics?: PlatformMetricsOmit
    engagementMetrics?: EngagementMetricsOmit
    influencer?: InfluencerOmit
    influencerCampaigns?: InfluencerCampaignsOmit
    clinic?: ClinicOmit
    product?: ProductOmit
    income?: IncomeOmit
    payment?: PaymentOmit
    invoice?: InvoiceOmit
    rOASMetrics?: ROASMetricsOmit
    conversionMetrics?: ConversionMetricsOmit
    tag?: TagOmit
    tagsOnCampaigns?: TagsOnCampaignsOmit
    notification?: NotificationOmit
    setting?: SettingOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    metaAccounts: number
    socialAccounts: number
    campaigns: number
    adsets: number
    ads: number
    schedules: number
    payments: number
    invoices: number
    notifications: number
    influencers: number
    clinics: number
    products: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    metaAccounts?: boolean | UserCountOutputTypeCountMetaAccountsArgs
    socialAccounts?: boolean | UserCountOutputTypeCountSocialAccountsArgs
    campaigns?: boolean | UserCountOutputTypeCountCampaignsArgs
    adsets?: boolean | UserCountOutputTypeCountAdsetsArgs
    ads?: boolean | UserCountOutputTypeCountAdsArgs
    schedules?: boolean | UserCountOutputTypeCountSchedulesArgs
    payments?: boolean | UserCountOutputTypeCountPaymentsArgs
    invoices?: boolean | UserCountOutputTypeCountInvoicesArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    influencers?: boolean | UserCountOutputTypeCountInfluencersArgs
    clinics?: boolean | UserCountOutputTypeCountClinicsArgs
    products?: boolean | UserCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMetaAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MetaAccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSocialAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialMediaAccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAdsetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdSetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAdsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInfluencersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InfluencerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClinicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type MetaAccountCountOutputType
   */

  export type MetaAccountCountOutputType = {
    campaigns: number
    adSets: number
    ads: number
    adAccounts: number
  }

  export type MetaAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | MetaAccountCountOutputTypeCountCampaignsArgs
    adSets?: boolean | MetaAccountCountOutputTypeCountAdSetsArgs
    ads?: boolean | MetaAccountCountOutputTypeCountAdsArgs
    adAccounts?: boolean | MetaAccountCountOutputTypeCountAdAccountsArgs
  }

  // Custom InputTypes
  /**
   * MetaAccountCountOutputType without action
   */
  export type MetaAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaAccountCountOutputType
     */
    select?: MetaAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MetaAccountCountOutputType without action
   */
  export type MetaAccountCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }

  /**
   * MetaAccountCountOutputType without action
   */
  export type MetaAccountCountOutputTypeCountAdSetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdSetWhereInput
  }

  /**
   * MetaAccountCountOutputType without action
   */
  export type MetaAccountCountOutputTypeCountAdsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdWhereInput
  }

  /**
   * MetaAccountCountOutputType without action
   */
  export type MetaAccountCountOutputTypeCountAdAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdAccountWhereInput
  }


  /**
   * Count Type AdAccountCountOutputType
   */

  export type AdAccountCountOutputType = {
    campaigns: number
  }

  export type AdAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | AdAccountCountOutputTypeCountCampaignsArgs
  }

  // Custom InputTypes
  /**
   * AdAccountCountOutputType without action
   */
  export type AdAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdAccountCountOutputType
     */
    select?: AdAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdAccountCountOutputType without action
   */
  export type AdAccountCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }


  /**
   * Count Type CampaignCountOutputType
   */

  export type CampaignCountOutputType = {
    adSets: number
    tags: number
    metrics: number
  }

  export type CampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adSets?: boolean | CampaignCountOutputTypeCountAdSetsArgs
    tags?: boolean | CampaignCountOutputTypeCountTagsArgs
    metrics?: boolean | CampaignCountOutputTypeCountMetricsArgs
  }

  // Custom InputTypes
  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignCountOutputType
     */
    select?: CampaignCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountAdSetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdSetWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagsOnCampaignsWhereInput
  }

  /**
   * CampaignCountOutputType without action
   */
  export type CampaignCountOutputTypeCountMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignMetricsWhereInput
  }


  /**
   * Count Type AdSetCountOutputType
   */

  export type AdSetCountOutputType = {
    ads: number
    metrics: number
  }

  export type AdSetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ads?: boolean | AdSetCountOutputTypeCountAdsArgs
    metrics?: boolean | AdSetCountOutputTypeCountMetricsArgs
  }

  // Custom InputTypes
  /**
   * AdSetCountOutputType without action
   */
  export type AdSetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSetCountOutputType
     */
    select?: AdSetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdSetCountOutputType without action
   */
  export type AdSetCountOutputTypeCountAdsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdWhereInput
  }

  /**
   * AdSetCountOutputType without action
   */
  export type AdSetCountOutputTypeCountMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdSetMetricsWhereInput
  }


  /**
   * Count Type AdCountOutputType
   */

  export type AdCountOutputType = {
    metrics: number
    schedules: number
  }

  export type AdCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    metrics?: boolean | AdCountOutputTypeCountMetricsArgs
    schedules?: boolean | AdCountOutputTypeCountSchedulesArgs
  }

  // Custom InputTypes
  /**
   * AdCountOutputType without action
   */
  export type AdCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdCountOutputType
     */
    select?: AdCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdCountOutputType without action
   */
  export type AdCountOutputTypeCountMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdMetricsWhereInput
  }

  /**
   * AdCountOutputType without action
   */
  export type AdCountOutputTypeCountSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
  }


  /**
   * Count Type AdsPlannerCountOutputType
   */

  export type AdsPlannerCountOutputType = {
    planItems: number
  }

  export type AdsPlannerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planItems?: boolean | AdsPlannerCountOutputTypeCountPlanItemsArgs
  }

  // Custom InputTypes
  /**
   * AdsPlannerCountOutputType without action
   */
  export type AdsPlannerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsPlannerCountOutputType
     */
    select?: AdsPlannerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdsPlannerCountOutputType without action
   */
  export type AdsPlannerCountOutputTypeCountPlanItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlannerItemWhereInput
  }


  /**
   * Count Type SocialMediaAccountCountOutputType
   */

  export type SocialMediaAccountCountOutputType = {
    platformMetrics: number
    engagementMetrics: number
    influencers: number
  }

  export type SocialMediaAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    platformMetrics?: boolean | SocialMediaAccountCountOutputTypeCountPlatformMetricsArgs
    engagementMetrics?: boolean | SocialMediaAccountCountOutputTypeCountEngagementMetricsArgs
    influencers?: boolean | SocialMediaAccountCountOutputTypeCountInfluencersArgs
  }

  // Custom InputTypes
  /**
   * SocialMediaAccountCountOutputType without action
   */
  export type SocialMediaAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaAccountCountOutputType
     */
    select?: SocialMediaAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SocialMediaAccountCountOutputType without action
   */
  export type SocialMediaAccountCountOutputTypeCountPlatformMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlatformMetricsWhereInput
  }

  /**
   * SocialMediaAccountCountOutputType without action
   */
  export type SocialMediaAccountCountOutputTypeCountEngagementMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EngagementMetricsWhereInput
  }

  /**
   * SocialMediaAccountCountOutputType without action
   */
  export type SocialMediaAccountCountOutputTypeCountInfluencersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InfluencerWhereInput
  }


  /**
   * Count Type InfluencerCountOutputType
   */

  export type InfluencerCountOutputType = {
    campaigns: number
  }

  export type InfluencerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | InfluencerCountOutputTypeCountCampaignsArgs
  }

  // Custom InputTypes
  /**
   * InfluencerCountOutputType without action
   */
  export type InfluencerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfluencerCountOutputType
     */
    select?: InfluencerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InfluencerCountOutputType without action
   */
  export type InfluencerCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InfluencerCampaignsWhereInput
  }


  /**
   * Count Type ClinicCountOutputType
   */

  export type ClinicCountOutputType = {
    schedules: number
    campaigns: number
  }

  export type ClinicCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedules?: boolean | ClinicCountOutputTypeCountSchedulesArgs
    campaigns?: boolean | ClinicCountOutputTypeCountCampaignsArgs
  }

  // Custom InputTypes
  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicCountOutputType
     */
    select?: ClinicCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    schedules: number
    campaigns: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedules?: boolean | ProductCountOutputTypeCountSchedulesArgs
    campaigns?: boolean | ProductCountOutputTypeCountCampaignsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    payments: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | InvoiceCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    campaigns: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | TagCountOutputTypeCountCampaignsArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagsOnCampaignsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string | null
    name: string | null
    role: $Enums.UserRole
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metaAccounts?: boolean | User$metaAccountsArgs<ExtArgs>
    socialAccounts?: boolean | User$socialAccountsArgs<ExtArgs>
    campaigns?: boolean | User$campaignsArgs<ExtArgs>
    adsets?: boolean | User$adsetsArgs<ExtArgs>
    ads?: boolean | User$adsArgs<ExtArgs>
    schedules?: boolean | User$schedulesArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    invoices?: boolean | User$invoicesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    influencers?: boolean | User$influencersArgs<ExtArgs>
    clinics?: boolean | User$clinicsArgs<ExtArgs>
    products?: boolean | User$productsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "name" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    metaAccounts?: boolean | User$metaAccountsArgs<ExtArgs>
    socialAccounts?: boolean | User$socialAccountsArgs<ExtArgs>
    campaigns?: boolean | User$campaignsArgs<ExtArgs>
    adsets?: boolean | User$adsetsArgs<ExtArgs>
    ads?: boolean | User$adsArgs<ExtArgs>
    schedules?: boolean | User$schedulesArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    invoices?: boolean | User$invoicesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    influencers?: boolean | User$influencersArgs<ExtArgs>
    clinics?: boolean | User$clinicsArgs<ExtArgs>
    products?: boolean | User$productsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      metaAccounts: Prisma.$MetaAccountPayload<ExtArgs>[]
      socialAccounts: Prisma.$SocialMediaAccountPayload<ExtArgs>[]
      campaigns: Prisma.$CampaignPayload<ExtArgs>[]
      adsets: Prisma.$AdSetPayload<ExtArgs>[]
      ads: Prisma.$AdPayload<ExtArgs>[]
      schedules: Prisma.$SchedulePayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      influencers: Prisma.$InfluencerPayload<ExtArgs>[]
      clinics: Prisma.$ClinicPayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string | null
      name: string | null
      role: $Enums.UserRole
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    metaAccounts<T extends User$metaAccountsArgs<ExtArgs> = {}>(args?: Subset<T, User$metaAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MetaAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    socialAccounts<T extends User$socialAccountsArgs<ExtArgs> = {}>(args?: Subset<T, User$socialAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialMediaAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    campaigns<T extends User$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, User$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adsets<T extends User$adsetsArgs<ExtArgs> = {}>(args?: Subset<T, User$adsetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdSetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ads<T extends User$adsArgs<ExtArgs> = {}>(args?: Subset<T, User$adsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    schedules<T extends User$schedulesArgs<ExtArgs> = {}>(args?: Subset<T, User$schedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends User$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends User$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, User$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    influencers<T extends User$influencersArgs<ExtArgs> = {}>(args?: Subset<T, User$influencersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InfluencerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clinics<T extends User$clinicsArgs<ExtArgs> = {}>(args?: Subset<T, User$clinicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    products<T extends User$productsArgs<ExtArgs> = {}>(args?: Subset<T, User$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.metaAccounts
   */
  export type User$metaAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaAccount
     */
    select?: MetaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaAccount
     */
    omit?: MetaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaAccountInclude<ExtArgs> | null
    where?: MetaAccountWhereInput
    orderBy?: MetaAccountOrderByWithRelationInput | MetaAccountOrderByWithRelationInput[]
    cursor?: MetaAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MetaAccountScalarFieldEnum | MetaAccountScalarFieldEnum[]
  }

  /**
   * User.socialAccounts
   */
  export type User$socialAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaAccount
     */
    select?: SocialMediaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaAccount
     */
    omit?: SocialMediaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaAccountInclude<ExtArgs> | null
    where?: SocialMediaAccountWhereInput
    orderBy?: SocialMediaAccountOrderByWithRelationInput | SocialMediaAccountOrderByWithRelationInput[]
    cursor?: SocialMediaAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SocialMediaAccountScalarFieldEnum | SocialMediaAccountScalarFieldEnum[]
  }

  /**
   * User.campaigns
   */
  export type User$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * User.adsets
   */
  export type User$adsetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSet
     */
    select?: AdSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdSet
     */
    omit?: AdSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdSetInclude<ExtArgs> | null
    where?: AdSetWhereInput
    orderBy?: AdSetOrderByWithRelationInput | AdSetOrderByWithRelationInput[]
    cursor?: AdSetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdSetScalarFieldEnum | AdSetScalarFieldEnum[]
  }

  /**
   * User.ads
   */
  export type User$adsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    where?: AdWhereInput
    orderBy?: AdOrderByWithRelationInput | AdOrderByWithRelationInput[]
    cursor?: AdWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdScalarFieldEnum | AdScalarFieldEnum[]
  }

  /**
   * User.schedules
   */
  export type User$schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    cursor?: ScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * User.payments
   */
  export type User$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * User.invoices
   */
  export type User$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.influencers
   */
  export type User$influencersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Influencer
     */
    select?: InfluencerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Influencer
     */
    omit?: InfluencerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerInclude<ExtArgs> | null
    where?: InfluencerWhereInput
    orderBy?: InfluencerOrderByWithRelationInput | InfluencerOrderByWithRelationInput[]
    cursor?: InfluencerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InfluencerScalarFieldEnum | InfluencerScalarFieldEnum[]
  }

  /**
   * User.clinics
   */
  export type User$clinicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    where?: ClinicWhereInput
    orderBy?: ClinicOrderByWithRelationInput | ClinicOrderByWithRelationInput[]
    cursor?: ClinicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClinicScalarFieldEnum | ClinicScalarFieldEnum[]
  }

  /**
   * User.products
   */
  export type User$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model MetaAccount
   */

  export type AggregateMetaAccount = {
    _count: MetaAccountCountAggregateOutputType | null
    _min: MetaAccountMinAggregateOutputType | null
    _max: MetaAccountMaxAggregateOutputType | null
  }

  export type MetaAccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    metaAccountId: string | null
    accessToken: string | null
    refreshToken: string | null
    tokenExpiresAt: Date | null
    businessName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MetaAccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    metaAccountId: string | null
    accessToken: string | null
    refreshToken: string | null
    tokenExpiresAt: Date | null
    businessName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MetaAccountCountAggregateOutputType = {
    id: number
    userId: number
    metaAccountId: number
    accessToken: number
    refreshToken: number
    tokenExpiresAt: number
    businessName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MetaAccountMinAggregateInputType = {
    id?: true
    userId?: true
    metaAccountId?: true
    accessToken?: true
    refreshToken?: true
    tokenExpiresAt?: true
    businessName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MetaAccountMaxAggregateInputType = {
    id?: true
    userId?: true
    metaAccountId?: true
    accessToken?: true
    refreshToken?: true
    tokenExpiresAt?: true
    businessName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MetaAccountCountAggregateInputType = {
    id?: true
    userId?: true
    metaAccountId?: true
    accessToken?: true
    refreshToken?: true
    tokenExpiresAt?: true
    businessName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MetaAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MetaAccount to aggregate.
     */
    where?: MetaAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetaAccounts to fetch.
     */
    orderBy?: MetaAccountOrderByWithRelationInput | MetaAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MetaAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetaAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetaAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MetaAccounts
    **/
    _count?: true | MetaAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MetaAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MetaAccountMaxAggregateInputType
  }

  export type GetMetaAccountAggregateType<T extends MetaAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateMetaAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMetaAccount[P]>
      : GetScalarType<T[P], AggregateMetaAccount[P]>
  }




  export type MetaAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MetaAccountWhereInput
    orderBy?: MetaAccountOrderByWithAggregationInput | MetaAccountOrderByWithAggregationInput[]
    by: MetaAccountScalarFieldEnum[] | MetaAccountScalarFieldEnum
    having?: MetaAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MetaAccountCountAggregateInputType | true
    _min?: MetaAccountMinAggregateInputType
    _max?: MetaAccountMaxAggregateInputType
  }

  export type MetaAccountGroupByOutputType = {
    id: string
    userId: string
    metaAccountId: string
    accessToken: string
    refreshToken: string | null
    tokenExpiresAt: Date | null
    businessName: string | null
    createdAt: Date
    updatedAt: Date
    _count: MetaAccountCountAggregateOutputType | null
    _min: MetaAccountMinAggregateOutputType | null
    _max: MetaAccountMaxAggregateOutputType | null
  }

  type GetMetaAccountGroupByPayload<T extends MetaAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MetaAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MetaAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MetaAccountGroupByOutputType[P]>
            : GetScalarType<T[P], MetaAccountGroupByOutputType[P]>
        }
      >
    >


  export type MetaAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    metaAccountId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenExpiresAt?: boolean
    businessName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaigns?: boolean | MetaAccount$campaignsArgs<ExtArgs>
    adSets?: boolean | MetaAccount$adSetsArgs<ExtArgs>
    ads?: boolean | MetaAccount$adsArgs<ExtArgs>
    adAccounts?: boolean | MetaAccount$adAccountsArgs<ExtArgs>
    _count?: boolean | MetaAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["metaAccount"]>

  export type MetaAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    metaAccountId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenExpiresAt?: boolean
    businessName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["metaAccount"]>

  export type MetaAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    metaAccountId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenExpiresAt?: boolean
    businessName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["metaAccount"]>

  export type MetaAccountSelectScalar = {
    id?: boolean
    userId?: boolean
    metaAccountId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    tokenExpiresAt?: boolean
    businessName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MetaAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "metaAccountId" | "accessToken" | "refreshToken" | "tokenExpiresAt" | "businessName" | "createdAt" | "updatedAt", ExtArgs["result"]["metaAccount"]>
  export type MetaAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaigns?: boolean | MetaAccount$campaignsArgs<ExtArgs>
    adSets?: boolean | MetaAccount$adSetsArgs<ExtArgs>
    ads?: boolean | MetaAccount$adsArgs<ExtArgs>
    adAccounts?: boolean | MetaAccount$adAccountsArgs<ExtArgs>
    _count?: boolean | MetaAccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MetaAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MetaAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MetaAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MetaAccount"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      campaigns: Prisma.$CampaignPayload<ExtArgs>[]
      adSets: Prisma.$AdSetPayload<ExtArgs>[]
      ads: Prisma.$AdPayload<ExtArgs>[]
      adAccounts: Prisma.$AdAccountPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      metaAccountId: string
      accessToken: string
      refreshToken: string | null
      tokenExpiresAt: Date | null
      businessName: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["metaAccount"]>
    composites: {}
  }

  type MetaAccountGetPayload<S extends boolean | null | undefined | MetaAccountDefaultArgs> = $Result.GetResult<Prisma.$MetaAccountPayload, S>

  type MetaAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MetaAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MetaAccountCountAggregateInputType | true
    }

  export interface MetaAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MetaAccount'], meta: { name: 'MetaAccount' } }
    /**
     * Find zero or one MetaAccount that matches the filter.
     * @param {MetaAccountFindUniqueArgs} args - Arguments to find a MetaAccount
     * @example
     * // Get one MetaAccount
     * const metaAccount = await prisma.metaAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MetaAccountFindUniqueArgs>(args: SelectSubset<T, MetaAccountFindUniqueArgs<ExtArgs>>): Prisma__MetaAccountClient<$Result.GetResult<Prisma.$MetaAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MetaAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MetaAccountFindUniqueOrThrowArgs} args - Arguments to find a MetaAccount
     * @example
     * // Get one MetaAccount
     * const metaAccount = await prisma.metaAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MetaAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, MetaAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MetaAccountClient<$Result.GetResult<Prisma.$MetaAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MetaAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaAccountFindFirstArgs} args - Arguments to find a MetaAccount
     * @example
     * // Get one MetaAccount
     * const metaAccount = await prisma.metaAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MetaAccountFindFirstArgs>(args?: SelectSubset<T, MetaAccountFindFirstArgs<ExtArgs>>): Prisma__MetaAccountClient<$Result.GetResult<Prisma.$MetaAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MetaAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaAccountFindFirstOrThrowArgs} args - Arguments to find a MetaAccount
     * @example
     * // Get one MetaAccount
     * const metaAccount = await prisma.metaAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MetaAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, MetaAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__MetaAccountClient<$Result.GetResult<Prisma.$MetaAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MetaAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MetaAccounts
     * const metaAccounts = await prisma.metaAccount.findMany()
     * 
     * // Get first 10 MetaAccounts
     * const metaAccounts = await prisma.metaAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const metaAccountWithIdOnly = await prisma.metaAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MetaAccountFindManyArgs>(args?: SelectSubset<T, MetaAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MetaAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MetaAccount.
     * @param {MetaAccountCreateArgs} args - Arguments to create a MetaAccount.
     * @example
     * // Create one MetaAccount
     * const MetaAccount = await prisma.metaAccount.create({
     *   data: {
     *     // ... data to create a MetaAccount
     *   }
     * })
     * 
     */
    create<T extends MetaAccountCreateArgs>(args: SelectSubset<T, MetaAccountCreateArgs<ExtArgs>>): Prisma__MetaAccountClient<$Result.GetResult<Prisma.$MetaAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MetaAccounts.
     * @param {MetaAccountCreateManyArgs} args - Arguments to create many MetaAccounts.
     * @example
     * // Create many MetaAccounts
     * const metaAccount = await prisma.metaAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MetaAccountCreateManyArgs>(args?: SelectSubset<T, MetaAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MetaAccounts and returns the data saved in the database.
     * @param {MetaAccountCreateManyAndReturnArgs} args - Arguments to create many MetaAccounts.
     * @example
     * // Create many MetaAccounts
     * const metaAccount = await prisma.metaAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MetaAccounts and only return the `id`
     * const metaAccountWithIdOnly = await prisma.metaAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MetaAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, MetaAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MetaAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MetaAccount.
     * @param {MetaAccountDeleteArgs} args - Arguments to delete one MetaAccount.
     * @example
     * // Delete one MetaAccount
     * const MetaAccount = await prisma.metaAccount.delete({
     *   where: {
     *     // ... filter to delete one MetaAccount
     *   }
     * })
     * 
     */
    delete<T extends MetaAccountDeleteArgs>(args: SelectSubset<T, MetaAccountDeleteArgs<ExtArgs>>): Prisma__MetaAccountClient<$Result.GetResult<Prisma.$MetaAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MetaAccount.
     * @param {MetaAccountUpdateArgs} args - Arguments to update one MetaAccount.
     * @example
     * // Update one MetaAccount
     * const metaAccount = await prisma.metaAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MetaAccountUpdateArgs>(args: SelectSubset<T, MetaAccountUpdateArgs<ExtArgs>>): Prisma__MetaAccountClient<$Result.GetResult<Prisma.$MetaAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MetaAccounts.
     * @param {MetaAccountDeleteManyArgs} args - Arguments to filter MetaAccounts to delete.
     * @example
     * // Delete a few MetaAccounts
     * const { count } = await prisma.metaAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MetaAccountDeleteManyArgs>(args?: SelectSubset<T, MetaAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MetaAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MetaAccounts
     * const metaAccount = await prisma.metaAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MetaAccountUpdateManyArgs>(args: SelectSubset<T, MetaAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MetaAccounts and returns the data updated in the database.
     * @param {MetaAccountUpdateManyAndReturnArgs} args - Arguments to update many MetaAccounts.
     * @example
     * // Update many MetaAccounts
     * const metaAccount = await prisma.metaAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MetaAccounts and only return the `id`
     * const metaAccountWithIdOnly = await prisma.metaAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MetaAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, MetaAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MetaAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MetaAccount.
     * @param {MetaAccountUpsertArgs} args - Arguments to update or create a MetaAccount.
     * @example
     * // Update or create a MetaAccount
     * const metaAccount = await prisma.metaAccount.upsert({
     *   create: {
     *     // ... data to create a MetaAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MetaAccount we want to update
     *   }
     * })
     */
    upsert<T extends MetaAccountUpsertArgs>(args: SelectSubset<T, MetaAccountUpsertArgs<ExtArgs>>): Prisma__MetaAccountClient<$Result.GetResult<Prisma.$MetaAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MetaAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaAccountCountArgs} args - Arguments to filter MetaAccounts to count.
     * @example
     * // Count the number of MetaAccounts
     * const count = await prisma.metaAccount.count({
     *   where: {
     *     // ... the filter for the MetaAccounts we want to count
     *   }
     * })
    **/
    count<T extends MetaAccountCountArgs>(
      args?: Subset<T, MetaAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MetaAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MetaAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MetaAccountAggregateArgs>(args: Subset<T, MetaAccountAggregateArgs>): Prisma.PrismaPromise<GetMetaAccountAggregateType<T>>

    /**
     * Group by MetaAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MetaAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MetaAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MetaAccountGroupByArgs['orderBy'] }
        : { orderBy?: MetaAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MetaAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMetaAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MetaAccount model
   */
  readonly fields: MetaAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MetaAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MetaAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    campaigns<T extends MetaAccount$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, MetaAccount$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adSets<T extends MetaAccount$adSetsArgs<ExtArgs> = {}>(args?: Subset<T, MetaAccount$adSetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdSetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ads<T extends MetaAccount$adsArgs<ExtArgs> = {}>(args?: Subset<T, MetaAccount$adsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adAccounts<T extends MetaAccount$adAccountsArgs<ExtArgs> = {}>(args?: Subset<T, MetaAccount$adAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MetaAccount model
   */
  interface MetaAccountFieldRefs {
    readonly id: FieldRef<"MetaAccount", 'String'>
    readonly userId: FieldRef<"MetaAccount", 'String'>
    readonly metaAccountId: FieldRef<"MetaAccount", 'String'>
    readonly accessToken: FieldRef<"MetaAccount", 'String'>
    readonly refreshToken: FieldRef<"MetaAccount", 'String'>
    readonly tokenExpiresAt: FieldRef<"MetaAccount", 'DateTime'>
    readonly businessName: FieldRef<"MetaAccount", 'String'>
    readonly createdAt: FieldRef<"MetaAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"MetaAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MetaAccount findUnique
   */
  export type MetaAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaAccount
     */
    select?: MetaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaAccount
     */
    omit?: MetaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaAccountInclude<ExtArgs> | null
    /**
     * Filter, which MetaAccount to fetch.
     */
    where: MetaAccountWhereUniqueInput
  }

  /**
   * MetaAccount findUniqueOrThrow
   */
  export type MetaAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaAccount
     */
    select?: MetaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaAccount
     */
    omit?: MetaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaAccountInclude<ExtArgs> | null
    /**
     * Filter, which MetaAccount to fetch.
     */
    where: MetaAccountWhereUniqueInput
  }

  /**
   * MetaAccount findFirst
   */
  export type MetaAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaAccount
     */
    select?: MetaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaAccount
     */
    omit?: MetaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaAccountInclude<ExtArgs> | null
    /**
     * Filter, which MetaAccount to fetch.
     */
    where?: MetaAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetaAccounts to fetch.
     */
    orderBy?: MetaAccountOrderByWithRelationInput | MetaAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MetaAccounts.
     */
    cursor?: MetaAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetaAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetaAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MetaAccounts.
     */
    distinct?: MetaAccountScalarFieldEnum | MetaAccountScalarFieldEnum[]
  }

  /**
   * MetaAccount findFirstOrThrow
   */
  export type MetaAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaAccount
     */
    select?: MetaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaAccount
     */
    omit?: MetaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaAccountInclude<ExtArgs> | null
    /**
     * Filter, which MetaAccount to fetch.
     */
    where?: MetaAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetaAccounts to fetch.
     */
    orderBy?: MetaAccountOrderByWithRelationInput | MetaAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MetaAccounts.
     */
    cursor?: MetaAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetaAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetaAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MetaAccounts.
     */
    distinct?: MetaAccountScalarFieldEnum | MetaAccountScalarFieldEnum[]
  }

  /**
   * MetaAccount findMany
   */
  export type MetaAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaAccount
     */
    select?: MetaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaAccount
     */
    omit?: MetaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaAccountInclude<ExtArgs> | null
    /**
     * Filter, which MetaAccounts to fetch.
     */
    where?: MetaAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MetaAccounts to fetch.
     */
    orderBy?: MetaAccountOrderByWithRelationInput | MetaAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MetaAccounts.
     */
    cursor?: MetaAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MetaAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MetaAccounts.
     */
    skip?: number
    distinct?: MetaAccountScalarFieldEnum | MetaAccountScalarFieldEnum[]
  }

  /**
   * MetaAccount create
   */
  export type MetaAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaAccount
     */
    select?: MetaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaAccount
     */
    omit?: MetaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a MetaAccount.
     */
    data: XOR<MetaAccountCreateInput, MetaAccountUncheckedCreateInput>
  }

  /**
   * MetaAccount createMany
   */
  export type MetaAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MetaAccounts.
     */
    data: MetaAccountCreateManyInput | MetaAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MetaAccount createManyAndReturn
   */
  export type MetaAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaAccount
     */
    select?: MetaAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MetaAccount
     */
    omit?: MetaAccountOmit<ExtArgs> | null
    /**
     * The data used to create many MetaAccounts.
     */
    data: MetaAccountCreateManyInput | MetaAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MetaAccount update
   */
  export type MetaAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaAccount
     */
    select?: MetaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaAccount
     */
    omit?: MetaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a MetaAccount.
     */
    data: XOR<MetaAccountUpdateInput, MetaAccountUncheckedUpdateInput>
    /**
     * Choose, which MetaAccount to update.
     */
    where: MetaAccountWhereUniqueInput
  }

  /**
   * MetaAccount updateMany
   */
  export type MetaAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MetaAccounts.
     */
    data: XOR<MetaAccountUpdateManyMutationInput, MetaAccountUncheckedUpdateManyInput>
    /**
     * Filter which MetaAccounts to update
     */
    where?: MetaAccountWhereInput
    /**
     * Limit how many MetaAccounts to update.
     */
    limit?: number
  }

  /**
   * MetaAccount updateManyAndReturn
   */
  export type MetaAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaAccount
     */
    select?: MetaAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MetaAccount
     */
    omit?: MetaAccountOmit<ExtArgs> | null
    /**
     * The data used to update MetaAccounts.
     */
    data: XOR<MetaAccountUpdateManyMutationInput, MetaAccountUncheckedUpdateManyInput>
    /**
     * Filter which MetaAccounts to update
     */
    where?: MetaAccountWhereInput
    /**
     * Limit how many MetaAccounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaAccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MetaAccount upsert
   */
  export type MetaAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaAccount
     */
    select?: MetaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaAccount
     */
    omit?: MetaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the MetaAccount to update in case it exists.
     */
    where: MetaAccountWhereUniqueInput
    /**
     * In case the MetaAccount found by the `where` argument doesn't exist, create a new MetaAccount with this data.
     */
    create: XOR<MetaAccountCreateInput, MetaAccountUncheckedCreateInput>
    /**
     * In case the MetaAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MetaAccountUpdateInput, MetaAccountUncheckedUpdateInput>
  }

  /**
   * MetaAccount delete
   */
  export type MetaAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaAccount
     */
    select?: MetaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaAccount
     */
    omit?: MetaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaAccountInclude<ExtArgs> | null
    /**
     * Filter which MetaAccount to delete.
     */
    where: MetaAccountWhereUniqueInput
  }

  /**
   * MetaAccount deleteMany
   */
  export type MetaAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MetaAccounts to delete
     */
    where?: MetaAccountWhereInput
    /**
     * Limit how many MetaAccounts to delete.
     */
    limit?: number
  }

  /**
   * MetaAccount.campaigns
   */
  export type MetaAccount$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * MetaAccount.adSets
   */
  export type MetaAccount$adSetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSet
     */
    select?: AdSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdSet
     */
    omit?: AdSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdSetInclude<ExtArgs> | null
    where?: AdSetWhereInput
    orderBy?: AdSetOrderByWithRelationInput | AdSetOrderByWithRelationInput[]
    cursor?: AdSetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdSetScalarFieldEnum | AdSetScalarFieldEnum[]
  }

  /**
   * MetaAccount.ads
   */
  export type MetaAccount$adsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    where?: AdWhereInput
    orderBy?: AdOrderByWithRelationInput | AdOrderByWithRelationInput[]
    cursor?: AdWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdScalarFieldEnum | AdScalarFieldEnum[]
  }

  /**
   * MetaAccount.adAccounts
   */
  export type MetaAccount$adAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdAccount
     */
    select?: AdAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdAccount
     */
    omit?: AdAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdAccountInclude<ExtArgs> | null
    where?: AdAccountWhereInput
    orderBy?: AdAccountOrderByWithRelationInput | AdAccountOrderByWithRelationInput[]
    cursor?: AdAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdAccountScalarFieldEnum | AdAccountScalarFieldEnum[]
  }

  /**
   * MetaAccount without action
   */
  export type MetaAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaAccount
     */
    select?: MetaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaAccount
     */
    omit?: MetaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaAccountInclude<ExtArgs> | null
  }


  /**
   * Model AdAccount
   */

  export type AggregateAdAccount = {
    _count: AdAccountCountAggregateOutputType | null
    _min: AdAccountMinAggregateOutputType | null
    _max: AdAccountMaxAggregateOutputType | null
  }

  export type AdAccountMinAggregateOutputType = {
    id: string | null
    metaAccountId: string | null
    adAccountId: string | null
    name: string | null
    currency: string | null
    timezone: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdAccountMaxAggregateOutputType = {
    id: string | null
    metaAccountId: string | null
    adAccountId: string | null
    name: string | null
    currency: string | null
    timezone: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdAccountCountAggregateOutputType = {
    id: number
    metaAccountId: number
    adAccountId: number
    name: number
    currency: number
    timezone: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdAccountMinAggregateInputType = {
    id?: true
    metaAccountId?: true
    adAccountId?: true
    name?: true
    currency?: true
    timezone?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdAccountMaxAggregateInputType = {
    id?: true
    metaAccountId?: true
    adAccountId?: true
    name?: true
    currency?: true
    timezone?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdAccountCountAggregateInputType = {
    id?: true
    metaAccountId?: true
    adAccountId?: true
    name?: true
    currency?: true
    timezone?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdAccount to aggregate.
     */
    where?: AdAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdAccounts to fetch.
     */
    orderBy?: AdAccountOrderByWithRelationInput | AdAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdAccounts
    **/
    _count?: true | AdAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdAccountMaxAggregateInputType
  }

  export type GetAdAccountAggregateType<T extends AdAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAdAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdAccount[P]>
      : GetScalarType<T[P], AggregateAdAccount[P]>
  }




  export type AdAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdAccountWhereInput
    orderBy?: AdAccountOrderByWithAggregationInput | AdAccountOrderByWithAggregationInput[]
    by: AdAccountScalarFieldEnum[] | AdAccountScalarFieldEnum
    having?: AdAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdAccountCountAggregateInputType | true
    _min?: AdAccountMinAggregateInputType
    _max?: AdAccountMaxAggregateInputType
  }

  export type AdAccountGroupByOutputType = {
    id: string
    metaAccountId: string
    adAccountId: string
    name: string
    currency: string
    timezone: string
    status: string
    createdAt: Date
    updatedAt: Date
    _count: AdAccountCountAggregateOutputType | null
    _min: AdAccountMinAggregateOutputType | null
    _max: AdAccountMaxAggregateOutputType | null
  }

  type GetAdAccountGroupByPayload<T extends AdAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdAccountGroupByOutputType[P]>
            : GetScalarType<T[P], AdAccountGroupByOutputType[P]>
        }
      >
    >


  export type AdAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metaAccountId?: boolean
    adAccountId?: boolean
    name?: boolean
    currency?: boolean
    timezone?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metaAccount?: boolean | MetaAccountDefaultArgs<ExtArgs>
    campaigns?: boolean | AdAccount$campaignsArgs<ExtArgs>
    _count?: boolean | AdAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adAccount"]>

  export type AdAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metaAccountId?: boolean
    adAccountId?: boolean
    name?: boolean
    currency?: boolean
    timezone?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metaAccount?: boolean | MetaAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adAccount"]>

  export type AdAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    metaAccountId?: boolean
    adAccountId?: boolean
    name?: boolean
    currency?: boolean
    timezone?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metaAccount?: boolean | MetaAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adAccount"]>

  export type AdAccountSelectScalar = {
    id?: boolean
    metaAccountId?: boolean
    adAccountId?: boolean
    name?: boolean
    currency?: boolean
    timezone?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "metaAccountId" | "adAccountId" | "name" | "currency" | "timezone" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["adAccount"]>
  export type AdAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    metaAccount?: boolean | MetaAccountDefaultArgs<ExtArgs>
    campaigns?: boolean | AdAccount$campaignsArgs<ExtArgs>
    _count?: boolean | AdAccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    metaAccount?: boolean | MetaAccountDefaultArgs<ExtArgs>
  }
  export type AdAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    metaAccount?: boolean | MetaAccountDefaultArgs<ExtArgs>
  }

  export type $AdAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdAccount"
    objects: {
      metaAccount: Prisma.$MetaAccountPayload<ExtArgs>
      campaigns: Prisma.$CampaignPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      metaAccountId: string
      adAccountId: string
      name: string
      currency: string
      timezone: string
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["adAccount"]>
    composites: {}
  }

  type AdAccountGetPayload<S extends boolean | null | undefined | AdAccountDefaultArgs> = $Result.GetResult<Prisma.$AdAccountPayload, S>

  type AdAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdAccountCountAggregateInputType | true
    }

  export interface AdAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdAccount'], meta: { name: 'AdAccount' } }
    /**
     * Find zero or one AdAccount that matches the filter.
     * @param {AdAccountFindUniqueArgs} args - Arguments to find a AdAccount
     * @example
     * // Get one AdAccount
     * const adAccount = await prisma.adAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdAccountFindUniqueArgs>(args: SelectSubset<T, AdAccountFindUniqueArgs<ExtArgs>>): Prisma__AdAccountClient<$Result.GetResult<Prisma.$AdAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdAccountFindUniqueOrThrowArgs} args - Arguments to find a AdAccount
     * @example
     * // Get one AdAccount
     * const adAccount = await prisma.adAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AdAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdAccountClient<$Result.GetResult<Prisma.$AdAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdAccountFindFirstArgs} args - Arguments to find a AdAccount
     * @example
     * // Get one AdAccount
     * const adAccount = await prisma.adAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdAccountFindFirstArgs>(args?: SelectSubset<T, AdAccountFindFirstArgs<ExtArgs>>): Prisma__AdAccountClient<$Result.GetResult<Prisma.$AdAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdAccountFindFirstOrThrowArgs} args - Arguments to find a AdAccount
     * @example
     * // Get one AdAccount
     * const adAccount = await prisma.adAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AdAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdAccountClient<$Result.GetResult<Prisma.$AdAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdAccounts
     * const adAccounts = await prisma.adAccount.findMany()
     * 
     * // Get first 10 AdAccounts
     * const adAccounts = await prisma.adAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adAccountWithIdOnly = await prisma.adAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdAccountFindManyArgs>(args?: SelectSubset<T, AdAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdAccount.
     * @param {AdAccountCreateArgs} args - Arguments to create a AdAccount.
     * @example
     * // Create one AdAccount
     * const AdAccount = await prisma.adAccount.create({
     *   data: {
     *     // ... data to create a AdAccount
     *   }
     * })
     * 
     */
    create<T extends AdAccountCreateArgs>(args: SelectSubset<T, AdAccountCreateArgs<ExtArgs>>): Prisma__AdAccountClient<$Result.GetResult<Prisma.$AdAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdAccounts.
     * @param {AdAccountCreateManyArgs} args - Arguments to create many AdAccounts.
     * @example
     * // Create many AdAccounts
     * const adAccount = await prisma.adAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdAccountCreateManyArgs>(args?: SelectSubset<T, AdAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdAccounts and returns the data saved in the database.
     * @param {AdAccountCreateManyAndReturnArgs} args - Arguments to create many AdAccounts.
     * @example
     * // Create many AdAccounts
     * const adAccount = await prisma.adAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdAccounts and only return the `id`
     * const adAccountWithIdOnly = await prisma.adAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AdAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdAccount.
     * @param {AdAccountDeleteArgs} args - Arguments to delete one AdAccount.
     * @example
     * // Delete one AdAccount
     * const AdAccount = await prisma.adAccount.delete({
     *   where: {
     *     // ... filter to delete one AdAccount
     *   }
     * })
     * 
     */
    delete<T extends AdAccountDeleteArgs>(args: SelectSubset<T, AdAccountDeleteArgs<ExtArgs>>): Prisma__AdAccountClient<$Result.GetResult<Prisma.$AdAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdAccount.
     * @param {AdAccountUpdateArgs} args - Arguments to update one AdAccount.
     * @example
     * // Update one AdAccount
     * const adAccount = await prisma.adAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdAccountUpdateArgs>(args: SelectSubset<T, AdAccountUpdateArgs<ExtArgs>>): Prisma__AdAccountClient<$Result.GetResult<Prisma.$AdAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdAccounts.
     * @param {AdAccountDeleteManyArgs} args - Arguments to filter AdAccounts to delete.
     * @example
     * // Delete a few AdAccounts
     * const { count } = await prisma.adAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdAccountDeleteManyArgs>(args?: SelectSubset<T, AdAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdAccounts
     * const adAccount = await prisma.adAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdAccountUpdateManyArgs>(args: SelectSubset<T, AdAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdAccounts and returns the data updated in the database.
     * @param {AdAccountUpdateManyAndReturnArgs} args - Arguments to update many AdAccounts.
     * @example
     * // Update many AdAccounts
     * const adAccount = await prisma.adAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdAccounts and only return the `id`
     * const adAccountWithIdOnly = await prisma.adAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AdAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdAccount.
     * @param {AdAccountUpsertArgs} args - Arguments to update or create a AdAccount.
     * @example
     * // Update or create a AdAccount
     * const adAccount = await prisma.adAccount.upsert({
     *   create: {
     *     // ... data to create a AdAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdAccount we want to update
     *   }
     * })
     */
    upsert<T extends AdAccountUpsertArgs>(args: SelectSubset<T, AdAccountUpsertArgs<ExtArgs>>): Prisma__AdAccountClient<$Result.GetResult<Prisma.$AdAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdAccountCountArgs} args - Arguments to filter AdAccounts to count.
     * @example
     * // Count the number of AdAccounts
     * const count = await prisma.adAccount.count({
     *   where: {
     *     // ... the filter for the AdAccounts we want to count
     *   }
     * })
    **/
    count<T extends AdAccountCountArgs>(
      args?: Subset<T, AdAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdAccountAggregateArgs>(args: Subset<T, AdAccountAggregateArgs>): Prisma.PrismaPromise<GetAdAccountAggregateType<T>>

    /**
     * Group by AdAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdAccountGroupByArgs['orderBy'] }
        : { orderBy?: AdAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdAccount model
   */
  readonly fields: AdAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    metaAccount<T extends MetaAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MetaAccountDefaultArgs<ExtArgs>>): Prisma__MetaAccountClient<$Result.GetResult<Prisma.$MetaAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    campaigns<T extends AdAccount$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, AdAccount$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdAccount model
   */
  interface AdAccountFieldRefs {
    readonly id: FieldRef<"AdAccount", 'String'>
    readonly metaAccountId: FieldRef<"AdAccount", 'String'>
    readonly adAccountId: FieldRef<"AdAccount", 'String'>
    readonly name: FieldRef<"AdAccount", 'String'>
    readonly currency: FieldRef<"AdAccount", 'String'>
    readonly timezone: FieldRef<"AdAccount", 'String'>
    readonly status: FieldRef<"AdAccount", 'String'>
    readonly createdAt: FieldRef<"AdAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"AdAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdAccount findUnique
   */
  export type AdAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdAccount
     */
    select?: AdAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdAccount
     */
    omit?: AdAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdAccountInclude<ExtArgs> | null
    /**
     * Filter, which AdAccount to fetch.
     */
    where: AdAccountWhereUniqueInput
  }

  /**
   * AdAccount findUniqueOrThrow
   */
  export type AdAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdAccount
     */
    select?: AdAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdAccount
     */
    omit?: AdAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdAccountInclude<ExtArgs> | null
    /**
     * Filter, which AdAccount to fetch.
     */
    where: AdAccountWhereUniqueInput
  }

  /**
   * AdAccount findFirst
   */
  export type AdAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdAccount
     */
    select?: AdAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdAccount
     */
    omit?: AdAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdAccountInclude<ExtArgs> | null
    /**
     * Filter, which AdAccount to fetch.
     */
    where?: AdAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdAccounts to fetch.
     */
    orderBy?: AdAccountOrderByWithRelationInput | AdAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdAccounts.
     */
    cursor?: AdAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdAccounts.
     */
    distinct?: AdAccountScalarFieldEnum | AdAccountScalarFieldEnum[]
  }

  /**
   * AdAccount findFirstOrThrow
   */
  export type AdAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdAccount
     */
    select?: AdAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdAccount
     */
    omit?: AdAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdAccountInclude<ExtArgs> | null
    /**
     * Filter, which AdAccount to fetch.
     */
    where?: AdAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdAccounts to fetch.
     */
    orderBy?: AdAccountOrderByWithRelationInput | AdAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdAccounts.
     */
    cursor?: AdAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdAccounts.
     */
    distinct?: AdAccountScalarFieldEnum | AdAccountScalarFieldEnum[]
  }

  /**
   * AdAccount findMany
   */
  export type AdAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdAccount
     */
    select?: AdAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdAccount
     */
    omit?: AdAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdAccountInclude<ExtArgs> | null
    /**
     * Filter, which AdAccounts to fetch.
     */
    where?: AdAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdAccounts to fetch.
     */
    orderBy?: AdAccountOrderByWithRelationInput | AdAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdAccounts.
     */
    cursor?: AdAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdAccounts.
     */
    skip?: number
    distinct?: AdAccountScalarFieldEnum | AdAccountScalarFieldEnum[]
  }

  /**
   * AdAccount create
   */
  export type AdAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdAccount
     */
    select?: AdAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdAccount
     */
    omit?: AdAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a AdAccount.
     */
    data: XOR<AdAccountCreateInput, AdAccountUncheckedCreateInput>
  }

  /**
   * AdAccount createMany
   */
  export type AdAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdAccounts.
     */
    data: AdAccountCreateManyInput | AdAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdAccount createManyAndReturn
   */
  export type AdAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdAccount
     */
    select?: AdAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdAccount
     */
    omit?: AdAccountOmit<ExtArgs> | null
    /**
     * The data used to create many AdAccounts.
     */
    data: AdAccountCreateManyInput | AdAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdAccount update
   */
  export type AdAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdAccount
     */
    select?: AdAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdAccount
     */
    omit?: AdAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a AdAccount.
     */
    data: XOR<AdAccountUpdateInput, AdAccountUncheckedUpdateInput>
    /**
     * Choose, which AdAccount to update.
     */
    where: AdAccountWhereUniqueInput
  }

  /**
   * AdAccount updateMany
   */
  export type AdAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdAccounts.
     */
    data: XOR<AdAccountUpdateManyMutationInput, AdAccountUncheckedUpdateManyInput>
    /**
     * Filter which AdAccounts to update
     */
    where?: AdAccountWhereInput
    /**
     * Limit how many AdAccounts to update.
     */
    limit?: number
  }

  /**
   * AdAccount updateManyAndReturn
   */
  export type AdAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdAccount
     */
    select?: AdAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdAccount
     */
    omit?: AdAccountOmit<ExtArgs> | null
    /**
     * The data used to update AdAccounts.
     */
    data: XOR<AdAccountUpdateManyMutationInput, AdAccountUncheckedUpdateManyInput>
    /**
     * Filter which AdAccounts to update
     */
    where?: AdAccountWhereInput
    /**
     * Limit how many AdAccounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdAccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdAccount upsert
   */
  export type AdAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdAccount
     */
    select?: AdAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdAccount
     */
    omit?: AdAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the AdAccount to update in case it exists.
     */
    where: AdAccountWhereUniqueInput
    /**
     * In case the AdAccount found by the `where` argument doesn't exist, create a new AdAccount with this data.
     */
    create: XOR<AdAccountCreateInput, AdAccountUncheckedCreateInput>
    /**
     * In case the AdAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdAccountUpdateInput, AdAccountUncheckedUpdateInput>
  }

  /**
   * AdAccount delete
   */
  export type AdAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdAccount
     */
    select?: AdAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdAccount
     */
    omit?: AdAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdAccountInclude<ExtArgs> | null
    /**
     * Filter which AdAccount to delete.
     */
    where: AdAccountWhereUniqueInput
  }

  /**
   * AdAccount deleteMany
   */
  export type AdAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdAccounts to delete
     */
    where?: AdAccountWhereInput
    /**
     * Limit how many AdAccounts to delete.
     */
    limit?: number
  }

  /**
   * AdAccount.campaigns
   */
  export type AdAccount$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * AdAccount without action
   */
  export type AdAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdAccount
     */
    select?: AdAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdAccount
     */
    omit?: AdAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdAccountInclude<ExtArgs> | null
  }


  /**
   * Model Campaign
   */

  export type AggregateCampaign = {
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  export type CampaignAvgAggregateOutputType = {
    budget: number | null
  }

  export type CampaignSumAggregateOutputType = {
    budget: number | null
  }

  export type CampaignMinAggregateOutputType = {
    id: string | null
    userId: string | null
    metaAccountId: string | null
    adAccountId: string | null
    campaignId: string | null
    name: string | null
    objective: string | null
    status: $Enums.CampaignStatus | null
    budget: number | null
    budgetType: $Enums.BudgetType | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    clinicId: string | null
    productId: string | null
  }

  export type CampaignMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    metaAccountId: string | null
    adAccountId: string | null
    campaignId: string | null
    name: string | null
    objective: string | null
    status: $Enums.CampaignStatus | null
    budget: number | null
    budgetType: $Enums.BudgetType | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    clinicId: string | null
    productId: string | null
  }

  export type CampaignCountAggregateOutputType = {
    id: number
    userId: number
    metaAccountId: number
    adAccountId: number
    campaignId: number
    name: number
    objective: number
    status: number
    budget: number
    budgetType: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    clinicId: number
    productId: number
    _all: number
  }


  export type CampaignAvgAggregateInputType = {
    budget?: true
  }

  export type CampaignSumAggregateInputType = {
    budget?: true
  }

  export type CampaignMinAggregateInputType = {
    id?: true
    userId?: true
    metaAccountId?: true
    adAccountId?: true
    campaignId?: true
    name?: true
    objective?: true
    status?: true
    budget?: true
    budgetType?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    clinicId?: true
    productId?: true
  }

  export type CampaignMaxAggregateInputType = {
    id?: true
    userId?: true
    metaAccountId?: true
    adAccountId?: true
    campaignId?: true
    name?: true
    objective?: true
    status?: true
    budget?: true
    budgetType?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    clinicId?: true
    productId?: true
  }

  export type CampaignCountAggregateInputType = {
    id?: true
    userId?: true
    metaAccountId?: true
    adAccountId?: true
    campaignId?: true
    name?: true
    objective?: true
    status?: true
    budget?: true
    budgetType?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    clinicId?: true
    productId?: true
    _all?: true
  }

  export type CampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaign to aggregate.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Campaigns
    **/
    _count?: true | CampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMaxAggregateInputType
  }

  export type GetCampaignAggregateType<T extends CampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaign[P]>
      : GetScalarType<T[P], AggregateCampaign[P]>
  }




  export type CampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithAggregationInput | CampaignOrderByWithAggregationInput[]
    by: CampaignScalarFieldEnum[] | CampaignScalarFieldEnum
    having?: CampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignCountAggregateInputType | true
    _avg?: CampaignAvgAggregateInputType
    _sum?: CampaignSumAggregateInputType
    _min?: CampaignMinAggregateInputType
    _max?: CampaignMaxAggregateInputType
  }

  export type CampaignGroupByOutputType = {
    id: string
    userId: string
    metaAccountId: string | null
    adAccountId: string | null
    campaignId: string | null
    name: string
    objective: string
    status: $Enums.CampaignStatus
    budget: number | null
    budgetType: $Enums.BudgetType | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date
    updatedAt: Date
    clinicId: string | null
    productId: string | null
    _count: CampaignCountAggregateOutputType | null
    _avg: CampaignAvgAggregateOutputType | null
    _sum: CampaignSumAggregateOutputType | null
    _min: CampaignMinAggregateOutputType | null
    _max: CampaignMaxAggregateOutputType | null
  }

  type GetCampaignGroupByPayload<T extends CampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignGroupByOutputType[P]>
        }
      >
    >


  export type CampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    metaAccountId?: boolean
    adAccountId?: boolean
    campaignId?: boolean
    name?: boolean
    objective?: boolean
    status?: boolean
    budget?: boolean
    budgetType?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinicId?: boolean
    productId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    metaAccount?: boolean | Campaign$metaAccountArgs<ExtArgs>
    adAccount?: boolean | Campaign$adAccountArgs<ExtArgs>
    adSets?: boolean | Campaign$adSetsArgs<ExtArgs>
    tags?: boolean | Campaign$tagsArgs<ExtArgs>
    metrics?: boolean | Campaign$metricsArgs<ExtArgs>
    clinic?: boolean | Campaign$clinicArgs<ExtArgs>
    product?: boolean | Campaign$productArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    metaAccountId?: boolean
    adAccountId?: boolean
    campaignId?: boolean
    name?: boolean
    objective?: boolean
    status?: boolean
    budget?: boolean
    budgetType?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinicId?: boolean
    productId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    metaAccount?: boolean | Campaign$metaAccountArgs<ExtArgs>
    adAccount?: boolean | Campaign$adAccountArgs<ExtArgs>
    clinic?: boolean | Campaign$clinicArgs<ExtArgs>
    product?: boolean | Campaign$productArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    metaAccountId?: boolean
    adAccountId?: boolean
    campaignId?: boolean
    name?: boolean
    objective?: boolean
    status?: boolean
    budget?: boolean
    budgetType?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinicId?: boolean
    productId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    metaAccount?: boolean | Campaign$metaAccountArgs<ExtArgs>
    adAccount?: boolean | Campaign$adAccountArgs<ExtArgs>
    clinic?: boolean | Campaign$clinicArgs<ExtArgs>
    product?: boolean | Campaign$productArgs<ExtArgs>
  }, ExtArgs["result"]["campaign"]>

  export type CampaignSelectScalar = {
    id?: boolean
    userId?: boolean
    metaAccountId?: boolean
    adAccountId?: boolean
    campaignId?: boolean
    name?: boolean
    objective?: boolean
    status?: boolean
    budget?: boolean
    budgetType?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinicId?: boolean
    productId?: boolean
  }

  export type CampaignOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "metaAccountId" | "adAccountId" | "campaignId" | "name" | "objective" | "status" | "budget" | "budgetType" | "startDate" | "endDate" | "createdAt" | "updatedAt" | "clinicId" | "productId", ExtArgs["result"]["campaign"]>
  export type CampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    metaAccount?: boolean | Campaign$metaAccountArgs<ExtArgs>
    adAccount?: boolean | Campaign$adAccountArgs<ExtArgs>
    adSets?: boolean | Campaign$adSetsArgs<ExtArgs>
    tags?: boolean | Campaign$tagsArgs<ExtArgs>
    metrics?: boolean | Campaign$metricsArgs<ExtArgs>
    clinic?: boolean | Campaign$clinicArgs<ExtArgs>
    product?: boolean | Campaign$productArgs<ExtArgs>
    _count?: boolean | CampaignCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CampaignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    metaAccount?: boolean | Campaign$metaAccountArgs<ExtArgs>
    adAccount?: boolean | Campaign$adAccountArgs<ExtArgs>
    clinic?: boolean | Campaign$clinicArgs<ExtArgs>
    product?: boolean | Campaign$productArgs<ExtArgs>
  }
  export type CampaignIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    metaAccount?: boolean | Campaign$metaAccountArgs<ExtArgs>
    adAccount?: boolean | Campaign$adAccountArgs<ExtArgs>
    clinic?: boolean | Campaign$clinicArgs<ExtArgs>
    product?: boolean | Campaign$productArgs<ExtArgs>
  }

  export type $CampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Campaign"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      metaAccount: Prisma.$MetaAccountPayload<ExtArgs> | null
      adAccount: Prisma.$AdAccountPayload<ExtArgs> | null
      adSets: Prisma.$AdSetPayload<ExtArgs>[]
      tags: Prisma.$TagsOnCampaignsPayload<ExtArgs>[]
      metrics: Prisma.$CampaignMetricsPayload<ExtArgs>[]
      clinic: Prisma.$ClinicPayload<ExtArgs> | null
      product: Prisma.$ProductPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      metaAccountId: string | null
      adAccountId: string | null
      campaignId: string | null
      name: string
      objective: string
      status: $Enums.CampaignStatus
      budget: number | null
      budgetType: $Enums.BudgetType | null
      startDate: Date | null
      endDate: Date | null
      createdAt: Date
      updatedAt: Date
      clinicId: string | null
      productId: string | null
    }, ExtArgs["result"]["campaign"]>
    composites: {}
  }

  type CampaignGetPayload<S extends boolean | null | undefined | CampaignDefaultArgs> = $Result.GetResult<Prisma.$CampaignPayload, S>

  type CampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CampaignFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CampaignCountAggregateInputType | true
    }

  export interface CampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Campaign'], meta: { name: 'Campaign' } }
    /**
     * Find zero or one Campaign that matches the filter.
     * @param {CampaignFindUniqueArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignFindUniqueArgs>(args: SelectSubset<T, CampaignFindUniqueArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Campaign that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CampaignFindUniqueOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Campaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignFindFirstArgs>(args?: SelectSubset<T, CampaignFindFirstArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Campaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindFirstOrThrowArgs} args - Arguments to find a Campaign
     * @example
     * // Get one Campaign
     * const campaign = await prisma.campaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Campaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Campaigns
     * const campaigns = await prisma.campaign.findMany()
     * 
     * // Get first 10 Campaigns
     * const campaigns = await prisma.campaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignWithIdOnly = await prisma.campaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignFindManyArgs>(args?: SelectSubset<T, CampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Campaign.
     * @param {CampaignCreateArgs} args - Arguments to create a Campaign.
     * @example
     * // Create one Campaign
     * const Campaign = await prisma.campaign.create({
     *   data: {
     *     // ... data to create a Campaign
     *   }
     * })
     * 
     */
    create<T extends CampaignCreateArgs>(args: SelectSubset<T, CampaignCreateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Campaigns.
     * @param {CampaignCreateManyArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignCreateManyArgs>(args?: SelectSubset<T, CampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Campaigns and returns the data saved in the database.
     * @param {CampaignCreateManyAndReturnArgs} args - Arguments to create many Campaigns.
     * @example
     * // Create many Campaigns
     * const campaign = await prisma.campaign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Campaigns and only return the `id`
     * const campaignWithIdOnly = await prisma.campaign.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Campaign.
     * @param {CampaignDeleteArgs} args - Arguments to delete one Campaign.
     * @example
     * // Delete one Campaign
     * const Campaign = await prisma.campaign.delete({
     *   where: {
     *     // ... filter to delete one Campaign
     *   }
     * })
     * 
     */
    delete<T extends CampaignDeleteArgs>(args: SelectSubset<T, CampaignDeleteArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Campaign.
     * @param {CampaignUpdateArgs} args - Arguments to update one Campaign.
     * @example
     * // Update one Campaign
     * const campaign = await prisma.campaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignUpdateArgs>(args: SelectSubset<T, CampaignUpdateArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Campaigns.
     * @param {CampaignDeleteManyArgs} args - Arguments to filter Campaigns to delete.
     * @example
     * // Delete a few Campaigns
     * const { count } = await prisma.campaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignDeleteManyArgs>(args?: SelectSubset<T, CampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignUpdateManyArgs>(args: SelectSubset<T, CampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Campaigns and returns the data updated in the database.
     * @param {CampaignUpdateManyAndReturnArgs} args - Arguments to update many Campaigns.
     * @example
     * // Update many Campaigns
     * const campaign = await prisma.campaign.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Campaigns and only return the `id`
     * const campaignWithIdOnly = await prisma.campaign.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CampaignUpdateManyAndReturnArgs>(args: SelectSubset<T, CampaignUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Campaign.
     * @param {CampaignUpsertArgs} args - Arguments to update or create a Campaign.
     * @example
     * // Update or create a Campaign
     * const campaign = await prisma.campaign.upsert({
     *   create: {
     *     // ... data to create a Campaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Campaign we want to update
     *   }
     * })
     */
    upsert<T extends CampaignUpsertArgs>(args: SelectSubset<T, CampaignUpsertArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Campaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignCountArgs} args - Arguments to filter Campaigns to count.
     * @example
     * // Count the number of Campaigns
     * const count = await prisma.campaign.count({
     *   where: {
     *     // ... the filter for the Campaigns we want to count
     *   }
     * })
    **/
    count<T extends CampaignCountArgs>(
      args?: Subset<T, CampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignAggregateArgs>(args: Subset<T, CampaignAggregateArgs>): Prisma.PrismaPromise<GetCampaignAggregateType<T>>

    /**
     * Group by Campaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignGroupByArgs['orderBy'] }
        : { orderBy?: CampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Campaign model
   */
  readonly fields: CampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Campaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    metaAccount<T extends Campaign$metaAccountArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$metaAccountArgs<ExtArgs>>): Prisma__MetaAccountClient<$Result.GetResult<Prisma.$MetaAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    adAccount<T extends Campaign$adAccountArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$adAccountArgs<ExtArgs>>): Prisma__AdAccountClient<$Result.GetResult<Prisma.$AdAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    adSets<T extends Campaign$adSetsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$adSetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdSetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Campaign$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagsOnCampaignsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    metrics<T extends Campaign$metricsArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$metricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignMetricsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clinic<T extends Campaign$clinicArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$clinicArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    product<T extends Campaign$productArgs<ExtArgs> = {}>(args?: Subset<T, Campaign$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Campaign model
   */
  interface CampaignFieldRefs {
    readonly id: FieldRef<"Campaign", 'String'>
    readonly userId: FieldRef<"Campaign", 'String'>
    readonly metaAccountId: FieldRef<"Campaign", 'String'>
    readonly adAccountId: FieldRef<"Campaign", 'String'>
    readonly campaignId: FieldRef<"Campaign", 'String'>
    readonly name: FieldRef<"Campaign", 'String'>
    readonly objective: FieldRef<"Campaign", 'String'>
    readonly status: FieldRef<"Campaign", 'CampaignStatus'>
    readonly budget: FieldRef<"Campaign", 'Float'>
    readonly budgetType: FieldRef<"Campaign", 'BudgetType'>
    readonly startDate: FieldRef<"Campaign", 'DateTime'>
    readonly endDate: FieldRef<"Campaign", 'DateTime'>
    readonly createdAt: FieldRef<"Campaign", 'DateTime'>
    readonly updatedAt: FieldRef<"Campaign", 'DateTime'>
    readonly clinicId: FieldRef<"Campaign", 'String'>
    readonly productId: FieldRef<"Campaign", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Campaign findUnique
   */
  export type CampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findUniqueOrThrow
   */
  export type CampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign findFirst
   */
  export type CampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findFirstOrThrow
   */
  export type CampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaign to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Campaigns.
     */
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign findMany
   */
  export type CampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter, which Campaigns to fetch.
     */
    where?: CampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Campaigns to fetch.
     */
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Campaigns.
     */
    cursor?: CampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Campaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Campaigns.
     */
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Campaign create
   */
  export type CampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a Campaign.
     */
    data: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
  }

  /**
   * Campaign createMany
   */
  export type CampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Campaign createManyAndReturn
   */
  export type CampaignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * The data used to create many Campaigns.
     */
    data: CampaignCreateManyInput | CampaignCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Campaign update
   */
  export type CampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a Campaign.
     */
    data: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
    /**
     * Choose, which Campaign to update.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign updateMany
   */
  export type CampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
    /**
     * Limit how many Campaigns to update.
     */
    limit?: number
  }

  /**
   * Campaign updateManyAndReturn
   */
  export type CampaignUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * The data used to update Campaigns.
     */
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyInput>
    /**
     * Filter which Campaigns to update
     */
    where?: CampaignWhereInput
    /**
     * Limit how many Campaigns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Campaign upsert
   */
  export type CampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the Campaign to update in case it exists.
     */
    where: CampaignWhereUniqueInput
    /**
     * In case the Campaign found by the `where` argument doesn't exist, create a new Campaign with this data.
     */
    create: XOR<CampaignCreateInput, CampaignUncheckedCreateInput>
    /**
     * In case the Campaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignUpdateInput, CampaignUncheckedUpdateInput>
  }

  /**
   * Campaign delete
   */
  export type CampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    /**
     * Filter which Campaign to delete.
     */
    where: CampaignWhereUniqueInput
  }

  /**
   * Campaign deleteMany
   */
  export type CampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Campaigns to delete
     */
    where?: CampaignWhereInput
    /**
     * Limit how many Campaigns to delete.
     */
    limit?: number
  }

  /**
   * Campaign.metaAccount
   */
  export type Campaign$metaAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaAccount
     */
    select?: MetaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaAccount
     */
    omit?: MetaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaAccountInclude<ExtArgs> | null
    where?: MetaAccountWhereInput
  }

  /**
   * Campaign.adAccount
   */
  export type Campaign$adAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdAccount
     */
    select?: AdAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdAccount
     */
    omit?: AdAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdAccountInclude<ExtArgs> | null
    where?: AdAccountWhereInput
  }

  /**
   * Campaign.adSets
   */
  export type Campaign$adSetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSet
     */
    select?: AdSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdSet
     */
    omit?: AdSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdSetInclude<ExtArgs> | null
    where?: AdSetWhereInput
    orderBy?: AdSetOrderByWithRelationInput | AdSetOrderByWithRelationInput[]
    cursor?: AdSetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdSetScalarFieldEnum | AdSetScalarFieldEnum[]
  }

  /**
   * Campaign.tags
   */
  export type Campaign$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagsOnCampaigns
     */
    select?: TagsOnCampaignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagsOnCampaigns
     */
    omit?: TagsOnCampaignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsOnCampaignsInclude<ExtArgs> | null
    where?: TagsOnCampaignsWhereInput
    orderBy?: TagsOnCampaignsOrderByWithRelationInput | TagsOnCampaignsOrderByWithRelationInput[]
    cursor?: TagsOnCampaignsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagsOnCampaignsScalarFieldEnum | TagsOnCampaignsScalarFieldEnum[]
  }

  /**
   * Campaign.metrics
   */
  export type Campaign$metricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMetrics
     */
    select?: CampaignMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMetrics
     */
    omit?: CampaignMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMetricsInclude<ExtArgs> | null
    where?: CampaignMetricsWhereInput
    orderBy?: CampaignMetricsOrderByWithRelationInput | CampaignMetricsOrderByWithRelationInput[]
    cursor?: CampaignMetricsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignMetricsScalarFieldEnum | CampaignMetricsScalarFieldEnum[]
  }

  /**
   * Campaign.clinic
   */
  export type Campaign$clinicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    where?: ClinicWhereInput
  }

  /**
   * Campaign.product
   */
  export type Campaign$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * Campaign without action
   */
  export type CampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
  }


  /**
   * Model CampaignMetrics
   */

  export type AggregateCampaignMetrics = {
    _count: CampaignMetricsCountAggregateOutputType | null
    _avg: CampaignMetricsAvgAggregateOutputType | null
    _sum: CampaignMetricsSumAggregateOutputType | null
    _min: CampaignMetricsMinAggregateOutputType | null
    _max: CampaignMetricsMaxAggregateOutputType | null
  }

  export type CampaignMetricsAvgAggregateOutputType = {
    impressions: number | null
    clicks: number | null
    reach: number | null
    spend: number | null
    conversions: number | null
    costPerResult: number | null
    ctr: number | null
    cpc: number | null
    cpm: number | null
    frequency: number | null
  }

  export type CampaignMetricsSumAggregateOutputType = {
    impressions: number | null
    clicks: number | null
    reach: number | null
    spend: number | null
    conversions: number | null
    costPerResult: number | null
    ctr: number | null
    cpc: number | null
    cpm: number | null
    frequency: number | null
  }

  export type CampaignMetricsMinAggregateOutputType = {
    id: string | null
    campaignId: string | null
    date: Date | null
    impressions: number | null
    clicks: number | null
    reach: number | null
    spend: number | null
    conversions: number | null
    costPerResult: number | null
    ctr: number | null
    cpc: number | null
    cpm: number | null
    frequency: number | null
  }

  export type CampaignMetricsMaxAggregateOutputType = {
    id: string | null
    campaignId: string | null
    date: Date | null
    impressions: number | null
    clicks: number | null
    reach: number | null
    spend: number | null
    conversions: number | null
    costPerResult: number | null
    ctr: number | null
    cpc: number | null
    cpm: number | null
    frequency: number | null
  }

  export type CampaignMetricsCountAggregateOutputType = {
    id: number
    campaignId: number
    date: number
    impressions: number
    clicks: number
    reach: number
    spend: number
    conversions: number
    costPerResult: number
    ctr: number
    cpc: number
    cpm: number
    frequency: number
    _all: number
  }


  export type CampaignMetricsAvgAggregateInputType = {
    impressions?: true
    clicks?: true
    reach?: true
    spend?: true
    conversions?: true
    costPerResult?: true
    ctr?: true
    cpc?: true
    cpm?: true
    frequency?: true
  }

  export type CampaignMetricsSumAggregateInputType = {
    impressions?: true
    clicks?: true
    reach?: true
    spend?: true
    conversions?: true
    costPerResult?: true
    ctr?: true
    cpc?: true
    cpm?: true
    frequency?: true
  }

  export type CampaignMetricsMinAggregateInputType = {
    id?: true
    campaignId?: true
    date?: true
    impressions?: true
    clicks?: true
    reach?: true
    spend?: true
    conversions?: true
    costPerResult?: true
    ctr?: true
    cpc?: true
    cpm?: true
    frequency?: true
  }

  export type CampaignMetricsMaxAggregateInputType = {
    id?: true
    campaignId?: true
    date?: true
    impressions?: true
    clicks?: true
    reach?: true
    spend?: true
    conversions?: true
    costPerResult?: true
    ctr?: true
    cpc?: true
    cpm?: true
    frequency?: true
  }

  export type CampaignMetricsCountAggregateInputType = {
    id?: true
    campaignId?: true
    date?: true
    impressions?: true
    clicks?: true
    reach?: true
    spend?: true
    conversions?: true
    costPerResult?: true
    ctr?: true
    cpc?: true
    cpm?: true
    frequency?: true
    _all?: true
  }

  export type CampaignMetricsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignMetrics to aggregate.
     */
    where?: CampaignMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignMetrics to fetch.
     */
    orderBy?: CampaignMetricsOrderByWithRelationInput | CampaignMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignMetrics
    **/
    _count?: true | CampaignMetricsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignMetricsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignMetricsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignMetricsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignMetricsMaxAggregateInputType
  }

  export type GetCampaignMetricsAggregateType<T extends CampaignMetricsAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignMetrics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignMetrics[P]>
      : GetScalarType<T[P], AggregateCampaignMetrics[P]>
  }




  export type CampaignMetricsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignMetricsWhereInput
    orderBy?: CampaignMetricsOrderByWithAggregationInput | CampaignMetricsOrderByWithAggregationInput[]
    by: CampaignMetricsScalarFieldEnum[] | CampaignMetricsScalarFieldEnum
    having?: CampaignMetricsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignMetricsCountAggregateInputType | true
    _avg?: CampaignMetricsAvgAggregateInputType
    _sum?: CampaignMetricsSumAggregateInputType
    _min?: CampaignMetricsMinAggregateInputType
    _max?: CampaignMetricsMaxAggregateInputType
  }

  export type CampaignMetricsGroupByOutputType = {
    id: string
    campaignId: string
    date: Date
    impressions: number
    clicks: number
    reach: number
    spend: number
    conversions: number
    costPerResult: number | null
    ctr: number | null
    cpc: number | null
    cpm: number | null
    frequency: number | null
    _count: CampaignMetricsCountAggregateOutputType | null
    _avg: CampaignMetricsAvgAggregateOutputType | null
    _sum: CampaignMetricsSumAggregateOutputType | null
    _min: CampaignMetricsMinAggregateOutputType | null
    _max: CampaignMetricsMaxAggregateOutputType | null
  }

  type GetCampaignMetricsGroupByPayload<T extends CampaignMetricsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignMetricsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignMetricsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignMetricsGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignMetricsGroupByOutputType[P]>
        }
      >
    >


  export type CampaignMetricsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    date?: boolean
    impressions?: boolean
    clicks?: boolean
    reach?: boolean
    spend?: boolean
    conversions?: boolean
    costPerResult?: boolean
    ctr?: boolean
    cpc?: boolean
    cpm?: boolean
    frequency?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignMetrics"]>

  export type CampaignMetricsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    date?: boolean
    impressions?: boolean
    clicks?: boolean
    reach?: boolean
    spend?: boolean
    conversions?: boolean
    costPerResult?: boolean
    ctr?: boolean
    cpc?: boolean
    cpm?: boolean
    frequency?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignMetrics"]>

  export type CampaignMetricsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    campaignId?: boolean
    date?: boolean
    impressions?: boolean
    clicks?: boolean
    reach?: boolean
    spend?: boolean
    conversions?: boolean
    costPerResult?: boolean
    ctr?: boolean
    cpc?: boolean
    cpm?: boolean
    frequency?: boolean
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignMetrics"]>

  export type CampaignMetricsSelectScalar = {
    id?: boolean
    campaignId?: boolean
    date?: boolean
    impressions?: boolean
    clicks?: boolean
    reach?: boolean
    spend?: boolean
    conversions?: boolean
    costPerResult?: boolean
    ctr?: boolean
    cpc?: boolean
    cpm?: boolean
    frequency?: boolean
  }

  export type CampaignMetricsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "campaignId" | "date" | "impressions" | "clicks" | "reach" | "spend" | "conversions" | "costPerResult" | "ctr" | "cpc" | "cpm" | "frequency", ExtArgs["result"]["campaignMetrics"]>
  export type CampaignMetricsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CampaignMetricsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type CampaignMetricsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $CampaignMetricsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignMetrics"
    objects: {
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      campaignId: string
      date: Date
      impressions: number
      clicks: number
      reach: number
      spend: number
      conversions: number
      costPerResult: number | null
      ctr: number | null
      cpc: number | null
      cpm: number | null
      frequency: number | null
    }, ExtArgs["result"]["campaignMetrics"]>
    composites: {}
  }

  type CampaignMetricsGetPayload<S extends boolean | null | undefined | CampaignMetricsDefaultArgs> = $Result.GetResult<Prisma.$CampaignMetricsPayload, S>

  type CampaignMetricsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CampaignMetricsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CampaignMetricsCountAggregateInputType | true
    }

  export interface CampaignMetricsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignMetrics'], meta: { name: 'CampaignMetrics' } }
    /**
     * Find zero or one CampaignMetrics that matches the filter.
     * @param {CampaignMetricsFindUniqueArgs} args - Arguments to find a CampaignMetrics
     * @example
     * // Get one CampaignMetrics
     * const campaignMetrics = await prisma.campaignMetrics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignMetricsFindUniqueArgs>(args: SelectSubset<T, CampaignMetricsFindUniqueArgs<ExtArgs>>): Prisma__CampaignMetricsClient<$Result.GetResult<Prisma.$CampaignMetricsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CampaignMetrics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CampaignMetricsFindUniqueOrThrowArgs} args - Arguments to find a CampaignMetrics
     * @example
     * // Get one CampaignMetrics
     * const campaignMetrics = await prisma.campaignMetrics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignMetricsFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignMetricsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignMetricsClient<$Result.GetResult<Prisma.$CampaignMetricsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CampaignMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMetricsFindFirstArgs} args - Arguments to find a CampaignMetrics
     * @example
     * // Get one CampaignMetrics
     * const campaignMetrics = await prisma.campaignMetrics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignMetricsFindFirstArgs>(args?: SelectSubset<T, CampaignMetricsFindFirstArgs<ExtArgs>>): Prisma__CampaignMetricsClient<$Result.GetResult<Prisma.$CampaignMetricsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CampaignMetrics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMetricsFindFirstOrThrowArgs} args - Arguments to find a CampaignMetrics
     * @example
     * // Get one CampaignMetrics
     * const campaignMetrics = await prisma.campaignMetrics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignMetricsFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignMetricsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignMetricsClient<$Result.GetResult<Prisma.$CampaignMetricsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CampaignMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMetricsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignMetrics
     * const campaignMetrics = await prisma.campaignMetrics.findMany()
     * 
     * // Get first 10 CampaignMetrics
     * const campaignMetrics = await prisma.campaignMetrics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignMetricsWithIdOnly = await prisma.campaignMetrics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignMetricsFindManyArgs>(args?: SelectSubset<T, CampaignMetricsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignMetricsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CampaignMetrics.
     * @param {CampaignMetricsCreateArgs} args - Arguments to create a CampaignMetrics.
     * @example
     * // Create one CampaignMetrics
     * const CampaignMetrics = await prisma.campaignMetrics.create({
     *   data: {
     *     // ... data to create a CampaignMetrics
     *   }
     * })
     * 
     */
    create<T extends CampaignMetricsCreateArgs>(args: SelectSubset<T, CampaignMetricsCreateArgs<ExtArgs>>): Prisma__CampaignMetricsClient<$Result.GetResult<Prisma.$CampaignMetricsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CampaignMetrics.
     * @param {CampaignMetricsCreateManyArgs} args - Arguments to create many CampaignMetrics.
     * @example
     * // Create many CampaignMetrics
     * const campaignMetrics = await prisma.campaignMetrics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignMetricsCreateManyArgs>(args?: SelectSubset<T, CampaignMetricsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignMetrics and returns the data saved in the database.
     * @param {CampaignMetricsCreateManyAndReturnArgs} args - Arguments to create many CampaignMetrics.
     * @example
     * // Create many CampaignMetrics
     * const campaignMetrics = await prisma.campaignMetrics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignMetrics and only return the `id`
     * const campaignMetricsWithIdOnly = await prisma.campaignMetrics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignMetricsCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignMetricsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignMetricsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CampaignMetrics.
     * @param {CampaignMetricsDeleteArgs} args - Arguments to delete one CampaignMetrics.
     * @example
     * // Delete one CampaignMetrics
     * const CampaignMetrics = await prisma.campaignMetrics.delete({
     *   where: {
     *     // ... filter to delete one CampaignMetrics
     *   }
     * })
     * 
     */
    delete<T extends CampaignMetricsDeleteArgs>(args: SelectSubset<T, CampaignMetricsDeleteArgs<ExtArgs>>): Prisma__CampaignMetricsClient<$Result.GetResult<Prisma.$CampaignMetricsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CampaignMetrics.
     * @param {CampaignMetricsUpdateArgs} args - Arguments to update one CampaignMetrics.
     * @example
     * // Update one CampaignMetrics
     * const campaignMetrics = await prisma.campaignMetrics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignMetricsUpdateArgs>(args: SelectSubset<T, CampaignMetricsUpdateArgs<ExtArgs>>): Prisma__CampaignMetricsClient<$Result.GetResult<Prisma.$CampaignMetricsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CampaignMetrics.
     * @param {CampaignMetricsDeleteManyArgs} args - Arguments to filter CampaignMetrics to delete.
     * @example
     * // Delete a few CampaignMetrics
     * const { count } = await prisma.campaignMetrics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignMetricsDeleteManyArgs>(args?: SelectSubset<T, CampaignMetricsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMetricsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignMetrics
     * const campaignMetrics = await prisma.campaignMetrics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignMetricsUpdateManyArgs>(args: SelectSubset<T, CampaignMetricsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignMetrics and returns the data updated in the database.
     * @param {CampaignMetricsUpdateManyAndReturnArgs} args - Arguments to update many CampaignMetrics.
     * @example
     * // Update many CampaignMetrics
     * const campaignMetrics = await prisma.campaignMetrics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CampaignMetrics and only return the `id`
     * const campaignMetricsWithIdOnly = await prisma.campaignMetrics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CampaignMetricsUpdateManyAndReturnArgs>(args: SelectSubset<T, CampaignMetricsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignMetricsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CampaignMetrics.
     * @param {CampaignMetricsUpsertArgs} args - Arguments to update or create a CampaignMetrics.
     * @example
     * // Update or create a CampaignMetrics
     * const campaignMetrics = await prisma.campaignMetrics.upsert({
     *   create: {
     *     // ... data to create a CampaignMetrics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignMetrics we want to update
     *   }
     * })
     */
    upsert<T extends CampaignMetricsUpsertArgs>(args: SelectSubset<T, CampaignMetricsUpsertArgs<ExtArgs>>): Prisma__CampaignMetricsClient<$Result.GetResult<Prisma.$CampaignMetricsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CampaignMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMetricsCountArgs} args - Arguments to filter CampaignMetrics to count.
     * @example
     * // Count the number of CampaignMetrics
     * const count = await prisma.campaignMetrics.count({
     *   where: {
     *     // ... the filter for the CampaignMetrics we want to count
     *   }
     * })
    **/
    count<T extends CampaignMetricsCountArgs>(
      args?: Subset<T, CampaignMetricsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignMetricsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMetricsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignMetricsAggregateArgs>(args: Subset<T, CampaignMetricsAggregateArgs>): Prisma.PrismaPromise<GetCampaignMetricsAggregateType<T>>

    /**
     * Group by CampaignMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignMetricsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignMetricsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignMetricsGroupByArgs['orderBy'] }
        : { orderBy?: CampaignMetricsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignMetricsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignMetricsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignMetrics model
   */
  readonly fields: CampaignMetricsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignMetrics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignMetricsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignMetrics model
   */
  interface CampaignMetricsFieldRefs {
    readonly id: FieldRef<"CampaignMetrics", 'String'>
    readonly campaignId: FieldRef<"CampaignMetrics", 'String'>
    readonly date: FieldRef<"CampaignMetrics", 'DateTime'>
    readonly impressions: FieldRef<"CampaignMetrics", 'Int'>
    readonly clicks: FieldRef<"CampaignMetrics", 'Int'>
    readonly reach: FieldRef<"CampaignMetrics", 'Int'>
    readonly spend: FieldRef<"CampaignMetrics", 'Float'>
    readonly conversions: FieldRef<"CampaignMetrics", 'Int'>
    readonly costPerResult: FieldRef<"CampaignMetrics", 'Float'>
    readonly ctr: FieldRef<"CampaignMetrics", 'Float'>
    readonly cpc: FieldRef<"CampaignMetrics", 'Float'>
    readonly cpm: FieldRef<"CampaignMetrics", 'Float'>
    readonly frequency: FieldRef<"CampaignMetrics", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * CampaignMetrics findUnique
   */
  export type CampaignMetricsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMetrics
     */
    select?: CampaignMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMetrics
     */
    omit?: CampaignMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMetricsInclude<ExtArgs> | null
    /**
     * Filter, which CampaignMetrics to fetch.
     */
    where: CampaignMetricsWhereUniqueInput
  }

  /**
   * CampaignMetrics findUniqueOrThrow
   */
  export type CampaignMetricsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMetrics
     */
    select?: CampaignMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMetrics
     */
    omit?: CampaignMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMetricsInclude<ExtArgs> | null
    /**
     * Filter, which CampaignMetrics to fetch.
     */
    where: CampaignMetricsWhereUniqueInput
  }

  /**
   * CampaignMetrics findFirst
   */
  export type CampaignMetricsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMetrics
     */
    select?: CampaignMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMetrics
     */
    omit?: CampaignMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMetricsInclude<ExtArgs> | null
    /**
     * Filter, which CampaignMetrics to fetch.
     */
    where?: CampaignMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignMetrics to fetch.
     */
    orderBy?: CampaignMetricsOrderByWithRelationInput | CampaignMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignMetrics.
     */
    cursor?: CampaignMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignMetrics.
     */
    distinct?: CampaignMetricsScalarFieldEnum | CampaignMetricsScalarFieldEnum[]
  }

  /**
   * CampaignMetrics findFirstOrThrow
   */
  export type CampaignMetricsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMetrics
     */
    select?: CampaignMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMetrics
     */
    omit?: CampaignMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMetricsInclude<ExtArgs> | null
    /**
     * Filter, which CampaignMetrics to fetch.
     */
    where?: CampaignMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignMetrics to fetch.
     */
    orderBy?: CampaignMetricsOrderByWithRelationInput | CampaignMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignMetrics.
     */
    cursor?: CampaignMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignMetrics.
     */
    distinct?: CampaignMetricsScalarFieldEnum | CampaignMetricsScalarFieldEnum[]
  }

  /**
   * CampaignMetrics findMany
   */
  export type CampaignMetricsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMetrics
     */
    select?: CampaignMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMetrics
     */
    omit?: CampaignMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMetricsInclude<ExtArgs> | null
    /**
     * Filter, which CampaignMetrics to fetch.
     */
    where?: CampaignMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignMetrics to fetch.
     */
    orderBy?: CampaignMetricsOrderByWithRelationInput | CampaignMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignMetrics.
     */
    cursor?: CampaignMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignMetrics.
     */
    skip?: number
    distinct?: CampaignMetricsScalarFieldEnum | CampaignMetricsScalarFieldEnum[]
  }

  /**
   * CampaignMetrics create
   */
  export type CampaignMetricsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMetrics
     */
    select?: CampaignMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMetrics
     */
    omit?: CampaignMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMetricsInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignMetrics.
     */
    data: XOR<CampaignMetricsCreateInput, CampaignMetricsUncheckedCreateInput>
  }

  /**
   * CampaignMetrics createMany
   */
  export type CampaignMetricsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignMetrics.
     */
    data: CampaignMetricsCreateManyInput | CampaignMetricsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignMetrics createManyAndReturn
   */
  export type CampaignMetricsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMetrics
     */
    select?: CampaignMetricsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMetrics
     */
    omit?: CampaignMetricsOmit<ExtArgs> | null
    /**
     * The data used to create many CampaignMetrics.
     */
    data: CampaignMetricsCreateManyInput | CampaignMetricsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMetricsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignMetrics update
   */
  export type CampaignMetricsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMetrics
     */
    select?: CampaignMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMetrics
     */
    omit?: CampaignMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMetricsInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignMetrics.
     */
    data: XOR<CampaignMetricsUpdateInput, CampaignMetricsUncheckedUpdateInput>
    /**
     * Choose, which CampaignMetrics to update.
     */
    where: CampaignMetricsWhereUniqueInput
  }

  /**
   * CampaignMetrics updateMany
   */
  export type CampaignMetricsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignMetrics.
     */
    data: XOR<CampaignMetricsUpdateManyMutationInput, CampaignMetricsUncheckedUpdateManyInput>
    /**
     * Filter which CampaignMetrics to update
     */
    where?: CampaignMetricsWhereInput
    /**
     * Limit how many CampaignMetrics to update.
     */
    limit?: number
  }

  /**
   * CampaignMetrics updateManyAndReturn
   */
  export type CampaignMetricsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMetrics
     */
    select?: CampaignMetricsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMetrics
     */
    omit?: CampaignMetricsOmit<ExtArgs> | null
    /**
     * The data used to update CampaignMetrics.
     */
    data: XOR<CampaignMetricsUpdateManyMutationInput, CampaignMetricsUncheckedUpdateManyInput>
    /**
     * Filter which CampaignMetrics to update
     */
    where?: CampaignMetricsWhereInput
    /**
     * Limit how many CampaignMetrics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMetricsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignMetrics upsert
   */
  export type CampaignMetricsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMetrics
     */
    select?: CampaignMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMetrics
     */
    omit?: CampaignMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMetricsInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignMetrics to update in case it exists.
     */
    where: CampaignMetricsWhereUniqueInput
    /**
     * In case the CampaignMetrics found by the `where` argument doesn't exist, create a new CampaignMetrics with this data.
     */
    create: XOR<CampaignMetricsCreateInput, CampaignMetricsUncheckedCreateInput>
    /**
     * In case the CampaignMetrics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignMetricsUpdateInput, CampaignMetricsUncheckedUpdateInput>
  }

  /**
   * CampaignMetrics delete
   */
  export type CampaignMetricsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMetrics
     */
    select?: CampaignMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMetrics
     */
    omit?: CampaignMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMetricsInclude<ExtArgs> | null
    /**
     * Filter which CampaignMetrics to delete.
     */
    where: CampaignMetricsWhereUniqueInput
  }

  /**
   * CampaignMetrics deleteMany
   */
  export type CampaignMetricsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignMetrics to delete
     */
    where?: CampaignMetricsWhereInput
    /**
     * Limit how many CampaignMetrics to delete.
     */
    limit?: number
  }

  /**
   * CampaignMetrics without action
   */
  export type CampaignMetricsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignMetrics
     */
    select?: CampaignMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignMetrics
     */
    omit?: CampaignMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignMetricsInclude<ExtArgs> | null
  }


  /**
   * Model AdSet
   */

  export type AggregateAdSet = {
    _count: AdSetCountAggregateOutputType | null
    _avg: AdSetAvgAggregateOutputType | null
    _sum: AdSetSumAggregateOutputType | null
    _min: AdSetMinAggregateOutputType | null
    _max: AdSetMaxAggregateOutputType | null
  }

  export type AdSetAvgAggregateOutputType = {
    budget: number | null
    bidAmount: number | null
  }

  export type AdSetSumAggregateOutputType = {
    budget: number | null
    bidAmount: number | null
  }

  export type AdSetMinAggregateOutputType = {
    id: string | null
    userId: string | null
    campaignId: string | null
    metaAccountId: string | null
    adSetId: string | null
    name: string | null
    status: $Enums.AdSetStatus | null
    budget: number | null
    budgetType: $Enums.BudgetType | null
    bidStrategy: string | null
    bidAmount: number | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdSetMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    campaignId: string | null
    metaAccountId: string | null
    adSetId: string | null
    name: string | null
    status: $Enums.AdSetStatus | null
    budget: number | null
    budgetType: $Enums.BudgetType | null
    bidStrategy: string | null
    bidAmount: number | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdSetCountAggregateOutputType = {
    id: number
    userId: number
    campaignId: number
    metaAccountId: number
    adSetId: number
    name: number
    status: number
    budget: number
    budgetType: number
    bidStrategy: number
    bidAmount: number
    startDate: number
    endDate: number
    targeting: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdSetAvgAggregateInputType = {
    budget?: true
    bidAmount?: true
  }

  export type AdSetSumAggregateInputType = {
    budget?: true
    bidAmount?: true
  }

  export type AdSetMinAggregateInputType = {
    id?: true
    userId?: true
    campaignId?: true
    metaAccountId?: true
    adSetId?: true
    name?: true
    status?: true
    budget?: true
    budgetType?: true
    bidStrategy?: true
    bidAmount?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdSetMaxAggregateInputType = {
    id?: true
    userId?: true
    campaignId?: true
    metaAccountId?: true
    adSetId?: true
    name?: true
    status?: true
    budget?: true
    budgetType?: true
    bidStrategy?: true
    bidAmount?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdSetCountAggregateInputType = {
    id?: true
    userId?: true
    campaignId?: true
    metaAccountId?: true
    adSetId?: true
    name?: true
    status?: true
    budget?: true
    budgetType?: true
    bidStrategy?: true
    bidAmount?: true
    startDate?: true
    endDate?: true
    targeting?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdSetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdSet to aggregate.
     */
    where?: AdSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdSets to fetch.
     */
    orderBy?: AdSetOrderByWithRelationInput | AdSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdSets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdSets
    **/
    _count?: true | AdSetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdSetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdSetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdSetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdSetMaxAggregateInputType
  }

  export type GetAdSetAggregateType<T extends AdSetAggregateArgs> = {
        [P in keyof T & keyof AggregateAdSet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdSet[P]>
      : GetScalarType<T[P], AggregateAdSet[P]>
  }




  export type AdSetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdSetWhereInput
    orderBy?: AdSetOrderByWithAggregationInput | AdSetOrderByWithAggregationInput[]
    by: AdSetScalarFieldEnum[] | AdSetScalarFieldEnum
    having?: AdSetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdSetCountAggregateInputType | true
    _avg?: AdSetAvgAggregateInputType
    _sum?: AdSetSumAggregateInputType
    _min?: AdSetMinAggregateInputType
    _max?: AdSetMaxAggregateInputType
  }

  export type AdSetGroupByOutputType = {
    id: string
    userId: string
    campaignId: string
    metaAccountId: string | null
    adSetId: string | null
    name: string
    status: $Enums.AdSetStatus
    budget: number | null
    budgetType: $Enums.BudgetType | null
    bidStrategy: string | null
    bidAmount: number | null
    startDate: Date | null
    endDate: Date | null
    targeting: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: AdSetCountAggregateOutputType | null
    _avg: AdSetAvgAggregateOutputType | null
    _sum: AdSetSumAggregateOutputType | null
    _min: AdSetMinAggregateOutputType | null
    _max: AdSetMaxAggregateOutputType | null
  }

  type GetAdSetGroupByPayload<T extends AdSetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdSetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdSetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdSetGroupByOutputType[P]>
            : GetScalarType<T[P], AdSetGroupByOutputType[P]>
        }
      >
    >


  export type AdSetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    campaignId?: boolean
    metaAccountId?: boolean
    adSetId?: boolean
    name?: boolean
    status?: boolean
    budget?: boolean
    budgetType?: boolean
    bidStrategy?: boolean
    bidAmount?: boolean
    startDate?: boolean
    endDate?: boolean
    targeting?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    metaAccount?: boolean | AdSet$metaAccountArgs<ExtArgs>
    ads?: boolean | AdSet$adsArgs<ExtArgs>
    metrics?: boolean | AdSet$metricsArgs<ExtArgs>
    _count?: boolean | AdSetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adSet"]>

  export type AdSetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    campaignId?: boolean
    metaAccountId?: boolean
    adSetId?: boolean
    name?: boolean
    status?: boolean
    budget?: boolean
    budgetType?: boolean
    bidStrategy?: boolean
    bidAmount?: boolean
    startDate?: boolean
    endDate?: boolean
    targeting?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    metaAccount?: boolean | AdSet$metaAccountArgs<ExtArgs>
  }, ExtArgs["result"]["adSet"]>

  export type AdSetSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    campaignId?: boolean
    metaAccountId?: boolean
    adSetId?: boolean
    name?: boolean
    status?: boolean
    budget?: boolean
    budgetType?: boolean
    bidStrategy?: boolean
    bidAmount?: boolean
    startDate?: boolean
    endDate?: boolean
    targeting?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    metaAccount?: boolean | AdSet$metaAccountArgs<ExtArgs>
  }, ExtArgs["result"]["adSet"]>

  export type AdSetSelectScalar = {
    id?: boolean
    userId?: boolean
    campaignId?: boolean
    metaAccountId?: boolean
    adSetId?: boolean
    name?: boolean
    status?: boolean
    budget?: boolean
    budgetType?: boolean
    bidStrategy?: boolean
    bidAmount?: boolean
    startDate?: boolean
    endDate?: boolean
    targeting?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdSetOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "campaignId" | "metaAccountId" | "adSetId" | "name" | "status" | "budget" | "budgetType" | "bidStrategy" | "bidAmount" | "startDate" | "endDate" | "targeting" | "createdAt" | "updatedAt", ExtArgs["result"]["adSet"]>
  export type AdSetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    metaAccount?: boolean | AdSet$metaAccountArgs<ExtArgs>
    ads?: boolean | AdSet$adsArgs<ExtArgs>
    metrics?: boolean | AdSet$metricsArgs<ExtArgs>
    _count?: boolean | AdSetCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdSetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    metaAccount?: boolean | AdSet$metaAccountArgs<ExtArgs>
  }
  export type AdSetIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
    metaAccount?: boolean | AdSet$metaAccountArgs<ExtArgs>
  }

  export type $AdSetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdSet"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      campaign: Prisma.$CampaignPayload<ExtArgs>
      metaAccount: Prisma.$MetaAccountPayload<ExtArgs> | null
      ads: Prisma.$AdPayload<ExtArgs>[]
      metrics: Prisma.$AdSetMetricsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      campaignId: string
      metaAccountId: string | null
      adSetId: string | null
      name: string
      status: $Enums.AdSetStatus
      budget: number | null
      budgetType: $Enums.BudgetType | null
      bidStrategy: string | null
      bidAmount: number | null
      startDate: Date | null
      endDate: Date | null
      targeting: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["adSet"]>
    composites: {}
  }

  type AdSetGetPayload<S extends boolean | null | undefined | AdSetDefaultArgs> = $Result.GetResult<Prisma.$AdSetPayload, S>

  type AdSetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdSetFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdSetCountAggregateInputType | true
    }

  export interface AdSetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdSet'], meta: { name: 'AdSet' } }
    /**
     * Find zero or one AdSet that matches the filter.
     * @param {AdSetFindUniqueArgs} args - Arguments to find a AdSet
     * @example
     * // Get one AdSet
     * const adSet = await prisma.adSet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdSetFindUniqueArgs>(args: SelectSubset<T, AdSetFindUniqueArgs<ExtArgs>>): Prisma__AdSetClient<$Result.GetResult<Prisma.$AdSetPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdSet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdSetFindUniqueOrThrowArgs} args - Arguments to find a AdSet
     * @example
     * // Get one AdSet
     * const adSet = await prisma.adSet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdSetFindUniqueOrThrowArgs>(args: SelectSubset<T, AdSetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdSetClient<$Result.GetResult<Prisma.$AdSetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdSet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdSetFindFirstArgs} args - Arguments to find a AdSet
     * @example
     * // Get one AdSet
     * const adSet = await prisma.adSet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdSetFindFirstArgs>(args?: SelectSubset<T, AdSetFindFirstArgs<ExtArgs>>): Prisma__AdSetClient<$Result.GetResult<Prisma.$AdSetPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdSet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdSetFindFirstOrThrowArgs} args - Arguments to find a AdSet
     * @example
     * // Get one AdSet
     * const adSet = await prisma.adSet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdSetFindFirstOrThrowArgs>(args?: SelectSubset<T, AdSetFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdSetClient<$Result.GetResult<Prisma.$AdSetPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdSets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdSetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdSets
     * const adSets = await prisma.adSet.findMany()
     * 
     * // Get first 10 AdSets
     * const adSets = await prisma.adSet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adSetWithIdOnly = await prisma.adSet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdSetFindManyArgs>(args?: SelectSubset<T, AdSetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdSetPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdSet.
     * @param {AdSetCreateArgs} args - Arguments to create a AdSet.
     * @example
     * // Create one AdSet
     * const AdSet = await prisma.adSet.create({
     *   data: {
     *     // ... data to create a AdSet
     *   }
     * })
     * 
     */
    create<T extends AdSetCreateArgs>(args: SelectSubset<T, AdSetCreateArgs<ExtArgs>>): Prisma__AdSetClient<$Result.GetResult<Prisma.$AdSetPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdSets.
     * @param {AdSetCreateManyArgs} args - Arguments to create many AdSets.
     * @example
     * // Create many AdSets
     * const adSet = await prisma.adSet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdSetCreateManyArgs>(args?: SelectSubset<T, AdSetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdSets and returns the data saved in the database.
     * @param {AdSetCreateManyAndReturnArgs} args - Arguments to create many AdSets.
     * @example
     * // Create many AdSets
     * const adSet = await prisma.adSet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdSets and only return the `id`
     * const adSetWithIdOnly = await prisma.adSet.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdSetCreateManyAndReturnArgs>(args?: SelectSubset<T, AdSetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdSetPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdSet.
     * @param {AdSetDeleteArgs} args - Arguments to delete one AdSet.
     * @example
     * // Delete one AdSet
     * const AdSet = await prisma.adSet.delete({
     *   where: {
     *     // ... filter to delete one AdSet
     *   }
     * })
     * 
     */
    delete<T extends AdSetDeleteArgs>(args: SelectSubset<T, AdSetDeleteArgs<ExtArgs>>): Prisma__AdSetClient<$Result.GetResult<Prisma.$AdSetPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdSet.
     * @param {AdSetUpdateArgs} args - Arguments to update one AdSet.
     * @example
     * // Update one AdSet
     * const adSet = await prisma.adSet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdSetUpdateArgs>(args: SelectSubset<T, AdSetUpdateArgs<ExtArgs>>): Prisma__AdSetClient<$Result.GetResult<Prisma.$AdSetPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdSets.
     * @param {AdSetDeleteManyArgs} args - Arguments to filter AdSets to delete.
     * @example
     * // Delete a few AdSets
     * const { count } = await prisma.adSet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdSetDeleteManyArgs>(args?: SelectSubset<T, AdSetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdSets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdSetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdSets
     * const adSet = await prisma.adSet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdSetUpdateManyArgs>(args: SelectSubset<T, AdSetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdSets and returns the data updated in the database.
     * @param {AdSetUpdateManyAndReturnArgs} args - Arguments to update many AdSets.
     * @example
     * // Update many AdSets
     * const adSet = await prisma.adSet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdSets and only return the `id`
     * const adSetWithIdOnly = await prisma.adSet.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdSetUpdateManyAndReturnArgs>(args: SelectSubset<T, AdSetUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdSetPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdSet.
     * @param {AdSetUpsertArgs} args - Arguments to update or create a AdSet.
     * @example
     * // Update or create a AdSet
     * const adSet = await prisma.adSet.upsert({
     *   create: {
     *     // ... data to create a AdSet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdSet we want to update
     *   }
     * })
     */
    upsert<T extends AdSetUpsertArgs>(args: SelectSubset<T, AdSetUpsertArgs<ExtArgs>>): Prisma__AdSetClient<$Result.GetResult<Prisma.$AdSetPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdSets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdSetCountArgs} args - Arguments to filter AdSets to count.
     * @example
     * // Count the number of AdSets
     * const count = await prisma.adSet.count({
     *   where: {
     *     // ... the filter for the AdSets we want to count
     *   }
     * })
    **/
    count<T extends AdSetCountArgs>(
      args?: Subset<T, AdSetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdSetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdSet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdSetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdSetAggregateArgs>(args: Subset<T, AdSetAggregateArgs>): Prisma.PrismaPromise<GetAdSetAggregateType<T>>

    /**
     * Group by AdSet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdSetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdSetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdSetGroupByArgs['orderBy'] }
        : { orderBy?: AdSetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdSetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdSetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdSet model
   */
  readonly fields: AdSetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdSet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdSetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    metaAccount<T extends AdSet$metaAccountArgs<ExtArgs> = {}>(args?: Subset<T, AdSet$metaAccountArgs<ExtArgs>>): Prisma__MetaAccountClient<$Result.GetResult<Prisma.$MetaAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ads<T extends AdSet$adsArgs<ExtArgs> = {}>(args?: Subset<T, AdSet$adsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    metrics<T extends AdSet$metricsArgs<ExtArgs> = {}>(args?: Subset<T, AdSet$metricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdSetMetricsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdSet model
   */
  interface AdSetFieldRefs {
    readonly id: FieldRef<"AdSet", 'String'>
    readonly userId: FieldRef<"AdSet", 'String'>
    readonly campaignId: FieldRef<"AdSet", 'String'>
    readonly metaAccountId: FieldRef<"AdSet", 'String'>
    readonly adSetId: FieldRef<"AdSet", 'String'>
    readonly name: FieldRef<"AdSet", 'String'>
    readonly status: FieldRef<"AdSet", 'AdSetStatus'>
    readonly budget: FieldRef<"AdSet", 'Float'>
    readonly budgetType: FieldRef<"AdSet", 'BudgetType'>
    readonly bidStrategy: FieldRef<"AdSet", 'String'>
    readonly bidAmount: FieldRef<"AdSet", 'Float'>
    readonly startDate: FieldRef<"AdSet", 'DateTime'>
    readonly endDate: FieldRef<"AdSet", 'DateTime'>
    readonly targeting: FieldRef<"AdSet", 'Json'>
    readonly createdAt: FieldRef<"AdSet", 'DateTime'>
    readonly updatedAt: FieldRef<"AdSet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdSet findUnique
   */
  export type AdSetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSet
     */
    select?: AdSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdSet
     */
    omit?: AdSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdSetInclude<ExtArgs> | null
    /**
     * Filter, which AdSet to fetch.
     */
    where: AdSetWhereUniqueInput
  }

  /**
   * AdSet findUniqueOrThrow
   */
  export type AdSetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSet
     */
    select?: AdSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdSet
     */
    omit?: AdSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdSetInclude<ExtArgs> | null
    /**
     * Filter, which AdSet to fetch.
     */
    where: AdSetWhereUniqueInput
  }

  /**
   * AdSet findFirst
   */
  export type AdSetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSet
     */
    select?: AdSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdSet
     */
    omit?: AdSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdSetInclude<ExtArgs> | null
    /**
     * Filter, which AdSet to fetch.
     */
    where?: AdSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdSets to fetch.
     */
    orderBy?: AdSetOrderByWithRelationInput | AdSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdSets.
     */
    cursor?: AdSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdSets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdSets.
     */
    distinct?: AdSetScalarFieldEnum | AdSetScalarFieldEnum[]
  }

  /**
   * AdSet findFirstOrThrow
   */
  export type AdSetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSet
     */
    select?: AdSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdSet
     */
    omit?: AdSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdSetInclude<ExtArgs> | null
    /**
     * Filter, which AdSet to fetch.
     */
    where?: AdSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdSets to fetch.
     */
    orderBy?: AdSetOrderByWithRelationInput | AdSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdSets.
     */
    cursor?: AdSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdSets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdSets.
     */
    distinct?: AdSetScalarFieldEnum | AdSetScalarFieldEnum[]
  }

  /**
   * AdSet findMany
   */
  export type AdSetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSet
     */
    select?: AdSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdSet
     */
    omit?: AdSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdSetInclude<ExtArgs> | null
    /**
     * Filter, which AdSets to fetch.
     */
    where?: AdSetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdSets to fetch.
     */
    orderBy?: AdSetOrderByWithRelationInput | AdSetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdSets.
     */
    cursor?: AdSetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdSets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdSets.
     */
    skip?: number
    distinct?: AdSetScalarFieldEnum | AdSetScalarFieldEnum[]
  }

  /**
   * AdSet create
   */
  export type AdSetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSet
     */
    select?: AdSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdSet
     */
    omit?: AdSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdSetInclude<ExtArgs> | null
    /**
     * The data needed to create a AdSet.
     */
    data: XOR<AdSetCreateInput, AdSetUncheckedCreateInput>
  }

  /**
   * AdSet createMany
   */
  export type AdSetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdSets.
     */
    data: AdSetCreateManyInput | AdSetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdSet createManyAndReturn
   */
  export type AdSetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSet
     */
    select?: AdSetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdSet
     */
    omit?: AdSetOmit<ExtArgs> | null
    /**
     * The data used to create many AdSets.
     */
    data: AdSetCreateManyInput | AdSetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdSetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdSet update
   */
  export type AdSetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSet
     */
    select?: AdSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdSet
     */
    omit?: AdSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdSetInclude<ExtArgs> | null
    /**
     * The data needed to update a AdSet.
     */
    data: XOR<AdSetUpdateInput, AdSetUncheckedUpdateInput>
    /**
     * Choose, which AdSet to update.
     */
    where: AdSetWhereUniqueInput
  }

  /**
   * AdSet updateMany
   */
  export type AdSetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdSets.
     */
    data: XOR<AdSetUpdateManyMutationInput, AdSetUncheckedUpdateManyInput>
    /**
     * Filter which AdSets to update
     */
    where?: AdSetWhereInput
    /**
     * Limit how many AdSets to update.
     */
    limit?: number
  }

  /**
   * AdSet updateManyAndReturn
   */
  export type AdSetUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSet
     */
    select?: AdSetSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdSet
     */
    omit?: AdSetOmit<ExtArgs> | null
    /**
     * The data used to update AdSets.
     */
    data: XOR<AdSetUpdateManyMutationInput, AdSetUncheckedUpdateManyInput>
    /**
     * Filter which AdSets to update
     */
    where?: AdSetWhereInput
    /**
     * Limit how many AdSets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdSetIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdSet upsert
   */
  export type AdSetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSet
     */
    select?: AdSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdSet
     */
    omit?: AdSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdSetInclude<ExtArgs> | null
    /**
     * The filter to search for the AdSet to update in case it exists.
     */
    where: AdSetWhereUniqueInput
    /**
     * In case the AdSet found by the `where` argument doesn't exist, create a new AdSet with this data.
     */
    create: XOR<AdSetCreateInput, AdSetUncheckedCreateInput>
    /**
     * In case the AdSet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdSetUpdateInput, AdSetUncheckedUpdateInput>
  }

  /**
   * AdSet delete
   */
  export type AdSetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSet
     */
    select?: AdSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdSet
     */
    omit?: AdSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdSetInclude<ExtArgs> | null
    /**
     * Filter which AdSet to delete.
     */
    where: AdSetWhereUniqueInput
  }

  /**
   * AdSet deleteMany
   */
  export type AdSetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdSets to delete
     */
    where?: AdSetWhereInput
    /**
     * Limit how many AdSets to delete.
     */
    limit?: number
  }

  /**
   * AdSet.metaAccount
   */
  export type AdSet$metaAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaAccount
     */
    select?: MetaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaAccount
     */
    omit?: MetaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaAccountInclude<ExtArgs> | null
    where?: MetaAccountWhereInput
  }

  /**
   * AdSet.ads
   */
  export type AdSet$adsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    where?: AdWhereInput
    orderBy?: AdOrderByWithRelationInput | AdOrderByWithRelationInput[]
    cursor?: AdWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdScalarFieldEnum | AdScalarFieldEnum[]
  }

  /**
   * AdSet.metrics
   */
  export type AdSet$metricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSetMetrics
     */
    select?: AdSetMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdSetMetrics
     */
    omit?: AdSetMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdSetMetricsInclude<ExtArgs> | null
    where?: AdSetMetricsWhereInput
    orderBy?: AdSetMetricsOrderByWithRelationInput | AdSetMetricsOrderByWithRelationInput[]
    cursor?: AdSetMetricsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdSetMetricsScalarFieldEnum | AdSetMetricsScalarFieldEnum[]
  }

  /**
   * AdSet without action
   */
  export type AdSetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSet
     */
    select?: AdSetSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdSet
     */
    omit?: AdSetOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdSetInclude<ExtArgs> | null
  }


  /**
   * Model AdSetMetrics
   */

  export type AggregateAdSetMetrics = {
    _count: AdSetMetricsCountAggregateOutputType | null
    _avg: AdSetMetricsAvgAggregateOutputType | null
    _sum: AdSetMetricsSumAggregateOutputType | null
    _min: AdSetMetricsMinAggregateOutputType | null
    _max: AdSetMetricsMaxAggregateOutputType | null
  }

  export type AdSetMetricsAvgAggregateOutputType = {
    impressions: number | null
    clicks: number | null
    reach: number | null
    spend: number | null
    conversions: number | null
    costPerResult: number | null
    ctr: number | null
    cpc: number | null
    cpm: number | null
    frequency: number | null
  }

  export type AdSetMetricsSumAggregateOutputType = {
    impressions: number | null
    clicks: number | null
    reach: number | null
    spend: number | null
    conversions: number | null
    costPerResult: number | null
    ctr: number | null
    cpc: number | null
    cpm: number | null
    frequency: number | null
  }

  export type AdSetMetricsMinAggregateOutputType = {
    id: string | null
    adSetId: string | null
    date: Date | null
    impressions: number | null
    clicks: number | null
    reach: number | null
    spend: number | null
    conversions: number | null
    costPerResult: number | null
    ctr: number | null
    cpc: number | null
    cpm: number | null
    frequency: number | null
  }

  export type AdSetMetricsMaxAggregateOutputType = {
    id: string | null
    adSetId: string | null
    date: Date | null
    impressions: number | null
    clicks: number | null
    reach: number | null
    spend: number | null
    conversions: number | null
    costPerResult: number | null
    ctr: number | null
    cpc: number | null
    cpm: number | null
    frequency: number | null
  }

  export type AdSetMetricsCountAggregateOutputType = {
    id: number
    adSetId: number
    date: number
    impressions: number
    clicks: number
    reach: number
    spend: number
    conversions: number
    costPerResult: number
    ctr: number
    cpc: number
    cpm: number
    frequency: number
    _all: number
  }


  export type AdSetMetricsAvgAggregateInputType = {
    impressions?: true
    clicks?: true
    reach?: true
    spend?: true
    conversions?: true
    costPerResult?: true
    ctr?: true
    cpc?: true
    cpm?: true
    frequency?: true
  }

  export type AdSetMetricsSumAggregateInputType = {
    impressions?: true
    clicks?: true
    reach?: true
    spend?: true
    conversions?: true
    costPerResult?: true
    ctr?: true
    cpc?: true
    cpm?: true
    frequency?: true
  }

  export type AdSetMetricsMinAggregateInputType = {
    id?: true
    adSetId?: true
    date?: true
    impressions?: true
    clicks?: true
    reach?: true
    spend?: true
    conversions?: true
    costPerResult?: true
    ctr?: true
    cpc?: true
    cpm?: true
    frequency?: true
  }

  export type AdSetMetricsMaxAggregateInputType = {
    id?: true
    adSetId?: true
    date?: true
    impressions?: true
    clicks?: true
    reach?: true
    spend?: true
    conversions?: true
    costPerResult?: true
    ctr?: true
    cpc?: true
    cpm?: true
    frequency?: true
  }

  export type AdSetMetricsCountAggregateInputType = {
    id?: true
    adSetId?: true
    date?: true
    impressions?: true
    clicks?: true
    reach?: true
    spend?: true
    conversions?: true
    costPerResult?: true
    ctr?: true
    cpc?: true
    cpm?: true
    frequency?: true
    _all?: true
  }

  export type AdSetMetricsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdSetMetrics to aggregate.
     */
    where?: AdSetMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdSetMetrics to fetch.
     */
    orderBy?: AdSetMetricsOrderByWithRelationInput | AdSetMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdSetMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdSetMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdSetMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdSetMetrics
    **/
    _count?: true | AdSetMetricsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdSetMetricsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdSetMetricsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdSetMetricsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdSetMetricsMaxAggregateInputType
  }

  export type GetAdSetMetricsAggregateType<T extends AdSetMetricsAggregateArgs> = {
        [P in keyof T & keyof AggregateAdSetMetrics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdSetMetrics[P]>
      : GetScalarType<T[P], AggregateAdSetMetrics[P]>
  }




  export type AdSetMetricsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdSetMetricsWhereInput
    orderBy?: AdSetMetricsOrderByWithAggregationInput | AdSetMetricsOrderByWithAggregationInput[]
    by: AdSetMetricsScalarFieldEnum[] | AdSetMetricsScalarFieldEnum
    having?: AdSetMetricsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdSetMetricsCountAggregateInputType | true
    _avg?: AdSetMetricsAvgAggregateInputType
    _sum?: AdSetMetricsSumAggregateInputType
    _min?: AdSetMetricsMinAggregateInputType
    _max?: AdSetMetricsMaxAggregateInputType
  }

  export type AdSetMetricsGroupByOutputType = {
    id: string
    adSetId: string
    date: Date
    impressions: number
    clicks: number
    reach: number
    spend: number
    conversions: number
    costPerResult: number | null
    ctr: number | null
    cpc: number | null
    cpm: number | null
    frequency: number | null
    _count: AdSetMetricsCountAggregateOutputType | null
    _avg: AdSetMetricsAvgAggregateOutputType | null
    _sum: AdSetMetricsSumAggregateOutputType | null
    _min: AdSetMetricsMinAggregateOutputType | null
    _max: AdSetMetricsMaxAggregateOutputType | null
  }

  type GetAdSetMetricsGroupByPayload<T extends AdSetMetricsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdSetMetricsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdSetMetricsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdSetMetricsGroupByOutputType[P]>
            : GetScalarType<T[P], AdSetMetricsGroupByOutputType[P]>
        }
      >
    >


  export type AdSetMetricsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adSetId?: boolean
    date?: boolean
    impressions?: boolean
    clicks?: boolean
    reach?: boolean
    spend?: boolean
    conversions?: boolean
    costPerResult?: boolean
    ctr?: boolean
    cpc?: boolean
    cpm?: boolean
    frequency?: boolean
    adSet?: boolean | AdSetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adSetMetrics"]>

  export type AdSetMetricsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adSetId?: boolean
    date?: boolean
    impressions?: boolean
    clicks?: boolean
    reach?: boolean
    spend?: boolean
    conversions?: boolean
    costPerResult?: boolean
    ctr?: boolean
    cpc?: boolean
    cpm?: boolean
    frequency?: boolean
    adSet?: boolean | AdSetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adSetMetrics"]>

  export type AdSetMetricsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adSetId?: boolean
    date?: boolean
    impressions?: boolean
    clicks?: boolean
    reach?: boolean
    spend?: boolean
    conversions?: boolean
    costPerResult?: boolean
    ctr?: boolean
    cpc?: boolean
    cpm?: boolean
    frequency?: boolean
    adSet?: boolean | AdSetDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adSetMetrics"]>

  export type AdSetMetricsSelectScalar = {
    id?: boolean
    adSetId?: boolean
    date?: boolean
    impressions?: boolean
    clicks?: boolean
    reach?: boolean
    spend?: boolean
    conversions?: boolean
    costPerResult?: boolean
    ctr?: boolean
    cpc?: boolean
    cpm?: boolean
    frequency?: boolean
  }

  export type AdSetMetricsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adSetId" | "date" | "impressions" | "clicks" | "reach" | "spend" | "conversions" | "costPerResult" | "ctr" | "cpc" | "cpm" | "frequency", ExtArgs["result"]["adSetMetrics"]>
  export type AdSetMetricsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adSet?: boolean | AdSetDefaultArgs<ExtArgs>
  }
  export type AdSetMetricsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adSet?: boolean | AdSetDefaultArgs<ExtArgs>
  }
  export type AdSetMetricsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    adSet?: boolean | AdSetDefaultArgs<ExtArgs>
  }

  export type $AdSetMetricsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdSetMetrics"
    objects: {
      adSet: Prisma.$AdSetPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adSetId: string
      date: Date
      impressions: number
      clicks: number
      reach: number
      spend: number
      conversions: number
      costPerResult: number | null
      ctr: number | null
      cpc: number | null
      cpm: number | null
      frequency: number | null
    }, ExtArgs["result"]["adSetMetrics"]>
    composites: {}
  }

  type AdSetMetricsGetPayload<S extends boolean | null | undefined | AdSetMetricsDefaultArgs> = $Result.GetResult<Prisma.$AdSetMetricsPayload, S>

  type AdSetMetricsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdSetMetricsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdSetMetricsCountAggregateInputType | true
    }

  export interface AdSetMetricsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdSetMetrics'], meta: { name: 'AdSetMetrics' } }
    /**
     * Find zero or one AdSetMetrics that matches the filter.
     * @param {AdSetMetricsFindUniqueArgs} args - Arguments to find a AdSetMetrics
     * @example
     * // Get one AdSetMetrics
     * const adSetMetrics = await prisma.adSetMetrics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdSetMetricsFindUniqueArgs>(args: SelectSubset<T, AdSetMetricsFindUniqueArgs<ExtArgs>>): Prisma__AdSetMetricsClient<$Result.GetResult<Prisma.$AdSetMetricsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdSetMetrics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdSetMetricsFindUniqueOrThrowArgs} args - Arguments to find a AdSetMetrics
     * @example
     * // Get one AdSetMetrics
     * const adSetMetrics = await prisma.adSetMetrics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdSetMetricsFindUniqueOrThrowArgs>(args: SelectSubset<T, AdSetMetricsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdSetMetricsClient<$Result.GetResult<Prisma.$AdSetMetricsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdSetMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdSetMetricsFindFirstArgs} args - Arguments to find a AdSetMetrics
     * @example
     * // Get one AdSetMetrics
     * const adSetMetrics = await prisma.adSetMetrics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdSetMetricsFindFirstArgs>(args?: SelectSubset<T, AdSetMetricsFindFirstArgs<ExtArgs>>): Prisma__AdSetMetricsClient<$Result.GetResult<Prisma.$AdSetMetricsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdSetMetrics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdSetMetricsFindFirstOrThrowArgs} args - Arguments to find a AdSetMetrics
     * @example
     * // Get one AdSetMetrics
     * const adSetMetrics = await prisma.adSetMetrics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdSetMetricsFindFirstOrThrowArgs>(args?: SelectSubset<T, AdSetMetricsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdSetMetricsClient<$Result.GetResult<Prisma.$AdSetMetricsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdSetMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdSetMetricsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdSetMetrics
     * const adSetMetrics = await prisma.adSetMetrics.findMany()
     * 
     * // Get first 10 AdSetMetrics
     * const adSetMetrics = await prisma.adSetMetrics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adSetMetricsWithIdOnly = await prisma.adSetMetrics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdSetMetricsFindManyArgs>(args?: SelectSubset<T, AdSetMetricsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdSetMetricsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdSetMetrics.
     * @param {AdSetMetricsCreateArgs} args - Arguments to create a AdSetMetrics.
     * @example
     * // Create one AdSetMetrics
     * const AdSetMetrics = await prisma.adSetMetrics.create({
     *   data: {
     *     // ... data to create a AdSetMetrics
     *   }
     * })
     * 
     */
    create<T extends AdSetMetricsCreateArgs>(args: SelectSubset<T, AdSetMetricsCreateArgs<ExtArgs>>): Prisma__AdSetMetricsClient<$Result.GetResult<Prisma.$AdSetMetricsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdSetMetrics.
     * @param {AdSetMetricsCreateManyArgs} args - Arguments to create many AdSetMetrics.
     * @example
     * // Create many AdSetMetrics
     * const adSetMetrics = await prisma.adSetMetrics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdSetMetricsCreateManyArgs>(args?: SelectSubset<T, AdSetMetricsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdSetMetrics and returns the data saved in the database.
     * @param {AdSetMetricsCreateManyAndReturnArgs} args - Arguments to create many AdSetMetrics.
     * @example
     * // Create many AdSetMetrics
     * const adSetMetrics = await prisma.adSetMetrics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdSetMetrics and only return the `id`
     * const adSetMetricsWithIdOnly = await prisma.adSetMetrics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdSetMetricsCreateManyAndReturnArgs>(args?: SelectSubset<T, AdSetMetricsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdSetMetricsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdSetMetrics.
     * @param {AdSetMetricsDeleteArgs} args - Arguments to delete one AdSetMetrics.
     * @example
     * // Delete one AdSetMetrics
     * const AdSetMetrics = await prisma.adSetMetrics.delete({
     *   where: {
     *     // ... filter to delete one AdSetMetrics
     *   }
     * })
     * 
     */
    delete<T extends AdSetMetricsDeleteArgs>(args: SelectSubset<T, AdSetMetricsDeleteArgs<ExtArgs>>): Prisma__AdSetMetricsClient<$Result.GetResult<Prisma.$AdSetMetricsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdSetMetrics.
     * @param {AdSetMetricsUpdateArgs} args - Arguments to update one AdSetMetrics.
     * @example
     * // Update one AdSetMetrics
     * const adSetMetrics = await prisma.adSetMetrics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdSetMetricsUpdateArgs>(args: SelectSubset<T, AdSetMetricsUpdateArgs<ExtArgs>>): Prisma__AdSetMetricsClient<$Result.GetResult<Prisma.$AdSetMetricsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdSetMetrics.
     * @param {AdSetMetricsDeleteManyArgs} args - Arguments to filter AdSetMetrics to delete.
     * @example
     * // Delete a few AdSetMetrics
     * const { count } = await prisma.adSetMetrics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdSetMetricsDeleteManyArgs>(args?: SelectSubset<T, AdSetMetricsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdSetMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdSetMetricsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdSetMetrics
     * const adSetMetrics = await prisma.adSetMetrics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdSetMetricsUpdateManyArgs>(args: SelectSubset<T, AdSetMetricsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdSetMetrics and returns the data updated in the database.
     * @param {AdSetMetricsUpdateManyAndReturnArgs} args - Arguments to update many AdSetMetrics.
     * @example
     * // Update many AdSetMetrics
     * const adSetMetrics = await prisma.adSetMetrics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdSetMetrics and only return the `id`
     * const adSetMetricsWithIdOnly = await prisma.adSetMetrics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdSetMetricsUpdateManyAndReturnArgs>(args: SelectSubset<T, AdSetMetricsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdSetMetricsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdSetMetrics.
     * @param {AdSetMetricsUpsertArgs} args - Arguments to update or create a AdSetMetrics.
     * @example
     * // Update or create a AdSetMetrics
     * const adSetMetrics = await prisma.adSetMetrics.upsert({
     *   create: {
     *     // ... data to create a AdSetMetrics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdSetMetrics we want to update
     *   }
     * })
     */
    upsert<T extends AdSetMetricsUpsertArgs>(args: SelectSubset<T, AdSetMetricsUpsertArgs<ExtArgs>>): Prisma__AdSetMetricsClient<$Result.GetResult<Prisma.$AdSetMetricsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdSetMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdSetMetricsCountArgs} args - Arguments to filter AdSetMetrics to count.
     * @example
     * // Count the number of AdSetMetrics
     * const count = await prisma.adSetMetrics.count({
     *   where: {
     *     // ... the filter for the AdSetMetrics we want to count
     *   }
     * })
    **/
    count<T extends AdSetMetricsCountArgs>(
      args?: Subset<T, AdSetMetricsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdSetMetricsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdSetMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdSetMetricsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdSetMetricsAggregateArgs>(args: Subset<T, AdSetMetricsAggregateArgs>): Prisma.PrismaPromise<GetAdSetMetricsAggregateType<T>>

    /**
     * Group by AdSetMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdSetMetricsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdSetMetricsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdSetMetricsGroupByArgs['orderBy'] }
        : { orderBy?: AdSetMetricsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdSetMetricsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdSetMetricsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdSetMetrics model
   */
  readonly fields: AdSetMetricsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdSetMetrics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdSetMetricsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    adSet<T extends AdSetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdSetDefaultArgs<ExtArgs>>): Prisma__AdSetClient<$Result.GetResult<Prisma.$AdSetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdSetMetrics model
   */
  interface AdSetMetricsFieldRefs {
    readonly id: FieldRef<"AdSetMetrics", 'String'>
    readonly adSetId: FieldRef<"AdSetMetrics", 'String'>
    readonly date: FieldRef<"AdSetMetrics", 'DateTime'>
    readonly impressions: FieldRef<"AdSetMetrics", 'Int'>
    readonly clicks: FieldRef<"AdSetMetrics", 'Int'>
    readonly reach: FieldRef<"AdSetMetrics", 'Int'>
    readonly spend: FieldRef<"AdSetMetrics", 'Float'>
    readonly conversions: FieldRef<"AdSetMetrics", 'Int'>
    readonly costPerResult: FieldRef<"AdSetMetrics", 'Float'>
    readonly ctr: FieldRef<"AdSetMetrics", 'Float'>
    readonly cpc: FieldRef<"AdSetMetrics", 'Float'>
    readonly cpm: FieldRef<"AdSetMetrics", 'Float'>
    readonly frequency: FieldRef<"AdSetMetrics", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * AdSetMetrics findUnique
   */
  export type AdSetMetricsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSetMetrics
     */
    select?: AdSetMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdSetMetrics
     */
    omit?: AdSetMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdSetMetricsInclude<ExtArgs> | null
    /**
     * Filter, which AdSetMetrics to fetch.
     */
    where: AdSetMetricsWhereUniqueInput
  }

  /**
   * AdSetMetrics findUniqueOrThrow
   */
  export type AdSetMetricsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSetMetrics
     */
    select?: AdSetMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdSetMetrics
     */
    omit?: AdSetMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdSetMetricsInclude<ExtArgs> | null
    /**
     * Filter, which AdSetMetrics to fetch.
     */
    where: AdSetMetricsWhereUniqueInput
  }

  /**
   * AdSetMetrics findFirst
   */
  export type AdSetMetricsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSetMetrics
     */
    select?: AdSetMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdSetMetrics
     */
    omit?: AdSetMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdSetMetricsInclude<ExtArgs> | null
    /**
     * Filter, which AdSetMetrics to fetch.
     */
    where?: AdSetMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdSetMetrics to fetch.
     */
    orderBy?: AdSetMetricsOrderByWithRelationInput | AdSetMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdSetMetrics.
     */
    cursor?: AdSetMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdSetMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdSetMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdSetMetrics.
     */
    distinct?: AdSetMetricsScalarFieldEnum | AdSetMetricsScalarFieldEnum[]
  }

  /**
   * AdSetMetrics findFirstOrThrow
   */
  export type AdSetMetricsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSetMetrics
     */
    select?: AdSetMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdSetMetrics
     */
    omit?: AdSetMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdSetMetricsInclude<ExtArgs> | null
    /**
     * Filter, which AdSetMetrics to fetch.
     */
    where?: AdSetMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdSetMetrics to fetch.
     */
    orderBy?: AdSetMetricsOrderByWithRelationInput | AdSetMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdSetMetrics.
     */
    cursor?: AdSetMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdSetMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdSetMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdSetMetrics.
     */
    distinct?: AdSetMetricsScalarFieldEnum | AdSetMetricsScalarFieldEnum[]
  }

  /**
   * AdSetMetrics findMany
   */
  export type AdSetMetricsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSetMetrics
     */
    select?: AdSetMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdSetMetrics
     */
    omit?: AdSetMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdSetMetricsInclude<ExtArgs> | null
    /**
     * Filter, which AdSetMetrics to fetch.
     */
    where?: AdSetMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdSetMetrics to fetch.
     */
    orderBy?: AdSetMetricsOrderByWithRelationInput | AdSetMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdSetMetrics.
     */
    cursor?: AdSetMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdSetMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdSetMetrics.
     */
    skip?: number
    distinct?: AdSetMetricsScalarFieldEnum | AdSetMetricsScalarFieldEnum[]
  }

  /**
   * AdSetMetrics create
   */
  export type AdSetMetricsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSetMetrics
     */
    select?: AdSetMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdSetMetrics
     */
    omit?: AdSetMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdSetMetricsInclude<ExtArgs> | null
    /**
     * The data needed to create a AdSetMetrics.
     */
    data: XOR<AdSetMetricsCreateInput, AdSetMetricsUncheckedCreateInput>
  }

  /**
   * AdSetMetrics createMany
   */
  export type AdSetMetricsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdSetMetrics.
     */
    data: AdSetMetricsCreateManyInput | AdSetMetricsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdSetMetrics createManyAndReturn
   */
  export type AdSetMetricsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSetMetrics
     */
    select?: AdSetMetricsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdSetMetrics
     */
    omit?: AdSetMetricsOmit<ExtArgs> | null
    /**
     * The data used to create many AdSetMetrics.
     */
    data: AdSetMetricsCreateManyInput | AdSetMetricsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdSetMetricsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdSetMetrics update
   */
  export type AdSetMetricsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSetMetrics
     */
    select?: AdSetMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdSetMetrics
     */
    omit?: AdSetMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdSetMetricsInclude<ExtArgs> | null
    /**
     * The data needed to update a AdSetMetrics.
     */
    data: XOR<AdSetMetricsUpdateInput, AdSetMetricsUncheckedUpdateInput>
    /**
     * Choose, which AdSetMetrics to update.
     */
    where: AdSetMetricsWhereUniqueInput
  }

  /**
   * AdSetMetrics updateMany
   */
  export type AdSetMetricsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdSetMetrics.
     */
    data: XOR<AdSetMetricsUpdateManyMutationInput, AdSetMetricsUncheckedUpdateManyInput>
    /**
     * Filter which AdSetMetrics to update
     */
    where?: AdSetMetricsWhereInput
    /**
     * Limit how many AdSetMetrics to update.
     */
    limit?: number
  }

  /**
   * AdSetMetrics updateManyAndReturn
   */
  export type AdSetMetricsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSetMetrics
     */
    select?: AdSetMetricsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdSetMetrics
     */
    omit?: AdSetMetricsOmit<ExtArgs> | null
    /**
     * The data used to update AdSetMetrics.
     */
    data: XOR<AdSetMetricsUpdateManyMutationInput, AdSetMetricsUncheckedUpdateManyInput>
    /**
     * Filter which AdSetMetrics to update
     */
    where?: AdSetMetricsWhereInput
    /**
     * Limit how many AdSetMetrics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdSetMetricsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdSetMetrics upsert
   */
  export type AdSetMetricsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSetMetrics
     */
    select?: AdSetMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdSetMetrics
     */
    omit?: AdSetMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdSetMetricsInclude<ExtArgs> | null
    /**
     * The filter to search for the AdSetMetrics to update in case it exists.
     */
    where: AdSetMetricsWhereUniqueInput
    /**
     * In case the AdSetMetrics found by the `where` argument doesn't exist, create a new AdSetMetrics with this data.
     */
    create: XOR<AdSetMetricsCreateInput, AdSetMetricsUncheckedCreateInput>
    /**
     * In case the AdSetMetrics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdSetMetricsUpdateInput, AdSetMetricsUncheckedUpdateInput>
  }

  /**
   * AdSetMetrics delete
   */
  export type AdSetMetricsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSetMetrics
     */
    select?: AdSetMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdSetMetrics
     */
    omit?: AdSetMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdSetMetricsInclude<ExtArgs> | null
    /**
     * Filter which AdSetMetrics to delete.
     */
    where: AdSetMetricsWhereUniqueInput
  }

  /**
   * AdSetMetrics deleteMany
   */
  export type AdSetMetricsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdSetMetrics to delete
     */
    where?: AdSetMetricsWhereInput
    /**
     * Limit how many AdSetMetrics to delete.
     */
    limit?: number
  }

  /**
   * AdSetMetrics without action
   */
  export type AdSetMetricsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdSetMetrics
     */
    select?: AdSetMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdSetMetrics
     */
    omit?: AdSetMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdSetMetricsInclude<ExtArgs> | null
  }


  /**
   * Model Ad
   */

  export type AggregateAd = {
    _count: AdCountAggregateOutputType | null
    _min: AdMinAggregateOutputType | null
    _max: AdMaxAggregateOutputType | null
  }

  export type AdMinAggregateOutputType = {
    id: string | null
    userId: string | null
    adSetId: string | null
    metaAccountId: string | null
    adId: string | null
    name: string | null
    status: $Enums.AdStatus | null
    headline: string | null
    description: string | null
    creativeType: $Enums.CreativeType | null
    imageUrl: string | null
    videoUrl: string | null
    destinationUrl: string | null
    callToAction: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    adSetId: string | null
    metaAccountId: string | null
    adId: string | null
    name: string | null
    status: $Enums.AdStatus | null
    headline: string | null
    description: string | null
    creativeType: $Enums.CreativeType | null
    imageUrl: string | null
    videoUrl: string | null
    destinationUrl: string | null
    callToAction: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdCountAggregateOutputType = {
    id: number
    userId: number
    adSetId: number
    metaAccountId: number
    adId: number
    name: number
    status: number
    headline: number
    description: number
    creativeType: number
    imageUrl: number
    videoUrl: number
    destinationUrl: number
    callToAction: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdMinAggregateInputType = {
    id?: true
    userId?: true
    adSetId?: true
    metaAccountId?: true
    adId?: true
    name?: true
    status?: true
    headline?: true
    description?: true
    creativeType?: true
    imageUrl?: true
    videoUrl?: true
    destinationUrl?: true
    callToAction?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdMaxAggregateInputType = {
    id?: true
    userId?: true
    adSetId?: true
    metaAccountId?: true
    adId?: true
    name?: true
    status?: true
    headline?: true
    description?: true
    creativeType?: true
    imageUrl?: true
    videoUrl?: true
    destinationUrl?: true
    callToAction?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdCountAggregateInputType = {
    id?: true
    userId?: true
    adSetId?: true
    metaAccountId?: true
    adId?: true
    name?: true
    status?: true
    headline?: true
    description?: true
    creativeType?: true
    imageUrl?: true
    videoUrl?: true
    destinationUrl?: true
    callToAction?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ad to aggregate.
     */
    where?: AdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ads to fetch.
     */
    orderBy?: AdOrderByWithRelationInput | AdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ads
    **/
    _count?: true | AdCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdMaxAggregateInputType
  }

  export type GetAdAggregateType<T extends AdAggregateArgs> = {
        [P in keyof T & keyof AggregateAd]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAd[P]>
      : GetScalarType<T[P], AggregateAd[P]>
  }




  export type AdGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdWhereInput
    orderBy?: AdOrderByWithAggregationInput | AdOrderByWithAggregationInput[]
    by: AdScalarFieldEnum[] | AdScalarFieldEnum
    having?: AdScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdCountAggregateInputType | true
    _min?: AdMinAggregateInputType
    _max?: AdMaxAggregateInputType
  }

  export type AdGroupByOutputType = {
    id: string
    userId: string
    adSetId: string
    metaAccountId: string | null
    adId: string | null
    name: string
    status: $Enums.AdStatus
    headline: string | null
    description: string | null
    creativeType: $Enums.CreativeType | null
    imageUrl: string | null
    videoUrl: string | null
    destinationUrl: string | null
    callToAction: string | null
    createdAt: Date
    updatedAt: Date
    _count: AdCountAggregateOutputType | null
    _min: AdMinAggregateOutputType | null
    _max: AdMaxAggregateOutputType | null
  }

  type GetAdGroupByPayload<T extends AdGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdGroupByOutputType[P]>
            : GetScalarType<T[P], AdGroupByOutputType[P]>
        }
      >
    >


  export type AdSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    adSetId?: boolean
    metaAccountId?: boolean
    adId?: boolean
    name?: boolean
    status?: boolean
    headline?: boolean
    description?: boolean
    creativeType?: boolean
    imageUrl?: boolean
    videoUrl?: boolean
    destinationUrl?: boolean
    callToAction?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    adSet?: boolean | AdSetDefaultArgs<ExtArgs>
    metaAccount?: boolean | Ad$metaAccountArgs<ExtArgs>
    metrics?: boolean | Ad$metricsArgs<ExtArgs>
    schedules?: boolean | Ad$schedulesArgs<ExtArgs>
    _count?: boolean | AdCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ad"]>

  export type AdSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    adSetId?: boolean
    metaAccountId?: boolean
    adId?: boolean
    name?: boolean
    status?: boolean
    headline?: boolean
    description?: boolean
    creativeType?: boolean
    imageUrl?: boolean
    videoUrl?: boolean
    destinationUrl?: boolean
    callToAction?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    adSet?: boolean | AdSetDefaultArgs<ExtArgs>
    metaAccount?: boolean | Ad$metaAccountArgs<ExtArgs>
  }, ExtArgs["result"]["ad"]>

  export type AdSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    adSetId?: boolean
    metaAccountId?: boolean
    adId?: boolean
    name?: boolean
    status?: boolean
    headline?: boolean
    description?: boolean
    creativeType?: boolean
    imageUrl?: boolean
    videoUrl?: boolean
    destinationUrl?: boolean
    callToAction?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    adSet?: boolean | AdSetDefaultArgs<ExtArgs>
    metaAccount?: boolean | Ad$metaAccountArgs<ExtArgs>
  }, ExtArgs["result"]["ad"]>

  export type AdSelectScalar = {
    id?: boolean
    userId?: boolean
    adSetId?: boolean
    metaAccountId?: boolean
    adId?: boolean
    name?: boolean
    status?: boolean
    headline?: boolean
    description?: boolean
    creativeType?: boolean
    imageUrl?: boolean
    videoUrl?: boolean
    destinationUrl?: boolean
    callToAction?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "adSetId" | "metaAccountId" | "adId" | "name" | "status" | "headline" | "description" | "creativeType" | "imageUrl" | "videoUrl" | "destinationUrl" | "callToAction" | "createdAt" | "updatedAt", ExtArgs["result"]["ad"]>
  export type AdInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    adSet?: boolean | AdSetDefaultArgs<ExtArgs>
    metaAccount?: boolean | Ad$metaAccountArgs<ExtArgs>
    metrics?: boolean | Ad$metricsArgs<ExtArgs>
    schedules?: boolean | Ad$schedulesArgs<ExtArgs>
    _count?: boolean | AdCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    adSet?: boolean | AdSetDefaultArgs<ExtArgs>
    metaAccount?: boolean | Ad$metaAccountArgs<ExtArgs>
  }
  export type AdIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    adSet?: boolean | AdSetDefaultArgs<ExtArgs>
    metaAccount?: boolean | Ad$metaAccountArgs<ExtArgs>
  }

  export type $AdPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ad"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      adSet: Prisma.$AdSetPayload<ExtArgs>
      metaAccount: Prisma.$MetaAccountPayload<ExtArgs> | null
      metrics: Prisma.$AdMetricsPayload<ExtArgs>[]
      schedules: Prisma.$SchedulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      adSetId: string
      metaAccountId: string | null
      adId: string | null
      name: string
      status: $Enums.AdStatus
      headline: string | null
      description: string | null
      creativeType: $Enums.CreativeType | null
      imageUrl: string | null
      videoUrl: string | null
      destinationUrl: string | null
      callToAction: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ad"]>
    composites: {}
  }

  type AdGetPayload<S extends boolean | null | undefined | AdDefaultArgs> = $Result.GetResult<Prisma.$AdPayload, S>

  type AdCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdCountAggregateInputType | true
    }

  export interface AdDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ad'], meta: { name: 'Ad' } }
    /**
     * Find zero or one Ad that matches the filter.
     * @param {AdFindUniqueArgs} args - Arguments to find a Ad
     * @example
     * // Get one Ad
     * const ad = await prisma.ad.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdFindUniqueArgs>(args: SelectSubset<T, AdFindUniqueArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ad that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdFindUniqueOrThrowArgs} args - Arguments to find a Ad
     * @example
     * // Get one Ad
     * const ad = await prisma.ad.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdFindUniqueOrThrowArgs>(args: SelectSubset<T, AdFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ad that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdFindFirstArgs} args - Arguments to find a Ad
     * @example
     * // Get one Ad
     * const ad = await prisma.ad.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdFindFirstArgs>(args?: SelectSubset<T, AdFindFirstArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ad that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdFindFirstOrThrowArgs} args - Arguments to find a Ad
     * @example
     * // Get one Ad
     * const ad = await prisma.ad.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdFindFirstOrThrowArgs>(args?: SelectSubset<T, AdFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ads
     * const ads = await prisma.ad.findMany()
     * 
     * // Get first 10 Ads
     * const ads = await prisma.ad.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adWithIdOnly = await prisma.ad.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdFindManyArgs>(args?: SelectSubset<T, AdFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ad.
     * @param {AdCreateArgs} args - Arguments to create a Ad.
     * @example
     * // Create one Ad
     * const Ad = await prisma.ad.create({
     *   data: {
     *     // ... data to create a Ad
     *   }
     * })
     * 
     */
    create<T extends AdCreateArgs>(args: SelectSubset<T, AdCreateArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ads.
     * @param {AdCreateManyArgs} args - Arguments to create many Ads.
     * @example
     * // Create many Ads
     * const ad = await prisma.ad.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdCreateManyArgs>(args?: SelectSubset<T, AdCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ads and returns the data saved in the database.
     * @param {AdCreateManyAndReturnArgs} args - Arguments to create many Ads.
     * @example
     * // Create many Ads
     * const ad = await prisma.ad.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ads and only return the `id`
     * const adWithIdOnly = await prisma.ad.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdCreateManyAndReturnArgs>(args?: SelectSubset<T, AdCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ad.
     * @param {AdDeleteArgs} args - Arguments to delete one Ad.
     * @example
     * // Delete one Ad
     * const Ad = await prisma.ad.delete({
     *   where: {
     *     // ... filter to delete one Ad
     *   }
     * })
     * 
     */
    delete<T extends AdDeleteArgs>(args: SelectSubset<T, AdDeleteArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ad.
     * @param {AdUpdateArgs} args - Arguments to update one Ad.
     * @example
     * // Update one Ad
     * const ad = await prisma.ad.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdUpdateArgs>(args: SelectSubset<T, AdUpdateArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ads.
     * @param {AdDeleteManyArgs} args - Arguments to filter Ads to delete.
     * @example
     * // Delete a few Ads
     * const { count } = await prisma.ad.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdDeleteManyArgs>(args?: SelectSubset<T, AdDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ads
     * const ad = await prisma.ad.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdUpdateManyArgs>(args: SelectSubset<T, AdUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ads and returns the data updated in the database.
     * @param {AdUpdateManyAndReturnArgs} args - Arguments to update many Ads.
     * @example
     * // Update many Ads
     * const ad = await prisma.ad.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ads and only return the `id`
     * const adWithIdOnly = await prisma.ad.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdUpdateManyAndReturnArgs>(args: SelectSubset<T, AdUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ad.
     * @param {AdUpsertArgs} args - Arguments to update or create a Ad.
     * @example
     * // Update or create a Ad
     * const ad = await prisma.ad.upsert({
     *   create: {
     *     // ... data to create a Ad
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ad we want to update
     *   }
     * })
     */
    upsert<T extends AdUpsertArgs>(args: SelectSubset<T, AdUpsertArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdCountArgs} args - Arguments to filter Ads to count.
     * @example
     * // Count the number of Ads
     * const count = await prisma.ad.count({
     *   where: {
     *     // ... the filter for the Ads we want to count
     *   }
     * })
    **/
    count<T extends AdCountArgs>(
      args?: Subset<T, AdCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdAggregateArgs>(args: Subset<T, AdAggregateArgs>): Prisma.PrismaPromise<GetAdAggregateType<T>>

    /**
     * Group by Ad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdGroupByArgs['orderBy'] }
        : { orderBy?: AdGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ad model
   */
  readonly fields: AdFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ad.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    adSet<T extends AdSetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdSetDefaultArgs<ExtArgs>>): Prisma__AdSetClient<$Result.GetResult<Prisma.$AdSetPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    metaAccount<T extends Ad$metaAccountArgs<ExtArgs> = {}>(args?: Subset<T, Ad$metaAccountArgs<ExtArgs>>): Prisma__MetaAccountClient<$Result.GetResult<Prisma.$MetaAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    metrics<T extends Ad$metricsArgs<ExtArgs> = {}>(args?: Subset<T, Ad$metricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdMetricsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    schedules<T extends Ad$schedulesArgs<ExtArgs> = {}>(args?: Subset<T, Ad$schedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ad model
   */
  interface AdFieldRefs {
    readonly id: FieldRef<"Ad", 'String'>
    readonly userId: FieldRef<"Ad", 'String'>
    readonly adSetId: FieldRef<"Ad", 'String'>
    readonly metaAccountId: FieldRef<"Ad", 'String'>
    readonly adId: FieldRef<"Ad", 'String'>
    readonly name: FieldRef<"Ad", 'String'>
    readonly status: FieldRef<"Ad", 'AdStatus'>
    readonly headline: FieldRef<"Ad", 'String'>
    readonly description: FieldRef<"Ad", 'String'>
    readonly creativeType: FieldRef<"Ad", 'CreativeType'>
    readonly imageUrl: FieldRef<"Ad", 'String'>
    readonly videoUrl: FieldRef<"Ad", 'String'>
    readonly destinationUrl: FieldRef<"Ad", 'String'>
    readonly callToAction: FieldRef<"Ad", 'String'>
    readonly createdAt: FieldRef<"Ad", 'DateTime'>
    readonly updatedAt: FieldRef<"Ad", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Ad findUnique
   */
  export type AdFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * Filter, which Ad to fetch.
     */
    where: AdWhereUniqueInput
  }

  /**
   * Ad findUniqueOrThrow
   */
  export type AdFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * Filter, which Ad to fetch.
     */
    where: AdWhereUniqueInput
  }

  /**
   * Ad findFirst
   */
  export type AdFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * Filter, which Ad to fetch.
     */
    where?: AdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ads to fetch.
     */
    orderBy?: AdOrderByWithRelationInput | AdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ads.
     */
    cursor?: AdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ads.
     */
    distinct?: AdScalarFieldEnum | AdScalarFieldEnum[]
  }

  /**
   * Ad findFirstOrThrow
   */
  export type AdFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * Filter, which Ad to fetch.
     */
    where?: AdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ads to fetch.
     */
    orderBy?: AdOrderByWithRelationInput | AdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ads.
     */
    cursor?: AdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ads.
     */
    distinct?: AdScalarFieldEnum | AdScalarFieldEnum[]
  }

  /**
   * Ad findMany
   */
  export type AdFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * Filter, which Ads to fetch.
     */
    where?: AdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ads to fetch.
     */
    orderBy?: AdOrderByWithRelationInput | AdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ads.
     */
    cursor?: AdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ads.
     */
    skip?: number
    distinct?: AdScalarFieldEnum | AdScalarFieldEnum[]
  }

  /**
   * Ad create
   */
  export type AdCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * The data needed to create a Ad.
     */
    data: XOR<AdCreateInput, AdUncheckedCreateInput>
  }

  /**
   * Ad createMany
   */
  export type AdCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ads.
     */
    data: AdCreateManyInput | AdCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ad createManyAndReturn
   */
  export type AdCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * The data used to create many Ads.
     */
    data: AdCreateManyInput | AdCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ad update
   */
  export type AdUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * The data needed to update a Ad.
     */
    data: XOR<AdUpdateInput, AdUncheckedUpdateInput>
    /**
     * Choose, which Ad to update.
     */
    where: AdWhereUniqueInput
  }

  /**
   * Ad updateMany
   */
  export type AdUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ads.
     */
    data: XOR<AdUpdateManyMutationInput, AdUncheckedUpdateManyInput>
    /**
     * Filter which Ads to update
     */
    where?: AdWhereInput
    /**
     * Limit how many Ads to update.
     */
    limit?: number
  }

  /**
   * Ad updateManyAndReturn
   */
  export type AdUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * The data used to update Ads.
     */
    data: XOR<AdUpdateManyMutationInput, AdUncheckedUpdateManyInput>
    /**
     * Filter which Ads to update
     */
    where?: AdWhereInput
    /**
     * Limit how many Ads to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ad upsert
   */
  export type AdUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * The filter to search for the Ad to update in case it exists.
     */
    where: AdWhereUniqueInput
    /**
     * In case the Ad found by the `where` argument doesn't exist, create a new Ad with this data.
     */
    create: XOR<AdCreateInput, AdUncheckedCreateInput>
    /**
     * In case the Ad was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdUpdateInput, AdUncheckedUpdateInput>
  }

  /**
   * Ad delete
   */
  export type AdDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * Filter which Ad to delete.
     */
    where: AdWhereUniqueInput
  }

  /**
   * Ad deleteMany
   */
  export type AdDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ads to delete
     */
    where?: AdWhereInput
    /**
     * Limit how many Ads to delete.
     */
    limit?: number
  }

  /**
   * Ad.metaAccount
   */
  export type Ad$metaAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MetaAccount
     */
    select?: MetaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MetaAccount
     */
    omit?: MetaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MetaAccountInclude<ExtArgs> | null
    where?: MetaAccountWhereInput
  }

  /**
   * Ad.metrics
   */
  export type Ad$metricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdMetrics
     */
    select?: AdMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdMetrics
     */
    omit?: AdMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdMetricsInclude<ExtArgs> | null
    where?: AdMetricsWhereInput
    orderBy?: AdMetricsOrderByWithRelationInput | AdMetricsOrderByWithRelationInput[]
    cursor?: AdMetricsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdMetricsScalarFieldEnum | AdMetricsScalarFieldEnum[]
  }

  /**
   * Ad.schedules
   */
  export type Ad$schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    cursor?: ScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Ad without action
   */
  export type AdDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
  }


  /**
   * Model AdMetrics
   */

  export type AggregateAdMetrics = {
    _count: AdMetricsCountAggregateOutputType | null
    _avg: AdMetricsAvgAggregateOutputType | null
    _sum: AdMetricsSumAggregateOutputType | null
    _min: AdMetricsMinAggregateOutputType | null
    _max: AdMetricsMaxAggregateOutputType | null
  }

  export type AdMetricsAvgAggregateOutputType = {
    impressions: number | null
    clicks: number | null
    reach: number | null
    spend: number | null
    conversions: number | null
    costPerResult: number | null
    ctr: number | null
    cpc: number | null
    cpm: number | null
    frequency: number | null
    engagements: number | null
    shares: number | null
    comments: number | null
    saves: number | null
  }

  export type AdMetricsSumAggregateOutputType = {
    impressions: number | null
    clicks: number | null
    reach: number | null
    spend: number | null
    conversions: number | null
    costPerResult: number | null
    ctr: number | null
    cpc: number | null
    cpm: number | null
    frequency: number | null
    engagements: number | null
    shares: number | null
    comments: number | null
    saves: number | null
  }

  export type AdMetricsMinAggregateOutputType = {
    id: string | null
    adId: string | null
    date: Date | null
    impressions: number | null
    clicks: number | null
    reach: number | null
    spend: number | null
    conversions: number | null
    costPerResult: number | null
    ctr: number | null
    cpc: number | null
    cpm: number | null
    frequency: number | null
    engagements: number | null
    shares: number | null
    comments: number | null
    saves: number | null
  }

  export type AdMetricsMaxAggregateOutputType = {
    id: string | null
    adId: string | null
    date: Date | null
    impressions: number | null
    clicks: number | null
    reach: number | null
    spend: number | null
    conversions: number | null
    costPerResult: number | null
    ctr: number | null
    cpc: number | null
    cpm: number | null
    frequency: number | null
    engagements: number | null
    shares: number | null
    comments: number | null
    saves: number | null
  }

  export type AdMetricsCountAggregateOutputType = {
    id: number
    adId: number
    date: number
    impressions: number
    clicks: number
    reach: number
    spend: number
    conversions: number
    costPerResult: number
    ctr: number
    cpc: number
    cpm: number
    frequency: number
    engagements: number
    shares: number
    comments: number
    saves: number
    _all: number
  }


  export type AdMetricsAvgAggregateInputType = {
    impressions?: true
    clicks?: true
    reach?: true
    spend?: true
    conversions?: true
    costPerResult?: true
    ctr?: true
    cpc?: true
    cpm?: true
    frequency?: true
    engagements?: true
    shares?: true
    comments?: true
    saves?: true
  }

  export type AdMetricsSumAggregateInputType = {
    impressions?: true
    clicks?: true
    reach?: true
    spend?: true
    conversions?: true
    costPerResult?: true
    ctr?: true
    cpc?: true
    cpm?: true
    frequency?: true
    engagements?: true
    shares?: true
    comments?: true
    saves?: true
  }

  export type AdMetricsMinAggregateInputType = {
    id?: true
    adId?: true
    date?: true
    impressions?: true
    clicks?: true
    reach?: true
    spend?: true
    conversions?: true
    costPerResult?: true
    ctr?: true
    cpc?: true
    cpm?: true
    frequency?: true
    engagements?: true
    shares?: true
    comments?: true
    saves?: true
  }

  export type AdMetricsMaxAggregateInputType = {
    id?: true
    adId?: true
    date?: true
    impressions?: true
    clicks?: true
    reach?: true
    spend?: true
    conversions?: true
    costPerResult?: true
    ctr?: true
    cpc?: true
    cpm?: true
    frequency?: true
    engagements?: true
    shares?: true
    comments?: true
    saves?: true
  }

  export type AdMetricsCountAggregateInputType = {
    id?: true
    adId?: true
    date?: true
    impressions?: true
    clicks?: true
    reach?: true
    spend?: true
    conversions?: true
    costPerResult?: true
    ctr?: true
    cpc?: true
    cpm?: true
    frequency?: true
    engagements?: true
    shares?: true
    comments?: true
    saves?: true
    _all?: true
  }

  export type AdMetricsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdMetrics to aggregate.
     */
    where?: AdMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdMetrics to fetch.
     */
    orderBy?: AdMetricsOrderByWithRelationInput | AdMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdMetrics
    **/
    _count?: true | AdMetricsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdMetricsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdMetricsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdMetricsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdMetricsMaxAggregateInputType
  }

  export type GetAdMetricsAggregateType<T extends AdMetricsAggregateArgs> = {
        [P in keyof T & keyof AggregateAdMetrics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdMetrics[P]>
      : GetScalarType<T[P], AggregateAdMetrics[P]>
  }




  export type AdMetricsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdMetricsWhereInput
    orderBy?: AdMetricsOrderByWithAggregationInput | AdMetricsOrderByWithAggregationInput[]
    by: AdMetricsScalarFieldEnum[] | AdMetricsScalarFieldEnum
    having?: AdMetricsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdMetricsCountAggregateInputType | true
    _avg?: AdMetricsAvgAggregateInputType
    _sum?: AdMetricsSumAggregateInputType
    _min?: AdMetricsMinAggregateInputType
    _max?: AdMetricsMaxAggregateInputType
  }

  export type AdMetricsGroupByOutputType = {
    id: string
    adId: string
    date: Date
    impressions: number
    clicks: number
    reach: number
    spend: number
    conversions: number
    costPerResult: number | null
    ctr: number | null
    cpc: number | null
    cpm: number | null
    frequency: number | null
    engagements: number
    shares: number
    comments: number
    saves: number
    _count: AdMetricsCountAggregateOutputType | null
    _avg: AdMetricsAvgAggregateOutputType | null
    _sum: AdMetricsSumAggregateOutputType | null
    _min: AdMetricsMinAggregateOutputType | null
    _max: AdMetricsMaxAggregateOutputType | null
  }

  type GetAdMetricsGroupByPayload<T extends AdMetricsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdMetricsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdMetricsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdMetricsGroupByOutputType[P]>
            : GetScalarType<T[P], AdMetricsGroupByOutputType[P]>
        }
      >
    >


  export type AdMetricsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adId?: boolean
    date?: boolean
    impressions?: boolean
    clicks?: boolean
    reach?: boolean
    spend?: boolean
    conversions?: boolean
    costPerResult?: boolean
    ctr?: boolean
    cpc?: boolean
    cpm?: boolean
    frequency?: boolean
    engagements?: boolean
    shares?: boolean
    comments?: boolean
    saves?: boolean
    ad?: boolean | AdDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adMetrics"]>

  export type AdMetricsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adId?: boolean
    date?: boolean
    impressions?: boolean
    clicks?: boolean
    reach?: boolean
    spend?: boolean
    conversions?: boolean
    costPerResult?: boolean
    ctr?: boolean
    cpc?: boolean
    cpm?: boolean
    frequency?: boolean
    engagements?: boolean
    shares?: boolean
    comments?: boolean
    saves?: boolean
    ad?: boolean | AdDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adMetrics"]>

  export type AdMetricsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adId?: boolean
    date?: boolean
    impressions?: boolean
    clicks?: boolean
    reach?: boolean
    spend?: boolean
    conversions?: boolean
    costPerResult?: boolean
    ctr?: boolean
    cpc?: boolean
    cpm?: boolean
    frequency?: boolean
    engagements?: boolean
    shares?: boolean
    comments?: boolean
    saves?: boolean
    ad?: boolean | AdDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adMetrics"]>

  export type AdMetricsSelectScalar = {
    id?: boolean
    adId?: boolean
    date?: boolean
    impressions?: boolean
    clicks?: boolean
    reach?: boolean
    spend?: boolean
    conversions?: boolean
    costPerResult?: boolean
    ctr?: boolean
    cpc?: boolean
    cpm?: boolean
    frequency?: boolean
    engagements?: boolean
    shares?: boolean
    comments?: boolean
    saves?: boolean
  }

  export type AdMetricsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adId" | "date" | "impressions" | "clicks" | "reach" | "spend" | "conversions" | "costPerResult" | "ctr" | "cpc" | "cpm" | "frequency" | "engagements" | "shares" | "comments" | "saves", ExtArgs["result"]["adMetrics"]>
  export type AdMetricsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ad?: boolean | AdDefaultArgs<ExtArgs>
  }
  export type AdMetricsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ad?: boolean | AdDefaultArgs<ExtArgs>
  }
  export type AdMetricsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ad?: boolean | AdDefaultArgs<ExtArgs>
  }

  export type $AdMetricsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdMetrics"
    objects: {
      ad: Prisma.$AdPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adId: string
      date: Date
      impressions: number
      clicks: number
      reach: number
      spend: number
      conversions: number
      costPerResult: number | null
      ctr: number | null
      cpc: number | null
      cpm: number | null
      frequency: number | null
      engagements: number
      shares: number
      comments: number
      saves: number
    }, ExtArgs["result"]["adMetrics"]>
    composites: {}
  }

  type AdMetricsGetPayload<S extends boolean | null | undefined | AdMetricsDefaultArgs> = $Result.GetResult<Prisma.$AdMetricsPayload, S>

  type AdMetricsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdMetricsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdMetricsCountAggregateInputType | true
    }

  export interface AdMetricsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdMetrics'], meta: { name: 'AdMetrics' } }
    /**
     * Find zero or one AdMetrics that matches the filter.
     * @param {AdMetricsFindUniqueArgs} args - Arguments to find a AdMetrics
     * @example
     * // Get one AdMetrics
     * const adMetrics = await prisma.adMetrics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdMetricsFindUniqueArgs>(args: SelectSubset<T, AdMetricsFindUniqueArgs<ExtArgs>>): Prisma__AdMetricsClient<$Result.GetResult<Prisma.$AdMetricsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdMetrics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdMetricsFindUniqueOrThrowArgs} args - Arguments to find a AdMetrics
     * @example
     * // Get one AdMetrics
     * const adMetrics = await prisma.adMetrics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdMetricsFindUniqueOrThrowArgs>(args: SelectSubset<T, AdMetricsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdMetricsClient<$Result.GetResult<Prisma.$AdMetricsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdMetricsFindFirstArgs} args - Arguments to find a AdMetrics
     * @example
     * // Get one AdMetrics
     * const adMetrics = await prisma.adMetrics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdMetricsFindFirstArgs>(args?: SelectSubset<T, AdMetricsFindFirstArgs<ExtArgs>>): Prisma__AdMetricsClient<$Result.GetResult<Prisma.$AdMetricsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdMetrics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdMetricsFindFirstOrThrowArgs} args - Arguments to find a AdMetrics
     * @example
     * // Get one AdMetrics
     * const adMetrics = await prisma.adMetrics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdMetricsFindFirstOrThrowArgs>(args?: SelectSubset<T, AdMetricsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdMetricsClient<$Result.GetResult<Prisma.$AdMetricsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdMetricsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdMetrics
     * const adMetrics = await prisma.adMetrics.findMany()
     * 
     * // Get first 10 AdMetrics
     * const adMetrics = await prisma.adMetrics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adMetricsWithIdOnly = await prisma.adMetrics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdMetricsFindManyArgs>(args?: SelectSubset<T, AdMetricsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdMetricsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdMetrics.
     * @param {AdMetricsCreateArgs} args - Arguments to create a AdMetrics.
     * @example
     * // Create one AdMetrics
     * const AdMetrics = await prisma.adMetrics.create({
     *   data: {
     *     // ... data to create a AdMetrics
     *   }
     * })
     * 
     */
    create<T extends AdMetricsCreateArgs>(args: SelectSubset<T, AdMetricsCreateArgs<ExtArgs>>): Prisma__AdMetricsClient<$Result.GetResult<Prisma.$AdMetricsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdMetrics.
     * @param {AdMetricsCreateManyArgs} args - Arguments to create many AdMetrics.
     * @example
     * // Create many AdMetrics
     * const adMetrics = await prisma.adMetrics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdMetricsCreateManyArgs>(args?: SelectSubset<T, AdMetricsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdMetrics and returns the data saved in the database.
     * @param {AdMetricsCreateManyAndReturnArgs} args - Arguments to create many AdMetrics.
     * @example
     * // Create many AdMetrics
     * const adMetrics = await prisma.adMetrics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdMetrics and only return the `id`
     * const adMetricsWithIdOnly = await prisma.adMetrics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdMetricsCreateManyAndReturnArgs>(args?: SelectSubset<T, AdMetricsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdMetricsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdMetrics.
     * @param {AdMetricsDeleteArgs} args - Arguments to delete one AdMetrics.
     * @example
     * // Delete one AdMetrics
     * const AdMetrics = await prisma.adMetrics.delete({
     *   where: {
     *     // ... filter to delete one AdMetrics
     *   }
     * })
     * 
     */
    delete<T extends AdMetricsDeleteArgs>(args: SelectSubset<T, AdMetricsDeleteArgs<ExtArgs>>): Prisma__AdMetricsClient<$Result.GetResult<Prisma.$AdMetricsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdMetrics.
     * @param {AdMetricsUpdateArgs} args - Arguments to update one AdMetrics.
     * @example
     * // Update one AdMetrics
     * const adMetrics = await prisma.adMetrics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdMetricsUpdateArgs>(args: SelectSubset<T, AdMetricsUpdateArgs<ExtArgs>>): Prisma__AdMetricsClient<$Result.GetResult<Prisma.$AdMetricsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdMetrics.
     * @param {AdMetricsDeleteManyArgs} args - Arguments to filter AdMetrics to delete.
     * @example
     * // Delete a few AdMetrics
     * const { count } = await prisma.adMetrics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdMetricsDeleteManyArgs>(args?: SelectSubset<T, AdMetricsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdMetricsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdMetrics
     * const adMetrics = await prisma.adMetrics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdMetricsUpdateManyArgs>(args: SelectSubset<T, AdMetricsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdMetrics and returns the data updated in the database.
     * @param {AdMetricsUpdateManyAndReturnArgs} args - Arguments to update many AdMetrics.
     * @example
     * // Update many AdMetrics
     * const adMetrics = await prisma.adMetrics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdMetrics and only return the `id`
     * const adMetricsWithIdOnly = await prisma.adMetrics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdMetricsUpdateManyAndReturnArgs>(args: SelectSubset<T, AdMetricsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdMetricsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdMetrics.
     * @param {AdMetricsUpsertArgs} args - Arguments to update or create a AdMetrics.
     * @example
     * // Update or create a AdMetrics
     * const adMetrics = await prisma.adMetrics.upsert({
     *   create: {
     *     // ... data to create a AdMetrics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdMetrics we want to update
     *   }
     * })
     */
    upsert<T extends AdMetricsUpsertArgs>(args: SelectSubset<T, AdMetricsUpsertArgs<ExtArgs>>): Prisma__AdMetricsClient<$Result.GetResult<Prisma.$AdMetricsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdMetricsCountArgs} args - Arguments to filter AdMetrics to count.
     * @example
     * // Count the number of AdMetrics
     * const count = await prisma.adMetrics.count({
     *   where: {
     *     // ... the filter for the AdMetrics we want to count
     *   }
     * })
    **/
    count<T extends AdMetricsCountArgs>(
      args?: Subset<T, AdMetricsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdMetricsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdMetricsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdMetricsAggregateArgs>(args: Subset<T, AdMetricsAggregateArgs>): Prisma.PrismaPromise<GetAdMetricsAggregateType<T>>

    /**
     * Group by AdMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdMetricsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdMetricsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdMetricsGroupByArgs['orderBy'] }
        : { orderBy?: AdMetricsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdMetricsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdMetricsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdMetrics model
   */
  readonly fields: AdMetricsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdMetrics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdMetricsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ad<T extends AdDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdDefaultArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdMetrics model
   */
  interface AdMetricsFieldRefs {
    readonly id: FieldRef<"AdMetrics", 'String'>
    readonly adId: FieldRef<"AdMetrics", 'String'>
    readonly date: FieldRef<"AdMetrics", 'DateTime'>
    readonly impressions: FieldRef<"AdMetrics", 'Int'>
    readonly clicks: FieldRef<"AdMetrics", 'Int'>
    readonly reach: FieldRef<"AdMetrics", 'Int'>
    readonly spend: FieldRef<"AdMetrics", 'Float'>
    readonly conversions: FieldRef<"AdMetrics", 'Int'>
    readonly costPerResult: FieldRef<"AdMetrics", 'Float'>
    readonly ctr: FieldRef<"AdMetrics", 'Float'>
    readonly cpc: FieldRef<"AdMetrics", 'Float'>
    readonly cpm: FieldRef<"AdMetrics", 'Float'>
    readonly frequency: FieldRef<"AdMetrics", 'Float'>
    readonly engagements: FieldRef<"AdMetrics", 'Int'>
    readonly shares: FieldRef<"AdMetrics", 'Int'>
    readonly comments: FieldRef<"AdMetrics", 'Int'>
    readonly saves: FieldRef<"AdMetrics", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * AdMetrics findUnique
   */
  export type AdMetricsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdMetrics
     */
    select?: AdMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdMetrics
     */
    omit?: AdMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdMetricsInclude<ExtArgs> | null
    /**
     * Filter, which AdMetrics to fetch.
     */
    where: AdMetricsWhereUniqueInput
  }

  /**
   * AdMetrics findUniqueOrThrow
   */
  export type AdMetricsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdMetrics
     */
    select?: AdMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdMetrics
     */
    omit?: AdMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdMetricsInclude<ExtArgs> | null
    /**
     * Filter, which AdMetrics to fetch.
     */
    where: AdMetricsWhereUniqueInput
  }

  /**
   * AdMetrics findFirst
   */
  export type AdMetricsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdMetrics
     */
    select?: AdMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdMetrics
     */
    omit?: AdMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdMetricsInclude<ExtArgs> | null
    /**
     * Filter, which AdMetrics to fetch.
     */
    where?: AdMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdMetrics to fetch.
     */
    orderBy?: AdMetricsOrderByWithRelationInput | AdMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdMetrics.
     */
    cursor?: AdMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdMetrics.
     */
    distinct?: AdMetricsScalarFieldEnum | AdMetricsScalarFieldEnum[]
  }

  /**
   * AdMetrics findFirstOrThrow
   */
  export type AdMetricsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdMetrics
     */
    select?: AdMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdMetrics
     */
    omit?: AdMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdMetricsInclude<ExtArgs> | null
    /**
     * Filter, which AdMetrics to fetch.
     */
    where?: AdMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdMetrics to fetch.
     */
    orderBy?: AdMetricsOrderByWithRelationInput | AdMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdMetrics.
     */
    cursor?: AdMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdMetrics.
     */
    distinct?: AdMetricsScalarFieldEnum | AdMetricsScalarFieldEnum[]
  }

  /**
   * AdMetrics findMany
   */
  export type AdMetricsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdMetrics
     */
    select?: AdMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdMetrics
     */
    omit?: AdMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdMetricsInclude<ExtArgs> | null
    /**
     * Filter, which AdMetrics to fetch.
     */
    where?: AdMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdMetrics to fetch.
     */
    orderBy?: AdMetricsOrderByWithRelationInput | AdMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdMetrics.
     */
    cursor?: AdMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdMetrics.
     */
    skip?: number
    distinct?: AdMetricsScalarFieldEnum | AdMetricsScalarFieldEnum[]
  }

  /**
   * AdMetrics create
   */
  export type AdMetricsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdMetrics
     */
    select?: AdMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdMetrics
     */
    omit?: AdMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdMetricsInclude<ExtArgs> | null
    /**
     * The data needed to create a AdMetrics.
     */
    data: XOR<AdMetricsCreateInput, AdMetricsUncheckedCreateInput>
  }

  /**
   * AdMetrics createMany
   */
  export type AdMetricsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdMetrics.
     */
    data: AdMetricsCreateManyInput | AdMetricsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdMetrics createManyAndReturn
   */
  export type AdMetricsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdMetrics
     */
    select?: AdMetricsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdMetrics
     */
    omit?: AdMetricsOmit<ExtArgs> | null
    /**
     * The data used to create many AdMetrics.
     */
    data: AdMetricsCreateManyInput | AdMetricsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdMetricsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdMetrics update
   */
  export type AdMetricsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdMetrics
     */
    select?: AdMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdMetrics
     */
    omit?: AdMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdMetricsInclude<ExtArgs> | null
    /**
     * The data needed to update a AdMetrics.
     */
    data: XOR<AdMetricsUpdateInput, AdMetricsUncheckedUpdateInput>
    /**
     * Choose, which AdMetrics to update.
     */
    where: AdMetricsWhereUniqueInput
  }

  /**
   * AdMetrics updateMany
   */
  export type AdMetricsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdMetrics.
     */
    data: XOR<AdMetricsUpdateManyMutationInput, AdMetricsUncheckedUpdateManyInput>
    /**
     * Filter which AdMetrics to update
     */
    where?: AdMetricsWhereInput
    /**
     * Limit how many AdMetrics to update.
     */
    limit?: number
  }

  /**
   * AdMetrics updateManyAndReturn
   */
  export type AdMetricsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdMetrics
     */
    select?: AdMetricsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdMetrics
     */
    omit?: AdMetricsOmit<ExtArgs> | null
    /**
     * The data used to update AdMetrics.
     */
    data: XOR<AdMetricsUpdateManyMutationInput, AdMetricsUncheckedUpdateManyInput>
    /**
     * Filter which AdMetrics to update
     */
    where?: AdMetricsWhereInput
    /**
     * Limit how many AdMetrics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdMetricsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdMetrics upsert
   */
  export type AdMetricsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdMetrics
     */
    select?: AdMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdMetrics
     */
    omit?: AdMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdMetricsInclude<ExtArgs> | null
    /**
     * The filter to search for the AdMetrics to update in case it exists.
     */
    where: AdMetricsWhereUniqueInput
    /**
     * In case the AdMetrics found by the `where` argument doesn't exist, create a new AdMetrics with this data.
     */
    create: XOR<AdMetricsCreateInput, AdMetricsUncheckedCreateInput>
    /**
     * In case the AdMetrics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdMetricsUpdateInput, AdMetricsUncheckedUpdateInput>
  }

  /**
   * AdMetrics delete
   */
  export type AdMetricsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdMetrics
     */
    select?: AdMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdMetrics
     */
    omit?: AdMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdMetricsInclude<ExtArgs> | null
    /**
     * Filter which AdMetrics to delete.
     */
    where: AdMetricsWhereUniqueInput
  }

  /**
   * AdMetrics deleteMany
   */
  export type AdMetricsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdMetrics to delete
     */
    where?: AdMetricsWhereInput
    /**
     * Limit how many AdMetrics to delete.
     */
    limit?: number
  }

  /**
   * AdMetrics without action
   */
  export type AdMetricsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdMetrics
     */
    select?: AdMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdMetrics
     */
    omit?: AdMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdMetricsInclude<ExtArgs> | null
  }


  /**
   * Model Schedule
   */

  export type AggregateSchedule = {
    _count: ScheduleCountAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  export type ScheduleMinAggregateOutputType = {
    id: string | null
    userId: string | null
    adId: string | null
    title: string | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.ScheduleStatus | null
    priority: $Enums.SchedulePriority | null
    category: $Enums.ScheduleCategory | null
    clinicId: string | null
    productId: string | null
    recurrence: $Enums.RecurrencePattern | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduleMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    adId: string | null
    title: string | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.ScheduleStatus | null
    priority: $Enums.SchedulePriority | null
    category: $Enums.ScheduleCategory | null
    clinicId: string | null
    productId: string | null
    recurrence: $Enums.RecurrencePattern | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduleCountAggregateOutputType = {
    id: number
    userId: number
    adId: number
    title: number
    startDate: number
    endDate: number
    status: number
    priority: number
    category: number
    clinicId: number
    productId: number
    recurrence: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScheduleMinAggregateInputType = {
    id?: true
    userId?: true
    adId?: true
    title?: true
    startDate?: true
    endDate?: true
    status?: true
    priority?: true
    category?: true
    clinicId?: true
    productId?: true
    recurrence?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduleMaxAggregateInputType = {
    id?: true
    userId?: true
    adId?: true
    title?: true
    startDate?: true
    endDate?: true
    status?: true
    priority?: true
    category?: true
    clinicId?: true
    productId?: true
    recurrence?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduleCountAggregateInputType = {
    id?: true
    userId?: true
    adId?: true
    title?: true
    startDate?: true
    endDate?: true
    status?: true
    priority?: true
    category?: true
    clinicId?: true
    productId?: true
    recurrence?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedule to aggregate.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schedules
    **/
    _count?: true | ScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduleMaxAggregateInputType
  }

  export type GetScheduleAggregateType<T extends ScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchedule[P]>
      : GetScalarType<T[P], AggregateSchedule[P]>
  }




  export type ScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithAggregationInput | ScheduleOrderByWithAggregationInput[]
    by: ScheduleScalarFieldEnum[] | ScheduleScalarFieldEnum
    having?: ScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduleCountAggregateInputType | true
    _min?: ScheduleMinAggregateInputType
    _max?: ScheduleMaxAggregateInputType
  }

  export type ScheduleGroupByOutputType = {
    id: string
    userId: string
    adId: string | null
    title: string
    startDate: Date
    endDate: Date
    status: $Enums.ScheduleStatus
    priority: $Enums.SchedulePriority
    category: $Enums.ScheduleCategory | null
    clinicId: string | null
    productId: string | null
    recurrence: $Enums.RecurrencePattern | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ScheduleCountAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  type GetScheduleGroupByPayload<T extends ScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
        }
      >
    >


  export type ScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    adId?: boolean
    title?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    priority?: boolean
    category?: boolean
    clinicId?: boolean
    productId?: boolean
    recurrence?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    ad?: boolean | Schedule$adArgs<ExtArgs>
    clinic?: boolean | Schedule$clinicArgs<ExtArgs>
    product?: boolean | Schedule$productArgs<ExtArgs>
  }, ExtArgs["result"]["schedule"]>

  export type ScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    adId?: boolean
    title?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    priority?: boolean
    category?: boolean
    clinicId?: boolean
    productId?: boolean
    recurrence?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    ad?: boolean | Schedule$adArgs<ExtArgs>
    clinic?: boolean | Schedule$clinicArgs<ExtArgs>
    product?: boolean | Schedule$productArgs<ExtArgs>
  }, ExtArgs["result"]["schedule"]>

  export type ScheduleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    adId?: boolean
    title?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    priority?: boolean
    category?: boolean
    clinicId?: boolean
    productId?: boolean
    recurrence?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    ad?: boolean | Schedule$adArgs<ExtArgs>
    clinic?: boolean | Schedule$clinicArgs<ExtArgs>
    product?: boolean | Schedule$productArgs<ExtArgs>
  }, ExtArgs["result"]["schedule"]>

  export type ScheduleSelectScalar = {
    id?: boolean
    userId?: boolean
    adId?: boolean
    title?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    priority?: boolean
    category?: boolean
    clinicId?: boolean
    productId?: boolean
    recurrence?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "adId" | "title" | "startDate" | "endDate" | "status" | "priority" | "category" | "clinicId" | "productId" | "recurrence" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["schedule"]>
  export type ScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    ad?: boolean | Schedule$adArgs<ExtArgs>
    clinic?: boolean | Schedule$clinicArgs<ExtArgs>
    product?: boolean | Schedule$productArgs<ExtArgs>
  }
  export type ScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    ad?: boolean | Schedule$adArgs<ExtArgs>
    clinic?: boolean | Schedule$clinicArgs<ExtArgs>
    product?: boolean | Schedule$productArgs<ExtArgs>
  }
  export type ScheduleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    ad?: boolean | Schedule$adArgs<ExtArgs>
    clinic?: boolean | Schedule$clinicArgs<ExtArgs>
    product?: boolean | Schedule$productArgs<ExtArgs>
  }

  export type $SchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Schedule"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      ad: Prisma.$AdPayload<ExtArgs> | null
      clinic: Prisma.$ClinicPayload<ExtArgs> | null
      product: Prisma.$ProductPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      adId: string | null
      title: string
      startDate: Date
      endDate: Date
      status: $Enums.ScheduleStatus
      priority: $Enums.SchedulePriority
      category: $Enums.ScheduleCategory | null
      clinicId: string | null
      productId: string | null
      recurrence: $Enums.RecurrencePattern | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["schedule"]>
    composites: {}
  }

  type ScheduleGetPayload<S extends boolean | null | undefined | ScheduleDefaultArgs> = $Result.GetResult<Prisma.$SchedulePayload, S>

  type ScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScheduleCountAggregateInputType | true
    }

  export interface ScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Schedule'], meta: { name: 'Schedule' } }
    /**
     * Find zero or one Schedule that matches the filter.
     * @param {ScheduleFindUniqueArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduleFindUniqueArgs>(args: SelectSubset<T, ScheduleFindUniqueArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Schedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScheduleFindUniqueOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Schedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduleFindFirstArgs>(args?: SelectSubset<T, ScheduleFindFirstArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Schedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Schedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schedules
     * const schedules = await prisma.schedule.findMany()
     * 
     * // Get first 10 Schedules
     * const schedules = await prisma.schedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduleWithIdOnly = await prisma.schedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduleFindManyArgs>(args?: SelectSubset<T, ScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Schedule.
     * @param {ScheduleCreateArgs} args - Arguments to create a Schedule.
     * @example
     * // Create one Schedule
     * const Schedule = await prisma.schedule.create({
     *   data: {
     *     // ... data to create a Schedule
     *   }
     * })
     * 
     */
    create<T extends ScheduleCreateArgs>(args: SelectSubset<T, ScheduleCreateArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Schedules.
     * @param {ScheduleCreateManyArgs} args - Arguments to create many Schedules.
     * @example
     * // Create many Schedules
     * const schedule = await prisma.schedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduleCreateManyArgs>(args?: SelectSubset<T, ScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Schedules and returns the data saved in the database.
     * @param {ScheduleCreateManyAndReturnArgs} args - Arguments to create many Schedules.
     * @example
     * // Create many Schedules
     * const schedule = await prisma.schedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Schedules and only return the `id`
     * const scheduleWithIdOnly = await prisma.schedule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Schedule.
     * @param {ScheduleDeleteArgs} args - Arguments to delete one Schedule.
     * @example
     * // Delete one Schedule
     * const Schedule = await prisma.schedule.delete({
     *   where: {
     *     // ... filter to delete one Schedule
     *   }
     * })
     * 
     */
    delete<T extends ScheduleDeleteArgs>(args: SelectSubset<T, ScheduleDeleteArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Schedule.
     * @param {ScheduleUpdateArgs} args - Arguments to update one Schedule.
     * @example
     * // Update one Schedule
     * const schedule = await prisma.schedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduleUpdateArgs>(args: SelectSubset<T, ScheduleUpdateArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Schedules.
     * @param {ScheduleDeleteManyArgs} args - Arguments to filter Schedules to delete.
     * @example
     * // Delete a few Schedules
     * const { count } = await prisma.schedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduleDeleteManyArgs>(args?: SelectSubset<T, ScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schedules
     * const schedule = await prisma.schedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduleUpdateManyArgs>(args: SelectSubset<T, ScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schedules and returns the data updated in the database.
     * @param {ScheduleUpdateManyAndReturnArgs} args - Arguments to update many Schedules.
     * @example
     * // Update many Schedules
     * const schedule = await prisma.schedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Schedules and only return the `id`
     * const scheduleWithIdOnly = await prisma.schedule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, ScheduleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Schedule.
     * @param {ScheduleUpsertArgs} args - Arguments to update or create a Schedule.
     * @example
     * // Update or create a Schedule
     * const schedule = await prisma.schedule.upsert({
     *   create: {
     *     // ... data to create a Schedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Schedule we want to update
     *   }
     * })
     */
    upsert<T extends ScheduleUpsertArgs>(args: SelectSubset<T, ScheduleUpsertArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleCountArgs} args - Arguments to filter Schedules to count.
     * @example
     * // Count the number of Schedules
     * const count = await prisma.schedule.count({
     *   where: {
     *     // ... the filter for the Schedules we want to count
     *   }
     * })
    **/
    count<T extends ScheduleCountArgs>(
      args?: Subset<T, ScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduleAggregateArgs>(args: Subset<T, ScheduleAggregateArgs>): Prisma.PrismaPromise<GetScheduleAggregateType<T>>

    /**
     * Group by Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduleGroupByArgs['orderBy'] }
        : { orderBy?: ScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Schedule model
   */
  readonly fields: ScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Schedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ad<T extends Schedule$adArgs<ExtArgs> = {}>(args?: Subset<T, Schedule$adArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    clinic<T extends Schedule$clinicArgs<ExtArgs> = {}>(args?: Subset<T, Schedule$clinicArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    product<T extends Schedule$productArgs<ExtArgs> = {}>(args?: Subset<T, Schedule$productArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Schedule model
   */
  interface ScheduleFieldRefs {
    readonly id: FieldRef<"Schedule", 'String'>
    readonly userId: FieldRef<"Schedule", 'String'>
    readonly adId: FieldRef<"Schedule", 'String'>
    readonly title: FieldRef<"Schedule", 'String'>
    readonly startDate: FieldRef<"Schedule", 'DateTime'>
    readonly endDate: FieldRef<"Schedule", 'DateTime'>
    readonly status: FieldRef<"Schedule", 'ScheduleStatus'>
    readonly priority: FieldRef<"Schedule", 'SchedulePriority'>
    readonly category: FieldRef<"Schedule", 'ScheduleCategory'>
    readonly clinicId: FieldRef<"Schedule", 'String'>
    readonly productId: FieldRef<"Schedule", 'String'>
    readonly recurrence: FieldRef<"Schedule", 'RecurrencePattern'>
    readonly notes: FieldRef<"Schedule", 'String'>
    readonly createdAt: FieldRef<"Schedule", 'DateTime'>
    readonly updatedAt: FieldRef<"Schedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Schedule findUnique
   */
  export type ScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule findUniqueOrThrow
   */
  export type ScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule findFirst
   */
  export type ScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule findFirstOrThrow
   */
  export type ScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule findMany
   */
  export type ScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedules to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule create
   */
  export type ScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a Schedule.
     */
    data: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>
  }

  /**
   * Schedule createMany
   */
  export type ScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Schedules.
     */
    data: ScheduleCreateManyInput | ScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Schedule createManyAndReturn
   */
  export type ScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * The data used to create many Schedules.
     */
    data: ScheduleCreateManyInput | ScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Schedule update
   */
  export type ScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a Schedule.
     */
    data: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>
    /**
     * Choose, which Schedule to update.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule updateMany
   */
  export type ScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Schedules.
     */
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyInput>
    /**
     * Filter which Schedules to update
     */
    where?: ScheduleWhereInput
    /**
     * Limit how many Schedules to update.
     */
    limit?: number
  }

  /**
   * Schedule updateManyAndReturn
   */
  export type ScheduleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * The data used to update Schedules.
     */
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyInput>
    /**
     * Filter which Schedules to update
     */
    where?: ScheduleWhereInput
    /**
     * Limit how many Schedules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Schedule upsert
   */
  export type ScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the Schedule to update in case it exists.
     */
    where: ScheduleWhereUniqueInput
    /**
     * In case the Schedule found by the `where` argument doesn't exist, create a new Schedule with this data.
     */
    create: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>
    /**
     * In case the Schedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>
  }

  /**
   * Schedule delete
   */
  export type ScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter which Schedule to delete.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule deleteMany
   */
  export type ScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedules to delete
     */
    where?: ScheduleWhereInput
    /**
     * Limit how many Schedules to delete.
     */
    limit?: number
  }

  /**
   * Schedule.ad
   */
  export type Schedule$adArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    where?: AdWhereInput
  }

  /**
   * Schedule.clinic
   */
  export type Schedule$clinicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    where?: ClinicWhereInput
  }

  /**
   * Schedule.product
   */
  export type Schedule$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
  }

  /**
   * Schedule without action
   */
  export type ScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
  }


  /**
   * Model AdsPlanner
   */

  export type AggregateAdsPlanner = {
    _count: AdsPlannerCountAggregateOutputType | null
    _avg: AdsPlannerAvgAggregateOutputType | null
    _sum: AdsPlannerSumAggregateOutputType | null
    _min: AdsPlannerMinAggregateOutputType | null
    _max: AdsPlannerMaxAggregateOutputType | null
  }

  export type AdsPlannerAvgAggregateOutputType = {
    budgetAmount: number | null
    minAge: number | null
    maxAge: number | null
  }

  export type AdsPlannerSumAggregateOutputType = {
    budgetAmount: number | null
    minAge: number | null
    maxAge: number | null
  }

  export type AdsPlannerMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    objective: $Enums.CampaignObjective | null
    budgetType: $Enums.BudgetType | null
    budgetAmount: number | null
    whatsappNumber: string | null
    startDate: Date | null
    endDate: Date | null
    location: string | null
    minAge: number | null
    maxAge: number | null
    gender: $Enums.GenderTarget | null
    detailTargeting: string | null
    videoUrl: string | null
    websiteUrl: string | null
    primaryText: string | null
    headline: string | null
    ctaName: string | null
    ctaText: string | null
    preFilledMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdsPlannerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    objective: $Enums.CampaignObjective | null
    budgetType: $Enums.BudgetType | null
    budgetAmount: number | null
    whatsappNumber: string | null
    startDate: Date | null
    endDate: Date | null
    location: string | null
    minAge: number | null
    maxAge: number | null
    gender: $Enums.GenderTarget | null
    detailTargeting: string | null
    videoUrl: string | null
    websiteUrl: string | null
    primaryText: string | null
    headline: string | null
    ctaName: string | null
    ctaText: string | null
    preFilledMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdsPlannerCountAggregateOutputType = {
    id: number
    name: number
    description: number
    objective: number
    budgetType: number
    budgetAmount: number
    whatsappNumber: number
    startDate: number
    endDate: number
    location: number
    minAge: number
    maxAge: number
    gender: number
    detailTargeting: number
    videoUrl: number
    websiteUrl: number
    primaryText: number
    headline: number
    ctaName: number
    ctaText: number
    preFilledMessage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdsPlannerAvgAggregateInputType = {
    budgetAmount?: true
    minAge?: true
    maxAge?: true
  }

  export type AdsPlannerSumAggregateInputType = {
    budgetAmount?: true
    minAge?: true
    maxAge?: true
  }

  export type AdsPlannerMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    objective?: true
    budgetType?: true
    budgetAmount?: true
    whatsappNumber?: true
    startDate?: true
    endDate?: true
    location?: true
    minAge?: true
    maxAge?: true
    gender?: true
    detailTargeting?: true
    videoUrl?: true
    websiteUrl?: true
    primaryText?: true
    headline?: true
    ctaName?: true
    ctaText?: true
    preFilledMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdsPlannerMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    objective?: true
    budgetType?: true
    budgetAmount?: true
    whatsappNumber?: true
    startDate?: true
    endDate?: true
    location?: true
    minAge?: true
    maxAge?: true
    gender?: true
    detailTargeting?: true
    videoUrl?: true
    websiteUrl?: true
    primaryText?: true
    headline?: true
    ctaName?: true
    ctaText?: true
    preFilledMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdsPlannerCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    objective?: true
    budgetType?: true
    budgetAmount?: true
    whatsappNumber?: true
    startDate?: true
    endDate?: true
    location?: true
    minAge?: true
    maxAge?: true
    gender?: true
    detailTargeting?: true
    videoUrl?: true
    websiteUrl?: true
    primaryText?: true
    headline?: true
    ctaName?: true
    ctaText?: true
    preFilledMessage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdsPlannerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdsPlanner to aggregate.
     */
    where?: AdsPlannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdsPlanners to fetch.
     */
    orderBy?: AdsPlannerOrderByWithRelationInput | AdsPlannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdsPlannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdsPlanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdsPlanners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdsPlanners
    **/
    _count?: true | AdsPlannerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdsPlannerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdsPlannerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdsPlannerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdsPlannerMaxAggregateInputType
  }

  export type GetAdsPlannerAggregateType<T extends AdsPlannerAggregateArgs> = {
        [P in keyof T & keyof AggregateAdsPlanner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdsPlanner[P]>
      : GetScalarType<T[P], AggregateAdsPlanner[P]>
  }




  export type AdsPlannerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdsPlannerWhereInput
    orderBy?: AdsPlannerOrderByWithAggregationInput | AdsPlannerOrderByWithAggregationInput[]
    by: AdsPlannerScalarFieldEnum[] | AdsPlannerScalarFieldEnum
    having?: AdsPlannerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdsPlannerCountAggregateInputType | true
    _avg?: AdsPlannerAvgAggregateInputType
    _sum?: AdsPlannerSumAggregateInputType
    _min?: AdsPlannerMinAggregateInputType
    _max?: AdsPlannerMaxAggregateInputType
  }

  export type AdsPlannerGroupByOutputType = {
    id: string
    name: string
    description: string | null
    objective: $Enums.CampaignObjective
    budgetType: $Enums.BudgetType
    budgetAmount: number
    whatsappNumber: string | null
    startDate: Date
    endDate: Date
    location: string | null
    minAge: number | null
    maxAge: number | null
    gender: $Enums.GenderTarget | null
    detailTargeting: string | null
    videoUrl: string | null
    websiteUrl: string | null
    primaryText: string | null
    headline: string | null
    ctaName: string | null
    ctaText: string | null
    preFilledMessage: string | null
    createdAt: Date
    updatedAt: Date
    _count: AdsPlannerCountAggregateOutputType | null
    _avg: AdsPlannerAvgAggregateOutputType | null
    _sum: AdsPlannerSumAggregateOutputType | null
    _min: AdsPlannerMinAggregateOutputType | null
    _max: AdsPlannerMaxAggregateOutputType | null
  }

  type GetAdsPlannerGroupByPayload<T extends AdsPlannerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdsPlannerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdsPlannerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdsPlannerGroupByOutputType[P]>
            : GetScalarType<T[P], AdsPlannerGroupByOutputType[P]>
        }
      >
    >


  export type AdsPlannerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    objective?: boolean
    budgetType?: boolean
    budgetAmount?: boolean
    whatsappNumber?: boolean
    startDate?: boolean
    endDate?: boolean
    location?: boolean
    minAge?: boolean
    maxAge?: boolean
    gender?: boolean
    detailTargeting?: boolean
    videoUrl?: boolean
    websiteUrl?: boolean
    primaryText?: boolean
    headline?: boolean
    ctaName?: boolean
    ctaText?: boolean
    preFilledMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    planItems?: boolean | AdsPlanner$planItemsArgs<ExtArgs>
    _count?: boolean | AdsPlannerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adsPlanner"]>

  export type AdsPlannerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    objective?: boolean
    budgetType?: boolean
    budgetAmount?: boolean
    whatsappNumber?: boolean
    startDate?: boolean
    endDate?: boolean
    location?: boolean
    minAge?: boolean
    maxAge?: boolean
    gender?: boolean
    detailTargeting?: boolean
    videoUrl?: boolean
    websiteUrl?: boolean
    primaryText?: boolean
    headline?: boolean
    ctaName?: boolean
    ctaText?: boolean
    preFilledMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["adsPlanner"]>

  export type AdsPlannerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    objective?: boolean
    budgetType?: boolean
    budgetAmount?: boolean
    whatsappNumber?: boolean
    startDate?: boolean
    endDate?: boolean
    location?: boolean
    minAge?: boolean
    maxAge?: boolean
    gender?: boolean
    detailTargeting?: boolean
    videoUrl?: boolean
    websiteUrl?: boolean
    primaryText?: boolean
    headline?: boolean
    ctaName?: boolean
    ctaText?: boolean
    preFilledMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["adsPlanner"]>

  export type AdsPlannerSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    objective?: boolean
    budgetType?: boolean
    budgetAmount?: boolean
    whatsappNumber?: boolean
    startDate?: boolean
    endDate?: boolean
    location?: boolean
    minAge?: boolean
    maxAge?: boolean
    gender?: boolean
    detailTargeting?: boolean
    videoUrl?: boolean
    websiteUrl?: boolean
    primaryText?: boolean
    headline?: boolean
    ctaName?: boolean
    ctaText?: boolean
    preFilledMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdsPlannerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "objective" | "budgetType" | "budgetAmount" | "whatsappNumber" | "startDate" | "endDate" | "location" | "minAge" | "maxAge" | "gender" | "detailTargeting" | "videoUrl" | "websiteUrl" | "primaryText" | "headline" | "ctaName" | "ctaText" | "preFilledMessage" | "createdAt" | "updatedAt", ExtArgs["result"]["adsPlanner"]>
  export type AdsPlannerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planItems?: boolean | AdsPlanner$planItemsArgs<ExtArgs>
    _count?: boolean | AdsPlannerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdsPlannerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AdsPlannerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AdsPlannerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdsPlanner"
    objects: {
      planItems: Prisma.$PlannerItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      objective: $Enums.CampaignObjective
      budgetType: $Enums.BudgetType
      budgetAmount: number
      whatsappNumber: string | null
      startDate: Date
      endDate: Date
      location: string | null
      minAge: number | null
      maxAge: number | null
      gender: $Enums.GenderTarget | null
      detailTargeting: string | null
      videoUrl: string | null
      websiteUrl: string | null
      primaryText: string | null
      headline: string | null
      ctaName: string | null
      ctaText: string | null
      preFilledMessage: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["adsPlanner"]>
    composites: {}
  }

  type AdsPlannerGetPayload<S extends boolean | null | undefined | AdsPlannerDefaultArgs> = $Result.GetResult<Prisma.$AdsPlannerPayload, S>

  type AdsPlannerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdsPlannerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdsPlannerCountAggregateInputType | true
    }

  export interface AdsPlannerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdsPlanner'], meta: { name: 'AdsPlanner' } }
    /**
     * Find zero or one AdsPlanner that matches the filter.
     * @param {AdsPlannerFindUniqueArgs} args - Arguments to find a AdsPlanner
     * @example
     * // Get one AdsPlanner
     * const adsPlanner = await prisma.adsPlanner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdsPlannerFindUniqueArgs>(args: SelectSubset<T, AdsPlannerFindUniqueArgs<ExtArgs>>): Prisma__AdsPlannerClient<$Result.GetResult<Prisma.$AdsPlannerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdsPlanner that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdsPlannerFindUniqueOrThrowArgs} args - Arguments to find a AdsPlanner
     * @example
     * // Get one AdsPlanner
     * const adsPlanner = await prisma.adsPlanner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdsPlannerFindUniqueOrThrowArgs>(args: SelectSubset<T, AdsPlannerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdsPlannerClient<$Result.GetResult<Prisma.$AdsPlannerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdsPlanner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdsPlannerFindFirstArgs} args - Arguments to find a AdsPlanner
     * @example
     * // Get one AdsPlanner
     * const adsPlanner = await prisma.adsPlanner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdsPlannerFindFirstArgs>(args?: SelectSubset<T, AdsPlannerFindFirstArgs<ExtArgs>>): Prisma__AdsPlannerClient<$Result.GetResult<Prisma.$AdsPlannerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdsPlanner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdsPlannerFindFirstOrThrowArgs} args - Arguments to find a AdsPlanner
     * @example
     * // Get one AdsPlanner
     * const adsPlanner = await prisma.adsPlanner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdsPlannerFindFirstOrThrowArgs>(args?: SelectSubset<T, AdsPlannerFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdsPlannerClient<$Result.GetResult<Prisma.$AdsPlannerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdsPlanners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdsPlannerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdsPlanners
     * const adsPlanners = await prisma.adsPlanner.findMany()
     * 
     * // Get first 10 AdsPlanners
     * const adsPlanners = await prisma.adsPlanner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adsPlannerWithIdOnly = await prisma.adsPlanner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdsPlannerFindManyArgs>(args?: SelectSubset<T, AdsPlannerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdsPlannerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdsPlanner.
     * @param {AdsPlannerCreateArgs} args - Arguments to create a AdsPlanner.
     * @example
     * // Create one AdsPlanner
     * const AdsPlanner = await prisma.adsPlanner.create({
     *   data: {
     *     // ... data to create a AdsPlanner
     *   }
     * })
     * 
     */
    create<T extends AdsPlannerCreateArgs>(args: SelectSubset<T, AdsPlannerCreateArgs<ExtArgs>>): Prisma__AdsPlannerClient<$Result.GetResult<Prisma.$AdsPlannerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdsPlanners.
     * @param {AdsPlannerCreateManyArgs} args - Arguments to create many AdsPlanners.
     * @example
     * // Create many AdsPlanners
     * const adsPlanner = await prisma.adsPlanner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdsPlannerCreateManyArgs>(args?: SelectSubset<T, AdsPlannerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdsPlanners and returns the data saved in the database.
     * @param {AdsPlannerCreateManyAndReturnArgs} args - Arguments to create many AdsPlanners.
     * @example
     * // Create many AdsPlanners
     * const adsPlanner = await prisma.adsPlanner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdsPlanners and only return the `id`
     * const adsPlannerWithIdOnly = await prisma.adsPlanner.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdsPlannerCreateManyAndReturnArgs>(args?: SelectSubset<T, AdsPlannerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdsPlannerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdsPlanner.
     * @param {AdsPlannerDeleteArgs} args - Arguments to delete one AdsPlanner.
     * @example
     * // Delete one AdsPlanner
     * const AdsPlanner = await prisma.adsPlanner.delete({
     *   where: {
     *     // ... filter to delete one AdsPlanner
     *   }
     * })
     * 
     */
    delete<T extends AdsPlannerDeleteArgs>(args: SelectSubset<T, AdsPlannerDeleteArgs<ExtArgs>>): Prisma__AdsPlannerClient<$Result.GetResult<Prisma.$AdsPlannerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdsPlanner.
     * @param {AdsPlannerUpdateArgs} args - Arguments to update one AdsPlanner.
     * @example
     * // Update one AdsPlanner
     * const adsPlanner = await prisma.adsPlanner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdsPlannerUpdateArgs>(args: SelectSubset<T, AdsPlannerUpdateArgs<ExtArgs>>): Prisma__AdsPlannerClient<$Result.GetResult<Prisma.$AdsPlannerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdsPlanners.
     * @param {AdsPlannerDeleteManyArgs} args - Arguments to filter AdsPlanners to delete.
     * @example
     * // Delete a few AdsPlanners
     * const { count } = await prisma.adsPlanner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdsPlannerDeleteManyArgs>(args?: SelectSubset<T, AdsPlannerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdsPlanners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdsPlannerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdsPlanners
     * const adsPlanner = await prisma.adsPlanner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdsPlannerUpdateManyArgs>(args: SelectSubset<T, AdsPlannerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdsPlanners and returns the data updated in the database.
     * @param {AdsPlannerUpdateManyAndReturnArgs} args - Arguments to update many AdsPlanners.
     * @example
     * // Update many AdsPlanners
     * const adsPlanner = await prisma.adsPlanner.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdsPlanners and only return the `id`
     * const adsPlannerWithIdOnly = await prisma.adsPlanner.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdsPlannerUpdateManyAndReturnArgs>(args: SelectSubset<T, AdsPlannerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdsPlannerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdsPlanner.
     * @param {AdsPlannerUpsertArgs} args - Arguments to update or create a AdsPlanner.
     * @example
     * // Update or create a AdsPlanner
     * const adsPlanner = await prisma.adsPlanner.upsert({
     *   create: {
     *     // ... data to create a AdsPlanner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdsPlanner we want to update
     *   }
     * })
     */
    upsert<T extends AdsPlannerUpsertArgs>(args: SelectSubset<T, AdsPlannerUpsertArgs<ExtArgs>>): Prisma__AdsPlannerClient<$Result.GetResult<Prisma.$AdsPlannerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdsPlanners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdsPlannerCountArgs} args - Arguments to filter AdsPlanners to count.
     * @example
     * // Count the number of AdsPlanners
     * const count = await prisma.adsPlanner.count({
     *   where: {
     *     // ... the filter for the AdsPlanners we want to count
     *   }
     * })
    **/
    count<T extends AdsPlannerCountArgs>(
      args?: Subset<T, AdsPlannerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdsPlannerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdsPlanner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdsPlannerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdsPlannerAggregateArgs>(args: Subset<T, AdsPlannerAggregateArgs>): Prisma.PrismaPromise<GetAdsPlannerAggregateType<T>>

    /**
     * Group by AdsPlanner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdsPlannerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdsPlannerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdsPlannerGroupByArgs['orderBy'] }
        : { orderBy?: AdsPlannerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdsPlannerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdsPlannerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdsPlanner model
   */
  readonly fields: AdsPlannerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdsPlanner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdsPlannerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    planItems<T extends AdsPlanner$planItemsArgs<ExtArgs> = {}>(args?: Subset<T, AdsPlanner$planItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlannerItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdsPlanner model
   */
  interface AdsPlannerFieldRefs {
    readonly id: FieldRef<"AdsPlanner", 'String'>
    readonly name: FieldRef<"AdsPlanner", 'String'>
    readonly description: FieldRef<"AdsPlanner", 'String'>
    readonly objective: FieldRef<"AdsPlanner", 'CampaignObjective'>
    readonly budgetType: FieldRef<"AdsPlanner", 'BudgetType'>
    readonly budgetAmount: FieldRef<"AdsPlanner", 'Float'>
    readonly whatsappNumber: FieldRef<"AdsPlanner", 'String'>
    readonly startDate: FieldRef<"AdsPlanner", 'DateTime'>
    readonly endDate: FieldRef<"AdsPlanner", 'DateTime'>
    readonly location: FieldRef<"AdsPlanner", 'String'>
    readonly minAge: FieldRef<"AdsPlanner", 'Int'>
    readonly maxAge: FieldRef<"AdsPlanner", 'Int'>
    readonly gender: FieldRef<"AdsPlanner", 'GenderTarget'>
    readonly detailTargeting: FieldRef<"AdsPlanner", 'String'>
    readonly videoUrl: FieldRef<"AdsPlanner", 'String'>
    readonly websiteUrl: FieldRef<"AdsPlanner", 'String'>
    readonly primaryText: FieldRef<"AdsPlanner", 'String'>
    readonly headline: FieldRef<"AdsPlanner", 'String'>
    readonly ctaName: FieldRef<"AdsPlanner", 'String'>
    readonly ctaText: FieldRef<"AdsPlanner", 'String'>
    readonly preFilledMessage: FieldRef<"AdsPlanner", 'String'>
    readonly createdAt: FieldRef<"AdsPlanner", 'DateTime'>
    readonly updatedAt: FieldRef<"AdsPlanner", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdsPlanner findUnique
   */
  export type AdsPlannerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsPlanner
     */
    select?: AdsPlannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsPlanner
     */
    omit?: AdsPlannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsPlannerInclude<ExtArgs> | null
    /**
     * Filter, which AdsPlanner to fetch.
     */
    where: AdsPlannerWhereUniqueInput
  }

  /**
   * AdsPlanner findUniqueOrThrow
   */
  export type AdsPlannerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsPlanner
     */
    select?: AdsPlannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsPlanner
     */
    omit?: AdsPlannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsPlannerInclude<ExtArgs> | null
    /**
     * Filter, which AdsPlanner to fetch.
     */
    where: AdsPlannerWhereUniqueInput
  }

  /**
   * AdsPlanner findFirst
   */
  export type AdsPlannerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsPlanner
     */
    select?: AdsPlannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsPlanner
     */
    omit?: AdsPlannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsPlannerInclude<ExtArgs> | null
    /**
     * Filter, which AdsPlanner to fetch.
     */
    where?: AdsPlannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdsPlanners to fetch.
     */
    orderBy?: AdsPlannerOrderByWithRelationInput | AdsPlannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdsPlanners.
     */
    cursor?: AdsPlannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdsPlanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdsPlanners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdsPlanners.
     */
    distinct?: AdsPlannerScalarFieldEnum | AdsPlannerScalarFieldEnum[]
  }

  /**
   * AdsPlanner findFirstOrThrow
   */
  export type AdsPlannerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsPlanner
     */
    select?: AdsPlannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsPlanner
     */
    omit?: AdsPlannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsPlannerInclude<ExtArgs> | null
    /**
     * Filter, which AdsPlanner to fetch.
     */
    where?: AdsPlannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdsPlanners to fetch.
     */
    orderBy?: AdsPlannerOrderByWithRelationInput | AdsPlannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdsPlanners.
     */
    cursor?: AdsPlannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdsPlanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdsPlanners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdsPlanners.
     */
    distinct?: AdsPlannerScalarFieldEnum | AdsPlannerScalarFieldEnum[]
  }

  /**
   * AdsPlanner findMany
   */
  export type AdsPlannerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsPlanner
     */
    select?: AdsPlannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsPlanner
     */
    omit?: AdsPlannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsPlannerInclude<ExtArgs> | null
    /**
     * Filter, which AdsPlanners to fetch.
     */
    where?: AdsPlannerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdsPlanners to fetch.
     */
    orderBy?: AdsPlannerOrderByWithRelationInput | AdsPlannerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdsPlanners.
     */
    cursor?: AdsPlannerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdsPlanners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdsPlanners.
     */
    skip?: number
    distinct?: AdsPlannerScalarFieldEnum | AdsPlannerScalarFieldEnum[]
  }

  /**
   * AdsPlanner create
   */
  export type AdsPlannerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsPlanner
     */
    select?: AdsPlannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsPlanner
     */
    omit?: AdsPlannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsPlannerInclude<ExtArgs> | null
    /**
     * The data needed to create a AdsPlanner.
     */
    data: XOR<AdsPlannerCreateInput, AdsPlannerUncheckedCreateInput>
  }

  /**
   * AdsPlanner createMany
   */
  export type AdsPlannerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdsPlanners.
     */
    data: AdsPlannerCreateManyInput | AdsPlannerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdsPlanner createManyAndReturn
   */
  export type AdsPlannerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsPlanner
     */
    select?: AdsPlannerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdsPlanner
     */
    omit?: AdsPlannerOmit<ExtArgs> | null
    /**
     * The data used to create many AdsPlanners.
     */
    data: AdsPlannerCreateManyInput | AdsPlannerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdsPlanner update
   */
  export type AdsPlannerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsPlanner
     */
    select?: AdsPlannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsPlanner
     */
    omit?: AdsPlannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsPlannerInclude<ExtArgs> | null
    /**
     * The data needed to update a AdsPlanner.
     */
    data: XOR<AdsPlannerUpdateInput, AdsPlannerUncheckedUpdateInput>
    /**
     * Choose, which AdsPlanner to update.
     */
    where: AdsPlannerWhereUniqueInput
  }

  /**
   * AdsPlanner updateMany
   */
  export type AdsPlannerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdsPlanners.
     */
    data: XOR<AdsPlannerUpdateManyMutationInput, AdsPlannerUncheckedUpdateManyInput>
    /**
     * Filter which AdsPlanners to update
     */
    where?: AdsPlannerWhereInput
    /**
     * Limit how many AdsPlanners to update.
     */
    limit?: number
  }

  /**
   * AdsPlanner updateManyAndReturn
   */
  export type AdsPlannerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsPlanner
     */
    select?: AdsPlannerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdsPlanner
     */
    omit?: AdsPlannerOmit<ExtArgs> | null
    /**
     * The data used to update AdsPlanners.
     */
    data: XOR<AdsPlannerUpdateManyMutationInput, AdsPlannerUncheckedUpdateManyInput>
    /**
     * Filter which AdsPlanners to update
     */
    where?: AdsPlannerWhereInput
    /**
     * Limit how many AdsPlanners to update.
     */
    limit?: number
  }

  /**
   * AdsPlanner upsert
   */
  export type AdsPlannerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsPlanner
     */
    select?: AdsPlannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsPlanner
     */
    omit?: AdsPlannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsPlannerInclude<ExtArgs> | null
    /**
     * The filter to search for the AdsPlanner to update in case it exists.
     */
    where: AdsPlannerWhereUniqueInput
    /**
     * In case the AdsPlanner found by the `where` argument doesn't exist, create a new AdsPlanner with this data.
     */
    create: XOR<AdsPlannerCreateInput, AdsPlannerUncheckedCreateInput>
    /**
     * In case the AdsPlanner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdsPlannerUpdateInput, AdsPlannerUncheckedUpdateInput>
  }

  /**
   * AdsPlanner delete
   */
  export type AdsPlannerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsPlanner
     */
    select?: AdsPlannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsPlanner
     */
    omit?: AdsPlannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsPlannerInclude<ExtArgs> | null
    /**
     * Filter which AdsPlanner to delete.
     */
    where: AdsPlannerWhereUniqueInput
  }

  /**
   * AdsPlanner deleteMany
   */
  export type AdsPlannerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdsPlanners to delete
     */
    where?: AdsPlannerWhereInput
    /**
     * Limit how many AdsPlanners to delete.
     */
    limit?: number
  }

  /**
   * AdsPlanner.planItems
   */
  export type AdsPlanner$planItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannerItem
     */
    select?: PlannerItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlannerItem
     */
    omit?: PlannerItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannerItemInclude<ExtArgs> | null
    where?: PlannerItemWhereInput
    orderBy?: PlannerItemOrderByWithRelationInput | PlannerItemOrderByWithRelationInput[]
    cursor?: PlannerItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlannerItemScalarFieldEnum | PlannerItemScalarFieldEnum[]
  }

  /**
   * AdsPlanner without action
   */
  export type AdsPlannerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdsPlanner
     */
    select?: AdsPlannerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdsPlanner
     */
    omit?: AdsPlannerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdsPlannerInclude<ExtArgs> | null
  }


  /**
   * Model PlannerItem
   */

  export type AggregatePlannerItem = {
    _count: PlannerItemCountAggregateOutputType | null
    _avg: PlannerItemAvgAggregateOutputType | null
    _sum: PlannerItemSumAggregateOutputType | null
    _min: PlannerItemMinAggregateOutputType | null
    _max: PlannerItemMaxAggregateOutputType | null
  }

  export type PlannerItemAvgAggregateOutputType = {
    budget: number | null
  }

  export type PlannerItemSumAggregateOutputType = {
    budget: number | null
  }

  export type PlannerItemMinAggregateOutputType = {
    id: string | null
    plannerId: string | null
    title: string | null
    description: string | null
    platform: $Enums.PlatformType | null
    format: string | null
    budget: number | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.PlannerItemStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlannerItemMaxAggregateOutputType = {
    id: string | null
    plannerId: string | null
    title: string | null
    description: string | null
    platform: $Enums.PlatformType | null
    format: string | null
    budget: number | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.PlannerItemStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlannerItemCountAggregateOutputType = {
    id: number
    plannerId: number
    title: number
    description: number
    platform: number
    format: number
    budget: number
    startDate: number
    endDate: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlannerItemAvgAggregateInputType = {
    budget?: true
  }

  export type PlannerItemSumAggregateInputType = {
    budget?: true
  }

  export type PlannerItemMinAggregateInputType = {
    id?: true
    plannerId?: true
    title?: true
    description?: true
    platform?: true
    format?: true
    budget?: true
    startDate?: true
    endDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlannerItemMaxAggregateInputType = {
    id?: true
    plannerId?: true
    title?: true
    description?: true
    platform?: true
    format?: true
    budget?: true
    startDate?: true
    endDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlannerItemCountAggregateInputType = {
    id?: true
    plannerId?: true
    title?: true
    description?: true
    platform?: true
    format?: true
    budget?: true
    startDate?: true
    endDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlannerItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlannerItem to aggregate.
     */
    where?: PlannerItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlannerItems to fetch.
     */
    orderBy?: PlannerItemOrderByWithRelationInput | PlannerItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlannerItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlannerItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlannerItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlannerItems
    **/
    _count?: true | PlannerItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlannerItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlannerItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlannerItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlannerItemMaxAggregateInputType
  }

  export type GetPlannerItemAggregateType<T extends PlannerItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePlannerItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlannerItem[P]>
      : GetScalarType<T[P], AggregatePlannerItem[P]>
  }




  export type PlannerItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlannerItemWhereInput
    orderBy?: PlannerItemOrderByWithAggregationInput | PlannerItemOrderByWithAggregationInput[]
    by: PlannerItemScalarFieldEnum[] | PlannerItemScalarFieldEnum
    having?: PlannerItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlannerItemCountAggregateInputType | true
    _avg?: PlannerItemAvgAggregateInputType
    _sum?: PlannerItemSumAggregateInputType
    _min?: PlannerItemMinAggregateInputType
    _max?: PlannerItemMaxAggregateInputType
  }

  export type PlannerItemGroupByOutputType = {
    id: string
    plannerId: string
    title: string
    description: string | null
    platform: $Enums.PlatformType
    format: string | null
    budget: number | null
    startDate: Date | null
    endDate: Date | null
    status: $Enums.PlannerItemStatus
    createdAt: Date
    updatedAt: Date
    _count: PlannerItemCountAggregateOutputType | null
    _avg: PlannerItemAvgAggregateOutputType | null
    _sum: PlannerItemSumAggregateOutputType | null
    _min: PlannerItemMinAggregateOutputType | null
    _max: PlannerItemMaxAggregateOutputType | null
  }

  type GetPlannerItemGroupByPayload<T extends PlannerItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlannerItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlannerItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlannerItemGroupByOutputType[P]>
            : GetScalarType<T[P], PlannerItemGroupByOutputType[P]>
        }
      >
    >


  export type PlannerItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plannerId?: boolean
    title?: boolean
    description?: boolean
    platform?: boolean
    format?: boolean
    budget?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    planner?: boolean | AdsPlannerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plannerItem"]>

  export type PlannerItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plannerId?: boolean
    title?: boolean
    description?: boolean
    platform?: boolean
    format?: boolean
    budget?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    planner?: boolean | AdsPlannerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plannerItem"]>

  export type PlannerItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plannerId?: boolean
    title?: boolean
    description?: boolean
    platform?: boolean
    format?: boolean
    budget?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    planner?: boolean | AdsPlannerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plannerItem"]>

  export type PlannerItemSelectScalar = {
    id?: boolean
    plannerId?: boolean
    title?: boolean
    description?: boolean
    platform?: boolean
    format?: boolean
    budget?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlannerItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "plannerId" | "title" | "description" | "platform" | "format" | "budget" | "startDate" | "endDate" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["plannerItem"]>
  export type PlannerItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planner?: boolean | AdsPlannerDefaultArgs<ExtArgs>
  }
  export type PlannerItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planner?: boolean | AdsPlannerDefaultArgs<ExtArgs>
  }
  export type PlannerItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    planner?: boolean | AdsPlannerDefaultArgs<ExtArgs>
  }

  export type $PlannerItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlannerItem"
    objects: {
      planner: Prisma.$AdsPlannerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      plannerId: string
      title: string
      description: string | null
      platform: $Enums.PlatformType
      format: string | null
      budget: number | null
      startDate: Date | null
      endDate: Date | null
      status: $Enums.PlannerItemStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["plannerItem"]>
    composites: {}
  }

  type PlannerItemGetPayload<S extends boolean | null | undefined | PlannerItemDefaultArgs> = $Result.GetResult<Prisma.$PlannerItemPayload, S>

  type PlannerItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlannerItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlannerItemCountAggregateInputType | true
    }

  export interface PlannerItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlannerItem'], meta: { name: 'PlannerItem' } }
    /**
     * Find zero or one PlannerItem that matches the filter.
     * @param {PlannerItemFindUniqueArgs} args - Arguments to find a PlannerItem
     * @example
     * // Get one PlannerItem
     * const plannerItem = await prisma.plannerItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlannerItemFindUniqueArgs>(args: SelectSubset<T, PlannerItemFindUniqueArgs<ExtArgs>>): Prisma__PlannerItemClient<$Result.GetResult<Prisma.$PlannerItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlannerItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlannerItemFindUniqueOrThrowArgs} args - Arguments to find a PlannerItem
     * @example
     * // Get one PlannerItem
     * const plannerItem = await prisma.plannerItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlannerItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PlannerItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlannerItemClient<$Result.GetResult<Prisma.$PlannerItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlannerItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlannerItemFindFirstArgs} args - Arguments to find a PlannerItem
     * @example
     * // Get one PlannerItem
     * const plannerItem = await prisma.plannerItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlannerItemFindFirstArgs>(args?: SelectSubset<T, PlannerItemFindFirstArgs<ExtArgs>>): Prisma__PlannerItemClient<$Result.GetResult<Prisma.$PlannerItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlannerItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlannerItemFindFirstOrThrowArgs} args - Arguments to find a PlannerItem
     * @example
     * // Get one PlannerItem
     * const plannerItem = await prisma.plannerItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlannerItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PlannerItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlannerItemClient<$Result.GetResult<Prisma.$PlannerItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlannerItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlannerItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlannerItems
     * const plannerItems = await prisma.plannerItem.findMany()
     * 
     * // Get first 10 PlannerItems
     * const plannerItems = await prisma.plannerItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plannerItemWithIdOnly = await prisma.plannerItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlannerItemFindManyArgs>(args?: SelectSubset<T, PlannerItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlannerItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlannerItem.
     * @param {PlannerItemCreateArgs} args - Arguments to create a PlannerItem.
     * @example
     * // Create one PlannerItem
     * const PlannerItem = await prisma.plannerItem.create({
     *   data: {
     *     // ... data to create a PlannerItem
     *   }
     * })
     * 
     */
    create<T extends PlannerItemCreateArgs>(args: SelectSubset<T, PlannerItemCreateArgs<ExtArgs>>): Prisma__PlannerItemClient<$Result.GetResult<Prisma.$PlannerItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlannerItems.
     * @param {PlannerItemCreateManyArgs} args - Arguments to create many PlannerItems.
     * @example
     * // Create many PlannerItems
     * const plannerItem = await prisma.plannerItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlannerItemCreateManyArgs>(args?: SelectSubset<T, PlannerItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlannerItems and returns the data saved in the database.
     * @param {PlannerItemCreateManyAndReturnArgs} args - Arguments to create many PlannerItems.
     * @example
     * // Create many PlannerItems
     * const plannerItem = await prisma.plannerItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlannerItems and only return the `id`
     * const plannerItemWithIdOnly = await prisma.plannerItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlannerItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PlannerItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlannerItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlannerItem.
     * @param {PlannerItemDeleteArgs} args - Arguments to delete one PlannerItem.
     * @example
     * // Delete one PlannerItem
     * const PlannerItem = await prisma.plannerItem.delete({
     *   where: {
     *     // ... filter to delete one PlannerItem
     *   }
     * })
     * 
     */
    delete<T extends PlannerItemDeleteArgs>(args: SelectSubset<T, PlannerItemDeleteArgs<ExtArgs>>): Prisma__PlannerItemClient<$Result.GetResult<Prisma.$PlannerItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlannerItem.
     * @param {PlannerItemUpdateArgs} args - Arguments to update one PlannerItem.
     * @example
     * // Update one PlannerItem
     * const plannerItem = await prisma.plannerItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlannerItemUpdateArgs>(args: SelectSubset<T, PlannerItemUpdateArgs<ExtArgs>>): Prisma__PlannerItemClient<$Result.GetResult<Prisma.$PlannerItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlannerItems.
     * @param {PlannerItemDeleteManyArgs} args - Arguments to filter PlannerItems to delete.
     * @example
     * // Delete a few PlannerItems
     * const { count } = await prisma.plannerItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlannerItemDeleteManyArgs>(args?: SelectSubset<T, PlannerItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlannerItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlannerItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlannerItems
     * const plannerItem = await prisma.plannerItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlannerItemUpdateManyArgs>(args: SelectSubset<T, PlannerItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlannerItems and returns the data updated in the database.
     * @param {PlannerItemUpdateManyAndReturnArgs} args - Arguments to update many PlannerItems.
     * @example
     * // Update many PlannerItems
     * const plannerItem = await prisma.plannerItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlannerItems and only return the `id`
     * const plannerItemWithIdOnly = await prisma.plannerItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlannerItemUpdateManyAndReturnArgs>(args: SelectSubset<T, PlannerItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlannerItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlannerItem.
     * @param {PlannerItemUpsertArgs} args - Arguments to update or create a PlannerItem.
     * @example
     * // Update or create a PlannerItem
     * const plannerItem = await prisma.plannerItem.upsert({
     *   create: {
     *     // ... data to create a PlannerItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlannerItem we want to update
     *   }
     * })
     */
    upsert<T extends PlannerItemUpsertArgs>(args: SelectSubset<T, PlannerItemUpsertArgs<ExtArgs>>): Prisma__PlannerItemClient<$Result.GetResult<Prisma.$PlannerItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlannerItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlannerItemCountArgs} args - Arguments to filter PlannerItems to count.
     * @example
     * // Count the number of PlannerItems
     * const count = await prisma.plannerItem.count({
     *   where: {
     *     // ... the filter for the PlannerItems we want to count
     *   }
     * })
    **/
    count<T extends PlannerItemCountArgs>(
      args?: Subset<T, PlannerItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlannerItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlannerItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlannerItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlannerItemAggregateArgs>(args: Subset<T, PlannerItemAggregateArgs>): Prisma.PrismaPromise<GetPlannerItemAggregateType<T>>

    /**
     * Group by PlannerItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlannerItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlannerItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlannerItemGroupByArgs['orderBy'] }
        : { orderBy?: PlannerItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlannerItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlannerItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlannerItem model
   */
  readonly fields: PlannerItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlannerItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlannerItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    planner<T extends AdsPlannerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdsPlannerDefaultArgs<ExtArgs>>): Prisma__AdsPlannerClient<$Result.GetResult<Prisma.$AdsPlannerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlannerItem model
   */
  interface PlannerItemFieldRefs {
    readonly id: FieldRef<"PlannerItem", 'String'>
    readonly plannerId: FieldRef<"PlannerItem", 'String'>
    readonly title: FieldRef<"PlannerItem", 'String'>
    readonly description: FieldRef<"PlannerItem", 'String'>
    readonly platform: FieldRef<"PlannerItem", 'PlatformType'>
    readonly format: FieldRef<"PlannerItem", 'String'>
    readonly budget: FieldRef<"PlannerItem", 'Float'>
    readonly startDate: FieldRef<"PlannerItem", 'DateTime'>
    readonly endDate: FieldRef<"PlannerItem", 'DateTime'>
    readonly status: FieldRef<"PlannerItem", 'PlannerItemStatus'>
    readonly createdAt: FieldRef<"PlannerItem", 'DateTime'>
    readonly updatedAt: FieldRef<"PlannerItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlannerItem findUnique
   */
  export type PlannerItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannerItem
     */
    select?: PlannerItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlannerItem
     */
    omit?: PlannerItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannerItemInclude<ExtArgs> | null
    /**
     * Filter, which PlannerItem to fetch.
     */
    where: PlannerItemWhereUniqueInput
  }

  /**
   * PlannerItem findUniqueOrThrow
   */
  export type PlannerItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannerItem
     */
    select?: PlannerItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlannerItem
     */
    omit?: PlannerItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannerItemInclude<ExtArgs> | null
    /**
     * Filter, which PlannerItem to fetch.
     */
    where: PlannerItemWhereUniqueInput
  }

  /**
   * PlannerItem findFirst
   */
  export type PlannerItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannerItem
     */
    select?: PlannerItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlannerItem
     */
    omit?: PlannerItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannerItemInclude<ExtArgs> | null
    /**
     * Filter, which PlannerItem to fetch.
     */
    where?: PlannerItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlannerItems to fetch.
     */
    orderBy?: PlannerItemOrderByWithRelationInput | PlannerItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlannerItems.
     */
    cursor?: PlannerItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlannerItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlannerItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlannerItems.
     */
    distinct?: PlannerItemScalarFieldEnum | PlannerItemScalarFieldEnum[]
  }

  /**
   * PlannerItem findFirstOrThrow
   */
  export type PlannerItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannerItem
     */
    select?: PlannerItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlannerItem
     */
    omit?: PlannerItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannerItemInclude<ExtArgs> | null
    /**
     * Filter, which PlannerItem to fetch.
     */
    where?: PlannerItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlannerItems to fetch.
     */
    orderBy?: PlannerItemOrderByWithRelationInput | PlannerItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlannerItems.
     */
    cursor?: PlannerItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlannerItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlannerItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlannerItems.
     */
    distinct?: PlannerItemScalarFieldEnum | PlannerItemScalarFieldEnum[]
  }

  /**
   * PlannerItem findMany
   */
  export type PlannerItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannerItem
     */
    select?: PlannerItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlannerItem
     */
    omit?: PlannerItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannerItemInclude<ExtArgs> | null
    /**
     * Filter, which PlannerItems to fetch.
     */
    where?: PlannerItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlannerItems to fetch.
     */
    orderBy?: PlannerItemOrderByWithRelationInput | PlannerItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlannerItems.
     */
    cursor?: PlannerItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlannerItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlannerItems.
     */
    skip?: number
    distinct?: PlannerItemScalarFieldEnum | PlannerItemScalarFieldEnum[]
  }

  /**
   * PlannerItem create
   */
  export type PlannerItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannerItem
     */
    select?: PlannerItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlannerItem
     */
    omit?: PlannerItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannerItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PlannerItem.
     */
    data: XOR<PlannerItemCreateInput, PlannerItemUncheckedCreateInput>
  }

  /**
   * PlannerItem createMany
   */
  export type PlannerItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlannerItems.
     */
    data: PlannerItemCreateManyInput | PlannerItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlannerItem createManyAndReturn
   */
  export type PlannerItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannerItem
     */
    select?: PlannerItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlannerItem
     */
    omit?: PlannerItemOmit<ExtArgs> | null
    /**
     * The data used to create many PlannerItems.
     */
    data: PlannerItemCreateManyInput | PlannerItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannerItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlannerItem update
   */
  export type PlannerItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannerItem
     */
    select?: PlannerItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlannerItem
     */
    omit?: PlannerItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannerItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PlannerItem.
     */
    data: XOR<PlannerItemUpdateInput, PlannerItemUncheckedUpdateInput>
    /**
     * Choose, which PlannerItem to update.
     */
    where: PlannerItemWhereUniqueInput
  }

  /**
   * PlannerItem updateMany
   */
  export type PlannerItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlannerItems.
     */
    data: XOR<PlannerItemUpdateManyMutationInput, PlannerItemUncheckedUpdateManyInput>
    /**
     * Filter which PlannerItems to update
     */
    where?: PlannerItemWhereInput
    /**
     * Limit how many PlannerItems to update.
     */
    limit?: number
  }

  /**
   * PlannerItem updateManyAndReturn
   */
  export type PlannerItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannerItem
     */
    select?: PlannerItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlannerItem
     */
    omit?: PlannerItemOmit<ExtArgs> | null
    /**
     * The data used to update PlannerItems.
     */
    data: XOR<PlannerItemUpdateManyMutationInput, PlannerItemUncheckedUpdateManyInput>
    /**
     * Filter which PlannerItems to update
     */
    where?: PlannerItemWhereInput
    /**
     * Limit how many PlannerItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannerItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlannerItem upsert
   */
  export type PlannerItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannerItem
     */
    select?: PlannerItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlannerItem
     */
    omit?: PlannerItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannerItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PlannerItem to update in case it exists.
     */
    where: PlannerItemWhereUniqueInput
    /**
     * In case the PlannerItem found by the `where` argument doesn't exist, create a new PlannerItem with this data.
     */
    create: XOR<PlannerItemCreateInput, PlannerItemUncheckedCreateInput>
    /**
     * In case the PlannerItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlannerItemUpdateInput, PlannerItemUncheckedUpdateInput>
  }

  /**
   * PlannerItem delete
   */
  export type PlannerItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannerItem
     */
    select?: PlannerItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlannerItem
     */
    omit?: PlannerItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannerItemInclude<ExtArgs> | null
    /**
     * Filter which PlannerItem to delete.
     */
    where: PlannerItemWhereUniqueInput
  }

  /**
   * PlannerItem deleteMany
   */
  export type PlannerItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlannerItems to delete
     */
    where?: PlannerItemWhereInput
    /**
     * Limit how many PlannerItems to delete.
     */
    limit?: number
  }

  /**
   * PlannerItem without action
   */
  export type PlannerItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlannerItem
     */
    select?: PlannerItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlannerItem
     */
    omit?: PlannerItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlannerItemInclude<ExtArgs> | null
  }


  /**
   * Model SocialMediaAccount
   */

  export type AggregateSocialMediaAccount = {
    _count: SocialMediaAccountCountAggregateOutputType | null
    _avg: SocialMediaAccountAvgAggregateOutputType | null
    _sum: SocialMediaAccountSumAggregateOutputType | null
    _min: SocialMediaAccountMinAggregateOutputType | null
    _max: SocialMediaAccountMaxAggregateOutputType | null
  }

  export type SocialMediaAccountAvgAggregateOutputType = {
    followers: number | null
  }

  export type SocialMediaAccountSumAggregateOutputType = {
    followers: number | null
  }

  export type SocialMediaAccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    platform: $Enums.PlatformType | null
    accountName: string | null
    accountId: string | null
    followers: number | null
    accessToken: string | null
    tokenExpiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SocialMediaAccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    platform: $Enums.PlatformType | null
    accountName: string | null
    accountId: string | null
    followers: number | null
    accessToken: string | null
    tokenExpiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SocialMediaAccountCountAggregateOutputType = {
    id: number
    userId: number
    platform: number
    accountName: number
    accountId: number
    followers: number
    accessToken: number
    tokenExpiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SocialMediaAccountAvgAggregateInputType = {
    followers?: true
  }

  export type SocialMediaAccountSumAggregateInputType = {
    followers?: true
  }

  export type SocialMediaAccountMinAggregateInputType = {
    id?: true
    userId?: true
    platform?: true
    accountName?: true
    accountId?: true
    followers?: true
    accessToken?: true
    tokenExpiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SocialMediaAccountMaxAggregateInputType = {
    id?: true
    userId?: true
    platform?: true
    accountName?: true
    accountId?: true
    followers?: true
    accessToken?: true
    tokenExpiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SocialMediaAccountCountAggregateInputType = {
    id?: true
    userId?: true
    platform?: true
    accountName?: true
    accountId?: true
    followers?: true
    accessToken?: true
    tokenExpiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SocialMediaAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialMediaAccount to aggregate.
     */
    where?: SocialMediaAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialMediaAccounts to fetch.
     */
    orderBy?: SocialMediaAccountOrderByWithRelationInput | SocialMediaAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SocialMediaAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialMediaAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialMediaAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SocialMediaAccounts
    **/
    _count?: true | SocialMediaAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SocialMediaAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SocialMediaAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SocialMediaAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SocialMediaAccountMaxAggregateInputType
  }

  export type GetSocialMediaAccountAggregateType<T extends SocialMediaAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateSocialMediaAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSocialMediaAccount[P]>
      : GetScalarType<T[P], AggregateSocialMediaAccount[P]>
  }




  export type SocialMediaAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SocialMediaAccountWhereInput
    orderBy?: SocialMediaAccountOrderByWithAggregationInput | SocialMediaAccountOrderByWithAggregationInput[]
    by: SocialMediaAccountScalarFieldEnum[] | SocialMediaAccountScalarFieldEnum
    having?: SocialMediaAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SocialMediaAccountCountAggregateInputType | true
    _avg?: SocialMediaAccountAvgAggregateInputType
    _sum?: SocialMediaAccountSumAggregateInputType
    _min?: SocialMediaAccountMinAggregateInputType
    _max?: SocialMediaAccountMaxAggregateInputType
  }

  export type SocialMediaAccountGroupByOutputType = {
    id: string
    userId: string
    platform: $Enums.PlatformType
    accountName: string
    accountId: string | null
    followers: number
    accessToken: string | null
    tokenExpiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: SocialMediaAccountCountAggregateOutputType | null
    _avg: SocialMediaAccountAvgAggregateOutputType | null
    _sum: SocialMediaAccountSumAggregateOutputType | null
    _min: SocialMediaAccountMinAggregateOutputType | null
    _max: SocialMediaAccountMaxAggregateOutputType | null
  }

  type GetSocialMediaAccountGroupByPayload<T extends SocialMediaAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SocialMediaAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SocialMediaAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SocialMediaAccountGroupByOutputType[P]>
            : GetScalarType<T[P], SocialMediaAccountGroupByOutputType[P]>
        }
      >
    >


  export type SocialMediaAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    platform?: boolean
    accountName?: boolean
    accountId?: boolean
    followers?: boolean
    accessToken?: boolean
    tokenExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    platformMetrics?: boolean | SocialMediaAccount$platformMetricsArgs<ExtArgs>
    engagementMetrics?: boolean | SocialMediaAccount$engagementMetricsArgs<ExtArgs>
    influencers?: boolean | SocialMediaAccount$influencersArgs<ExtArgs>
    _count?: boolean | SocialMediaAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["socialMediaAccount"]>

  export type SocialMediaAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    platform?: boolean
    accountName?: boolean
    accountId?: boolean
    followers?: boolean
    accessToken?: boolean
    tokenExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["socialMediaAccount"]>

  export type SocialMediaAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    platform?: boolean
    accountName?: boolean
    accountId?: boolean
    followers?: boolean
    accessToken?: boolean
    tokenExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["socialMediaAccount"]>

  export type SocialMediaAccountSelectScalar = {
    id?: boolean
    userId?: boolean
    platform?: boolean
    accountName?: boolean
    accountId?: boolean
    followers?: boolean
    accessToken?: boolean
    tokenExpiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SocialMediaAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "platform" | "accountName" | "accountId" | "followers" | "accessToken" | "tokenExpiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["socialMediaAccount"]>
  export type SocialMediaAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    platformMetrics?: boolean | SocialMediaAccount$platformMetricsArgs<ExtArgs>
    engagementMetrics?: boolean | SocialMediaAccount$engagementMetricsArgs<ExtArgs>
    influencers?: boolean | SocialMediaAccount$influencersArgs<ExtArgs>
    _count?: boolean | SocialMediaAccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SocialMediaAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SocialMediaAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SocialMediaAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SocialMediaAccount"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      platformMetrics: Prisma.$PlatformMetricsPayload<ExtArgs>[]
      engagementMetrics: Prisma.$EngagementMetricsPayload<ExtArgs>[]
      influencers: Prisma.$InfluencerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      platform: $Enums.PlatformType
      accountName: string
      accountId: string | null
      followers: number
      accessToken: string | null
      tokenExpiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["socialMediaAccount"]>
    composites: {}
  }

  type SocialMediaAccountGetPayload<S extends boolean | null | undefined | SocialMediaAccountDefaultArgs> = $Result.GetResult<Prisma.$SocialMediaAccountPayload, S>

  type SocialMediaAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SocialMediaAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SocialMediaAccountCountAggregateInputType | true
    }

  export interface SocialMediaAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SocialMediaAccount'], meta: { name: 'SocialMediaAccount' } }
    /**
     * Find zero or one SocialMediaAccount that matches the filter.
     * @param {SocialMediaAccountFindUniqueArgs} args - Arguments to find a SocialMediaAccount
     * @example
     * // Get one SocialMediaAccount
     * const socialMediaAccount = await prisma.socialMediaAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SocialMediaAccountFindUniqueArgs>(args: SelectSubset<T, SocialMediaAccountFindUniqueArgs<ExtArgs>>): Prisma__SocialMediaAccountClient<$Result.GetResult<Prisma.$SocialMediaAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SocialMediaAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SocialMediaAccountFindUniqueOrThrowArgs} args - Arguments to find a SocialMediaAccount
     * @example
     * // Get one SocialMediaAccount
     * const socialMediaAccount = await prisma.socialMediaAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SocialMediaAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, SocialMediaAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SocialMediaAccountClient<$Result.GetResult<Prisma.$SocialMediaAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SocialMediaAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialMediaAccountFindFirstArgs} args - Arguments to find a SocialMediaAccount
     * @example
     * // Get one SocialMediaAccount
     * const socialMediaAccount = await prisma.socialMediaAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SocialMediaAccountFindFirstArgs>(args?: SelectSubset<T, SocialMediaAccountFindFirstArgs<ExtArgs>>): Prisma__SocialMediaAccountClient<$Result.GetResult<Prisma.$SocialMediaAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SocialMediaAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialMediaAccountFindFirstOrThrowArgs} args - Arguments to find a SocialMediaAccount
     * @example
     * // Get one SocialMediaAccount
     * const socialMediaAccount = await prisma.socialMediaAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SocialMediaAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, SocialMediaAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__SocialMediaAccountClient<$Result.GetResult<Prisma.$SocialMediaAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SocialMediaAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialMediaAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SocialMediaAccounts
     * const socialMediaAccounts = await prisma.socialMediaAccount.findMany()
     * 
     * // Get first 10 SocialMediaAccounts
     * const socialMediaAccounts = await prisma.socialMediaAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const socialMediaAccountWithIdOnly = await prisma.socialMediaAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SocialMediaAccountFindManyArgs>(args?: SelectSubset<T, SocialMediaAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialMediaAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SocialMediaAccount.
     * @param {SocialMediaAccountCreateArgs} args - Arguments to create a SocialMediaAccount.
     * @example
     * // Create one SocialMediaAccount
     * const SocialMediaAccount = await prisma.socialMediaAccount.create({
     *   data: {
     *     // ... data to create a SocialMediaAccount
     *   }
     * })
     * 
     */
    create<T extends SocialMediaAccountCreateArgs>(args: SelectSubset<T, SocialMediaAccountCreateArgs<ExtArgs>>): Prisma__SocialMediaAccountClient<$Result.GetResult<Prisma.$SocialMediaAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SocialMediaAccounts.
     * @param {SocialMediaAccountCreateManyArgs} args - Arguments to create many SocialMediaAccounts.
     * @example
     * // Create many SocialMediaAccounts
     * const socialMediaAccount = await prisma.socialMediaAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SocialMediaAccountCreateManyArgs>(args?: SelectSubset<T, SocialMediaAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SocialMediaAccounts and returns the data saved in the database.
     * @param {SocialMediaAccountCreateManyAndReturnArgs} args - Arguments to create many SocialMediaAccounts.
     * @example
     * // Create many SocialMediaAccounts
     * const socialMediaAccount = await prisma.socialMediaAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SocialMediaAccounts and only return the `id`
     * const socialMediaAccountWithIdOnly = await prisma.socialMediaAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SocialMediaAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, SocialMediaAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialMediaAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SocialMediaAccount.
     * @param {SocialMediaAccountDeleteArgs} args - Arguments to delete one SocialMediaAccount.
     * @example
     * // Delete one SocialMediaAccount
     * const SocialMediaAccount = await prisma.socialMediaAccount.delete({
     *   where: {
     *     // ... filter to delete one SocialMediaAccount
     *   }
     * })
     * 
     */
    delete<T extends SocialMediaAccountDeleteArgs>(args: SelectSubset<T, SocialMediaAccountDeleteArgs<ExtArgs>>): Prisma__SocialMediaAccountClient<$Result.GetResult<Prisma.$SocialMediaAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SocialMediaAccount.
     * @param {SocialMediaAccountUpdateArgs} args - Arguments to update one SocialMediaAccount.
     * @example
     * // Update one SocialMediaAccount
     * const socialMediaAccount = await prisma.socialMediaAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SocialMediaAccountUpdateArgs>(args: SelectSubset<T, SocialMediaAccountUpdateArgs<ExtArgs>>): Prisma__SocialMediaAccountClient<$Result.GetResult<Prisma.$SocialMediaAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SocialMediaAccounts.
     * @param {SocialMediaAccountDeleteManyArgs} args - Arguments to filter SocialMediaAccounts to delete.
     * @example
     * // Delete a few SocialMediaAccounts
     * const { count } = await prisma.socialMediaAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SocialMediaAccountDeleteManyArgs>(args?: SelectSubset<T, SocialMediaAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialMediaAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialMediaAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SocialMediaAccounts
     * const socialMediaAccount = await prisma.socialMediaAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SocialMediaAccountUpdateManyArgs>(args: SelectSubset<T, SocialMediaAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SocialMediaAccounts and returns the data updated in the database.
     * @param {SocialMediaAccountUpdateManyAndReturnArgs} args - Arguments to update many SocialMediaAccounts.
     * @example
     * // Update many SocialMediaAccounts
     * const socialMediaAccount = await prisma.socialMediaAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SocialMediaAccounts and only return the `id`
     * const socialMediaAccountWithIdOnly = await prisma.socialMediaAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SocialMediaAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, SocialMediaAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SocialMediaAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SocialMediaAccount.
     * @param {SocialMediaAccountUpsertArgs} args - Arguments to update or create a SocialMediaAccount.
     * @example
     * // Update or create a SocialMediaAccount
     * const socialMediaAccount = await prisma.socialMediaAccount.upsert({
     *   create: {
     *     // ... data to create a SocialMediaAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SocialMediaAccount we want to update
     *   }
     * })
     */
    upsert<T extends SocialMediaAccountUpsertArgs>(args: SelectSubset<T, SocialMediaAccountUpsertArgs<ExtArgs>>): Prisma__SocialMediaAccountClient<$Result.GetResult<Prisma.$SocialMediaAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SocialMediaAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialMediaAccountCountArgs} args - Arguments to filter SocialMediaAccounts to count.
     * @example
     * // Count the number of SocialMediaAccounts
     * const count = await prisma.socialMediaAccount.count({
     *   where: {
     *     // ... the filter for the SocialMediaAccounts we want to count
     *   }
     * })
    **/
    count<T extends SocialMediaAccountCountArgs>(
      args?: Subset<T, SocialMediaAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SocialMediaAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SocialMediaAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialMediaAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SocialMediaAccountAggregateArgs>(args: Subset<T, SocialMediaAccountAggregateArgs>): Prisma.PrismaPromise<GetSocialMediaAccountAggregateType<T>>

    /**
     * Group by SocialMediaAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SocialMediaAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SocialMediaAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SocialMediaAccountGroupByArgs['orderBy'] }
        : { orderBy?: SocialMediaAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SocialMediaAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSocialMediaAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SocialMediaAccount model
   */
  readonly fields: SocialMediaAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SocialMediaAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SocialMediaAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    platformMetrics<T extends SocialMediaAccount$platformMetricsArgs<ExtArgs> = {}>(args?: Subset<T, SocialMediaAccount$platformMetricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformMetricsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    engagementMetrics<T extends SocialMediaAccount$engagementMetricsArgs<ExtArgs> = {}>(args?: Subset<T, SocialMediaAccount$engagementMetricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EngagementMetricsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    influencers<T extends SocialMediaAccount$influencersArgs<ExtArgs> = {}>(args?: Subset<T, SocialMediaAccount$influencersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InfluencerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SocialMediaAccount model
   */
  interface SocialMediaAccountFieldRefs {
    readonly id: FieldRef<"SocialMediaAccount", 'String'>
    readonly userId: FieldRef<"SocialMediaAccount", 'String'>
    readonly platform: FieldRef<"SocialMediaAccount", 'PlatformType'>
    readonly accountName: FieldRef<"SocialMediaAccount", 'String'>
    readonly accountId: FieldRef<"SocialMediaAccount", 'String'>
    readonly followers: FieldRef<"SocialMediaAccount", 'Int'>
    readonly accessToken: FieldRef<"SocialMediaAccount", 'String'>
    readonly tokenExpiresAt: FieldRef<"SocialMediaAccount", 'DateTime'>
    readonly createdAt: FieldRef<"SocialMediaAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"SocialMediaAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SocialMediaAccount findUnique
   */
  export type SocialMediaAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaAccount
     */
    select?: SocialMediaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaAccount
     */
    omit?: SocialMediaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaAccountInclude<ExtArgs> | null
    /**
     * Filter, which SocialMediaAccount to fetch.
     */
    where: SocialMediaAccountWhereUniqueInput
  }

  /**
   * SocialMediaAccount findUniqueOrThrow
   */
  export type SocialMediaAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaAccount
     */
    select?: SocialMediaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaAccount
     */
    omit?: SocialMediaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaAccountInclude<ExtArgs> | null
    /**
     * Filter, which SocialMediaAccount to fetch.
     */
    where: SocialMediaAccountWhereUniqueInput
  }

  /**
   * SocialMediaAccount findFirst
   */
  export type SocialMediaAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaAccount
     */
    select?: SocialMediaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaAccount
     */
    omit?: SocialMediaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaAccountInclude<ExtArgs> | null
    /**
     * Filter, which SocialMediaAccount to fetch.
     */
    where?: SocialMediaAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialMediaAccounts to fetch.
     */
    orderBy?: SocialMediaAccountOrderByWithRelationInput | SocialMediaAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialMediaAccounts.
     */
    cursor?: SocialMediaAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialMediaAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialMediaAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialMediaAccounts.
     */
    distinct?: SocialMediaAccountScalarFieldEnum | SocialMediaAccountScalarFieldEnum[]
  }

  /**
   * SocialMediaAccount findFirstOrThrow
   */
  export type SocialMediaAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaAccount
     */
    select?: SocialMediaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaAccount
     */
    omit?: SocialMediaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaAccountInclude<ExtArgs> | null
    /**
     * Filter, which SocialMediaAccount to fetch.
     */
    where?: SocialMediaAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialMediaAccounts to fetch.
     */
    orderBy?: SocialMediaAccountOrderByWithRelationInput | SocialMediaAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SocialMediaAccounts.
     */
    cursor?: SocialMediaAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialMediaAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialMediaAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SocialMediaAccounts.
     */
    distinct?: SocialMediaAccountScalarFieldEnum | SocialMediaAccountScalarFieldEnum[]
  }

  /**
   * SocialMediaAccount findMany
   */
  export type SocialMediaAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaAccount
     */
    select?: SocialMediaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaAccount
     */
    omit?: SocialMediaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaAccountInclude<ExtArgs> | null
    /**
     * Filter, which SocialMediaAccounts to fetch.
     */
    where?: SocialMediaAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SocialMediaAccounts to fetch.
     */
    orderBy?: SocialMediaAccountOrderByWithRelationInput | SocialMediaAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SocialMediaAccounts.
     */
    cursor?: SocialMediaAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SocialMediaAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SocialMediaAccounts.
     */
    skip?: number
    distinct?: SocialMediaAccountScalarFieldEnum | SocialMediaAccountScalarFieldEnum[]
  }

  /**
   * SocialMediaAccount create
   */
  export type SocialMediaAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaAccount
     */
    select?: SocialMediaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaAccount
     */
    omit?: SocialMediaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a SocialMediaAccount.
     */
    data: XOR<SocialMediaAccountCreateInput, SocialMediaAccountUncheckedCreateInput>
  }

  /**
   * SocialMediaAccount createMany
   */
  export type SocialMediaAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SocialMediaAccounts.
     */
    data: SocialMediaAccountCreateManyInput | SocialMediaAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SocialMediaAccount createManyAndReturn
   */
  export type SocialMediaAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaAccount
     */
    select?: SocialMediaAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaAccount
     */
    omit?: SocialMediaAccountOmit<ExtArgs> | null
    /**
     * The data used to create many SocialMediaAccounts.
     */
    data: SocialMediaAccountCreateManyInput | SocialMediaAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SocialMediaAccount update
   */
  export type SocialMediaAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaAccount
     */
    select?: SocialMediaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaAccount
     */
    omit?: SocialMediaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a SocialMediaAccount.
     */
    data: XOR<SocialMediaAccountUpdateInput, SocialMediaAccountUncheckedUpdateInput>
    /**
     * Choose, which SocialMediaAccount to update.
     */
    where: SocialMediaAccountWhereUniqueInput
  }

  /**
   * SocialMediaAccount updateMany
   */
  export type SocialMediaAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SocialMediaAccounts.
     */
    data: XOR<SocialMediaAccountUpdateManyMutationInput, SocialMediaAccountUncheckedUpdateManyInput>
    /**
     * Filter which SocialMediaAccounts to update
     */
    where?: SocialMediaAccountWhereInput
    /**
     * Limit how many SocialMediaAccounts to update.
     */
    limit?: number
  }

  /**
   * SocialMediaAccount updateManyAndReturn
   */
  export type SocialMediaAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaAccount
     */
    select?: SocialMediaAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaAccount
     */
    omit?: SocialMediaAccountOmit<ExtArgs> | null
    /**
     * The data used to update SocialMediaAccounts.
     */
    data: XOR<SocialMediaAccountUpdateManyMutationInput, SocialMediaAccountUncheckedUpdateManyInput>
    /**
     * Filter which SocialMediaAccounts to update
     */
    where?: SocialMediaAccountWhereInput
    /**
     * Limit how many SocialMediaAccounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaAccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SocialMediaAccount upsert
   */
  export type SocialMediaAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaAccount
     */
    select?: SocialMediaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaAccount
     */
    omit?: SocialMediaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the SocialMediaAccount to update in case it exists.
     */
    where: SocialMediaAccountWhereUniqueInput
    /**
     * In case the SocialMediaAccount found by the `where` argument doesn't exist, create a new SocialMediaAccount with this data.
     */
    create: XOR<SocialMediaAccountCreateInput, SocialMediaAccountUncheckedCreateInput>
    /**
     * In case the SocialMediaAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SocialMediaAccountUpdateInput, SocialMediaAccountUncheckedUpdateInput>
  }

  /**
   * SocialMediaAccount delete
   */
  export type SocialMediaAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaAccount
     */
    select?: SocialMediaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaAccount
     */
    omit?: SocialMediaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaAccountInclude<ExtArgs> | null
    /**
     * Filter which SocialMediaAccount to delete.
     */
    where: SocialMediaAccountWhereUniqueInput
  }

  /**
   * SocialMediaAccount deleteMany
   */
  export type SocialMediaAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SocialMediaAccounts to delete
     */
    where?: SocialMediaAccountWhereInput
    /**
     * Limit how many SocialMediaAccounts to delete.
     */
    limit?: number
  }

  /**
   * SocialMediaAccount.platformMetrics
   */
  export type SocialMediaAccount$platformMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformMetrics
     */
    select?: PlatformMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformMetrics
     */
    omit?: PlatformMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformMetricsInclude<ExtArgs> | null
    where?: PlatformMetricsWhereInput
    orderBy?: PlatformMetricsOrderByWithRelationInput | PlatformMetricsOrderByWithRelationInput[]
    cursor?: PlatformMetricsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlatformMetricsScalarFieldEnum | PlatformMetricsScalarFieldEnum[]
  }

  /**
   * SocialMediaAccount.engagementMetrics
   */
  export type SocialMediaAccount$engagementMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementMetrics
     */
    select?: EngagementMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EngagementMetrics
     */
    omit?: EngagementMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementMetricsInclude<ExtArgs> | null
    where?: EngagementMetricsWhereInput
    orderBy?: EngagementMetricsOrderByWithRelationInput | EngagementMetricsOrderByWithRelationInput[]
    cursor?: EngagementMetricsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EngagementMetricsScalarFieldEnum | EngagementMetricsScalarFieldEnum[]
  }

  /**
   * SocialMediaAccount.influencers
   */
  export type SocialMediaAccount$influencersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Influencer
     */
    select?: InfluencerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Influencer
     */
    omit?: InfluencerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerInclude<ExtArgs> | null
    where?: InfluencerWhereInput
    orderBy?: InfluencerOrderByWithRelationInput | InfluencerOrderByWithRelationInput[]
    cursor?: InfluencerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InfluencerScalarFieldEnum | InfluencerScalarFieldEnum[]
  }

  /**
   * SocialMediaAccount without action
   */
  export type SocialMediaAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SocialMediaAccount
     */
    select?: SocialMediaAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SocialMediaAccount
     */
    omit?: SocialMediaAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SocialMediaAccountInclude<ExtArgs> | null
  }


  /**
   * Model PlatformMetrics
   */

  export type AggregatePlatformMetrics = {
    _count: PlatformMetricsCountAggregateOutputType | null
    _avg: PlatformMetricsAvgAggregateOutputType | null
    _sum: PlatformMetricsSumAggregateOutputType | null
    _min: PlatformMetricsMinAggregateOutputType | null
    _max: PlatformMetricsMaxAggregateOutputType | null
  }

  export type PlatformMetricsAvgAggregateOutputType = {
    followers: number | null
    following: number | null
    posts: number | null
    impressions: number | null
    reach: number | null
    profileViews: number | null
    websiteClicks: number | null
  }

  export type PlatformMetricsSumAggregateOutputType = {
    followers: number | null
    following: number | null
    posts: number | null
    impressions: number | null
    reach: number | null
    profileViews: number | null
    websiteClicks: number | null
  }

  export type PlatformMetricsMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    date: Date | null
    followers: number | null
    following: number | null
    posts: number | null
    impressions: number | null
    reach: number | null
    profileViews: number | null
    websiteClicks: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlatformMetricsMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    date: Date | null
    followers: number | null
    following: number | null
    posts: number | null
    impressions: number | null
    reach: number | null
    profileViews: number | null
    websiteClicks: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlatformMetricsCountAggregateOutputType = {
    id: number
    accountId: number
    date: number
    followers: number
    following: number
    posts: number
    impressions: number
    reach: number
    profileViews: number
    websiteClicks: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlatformMetricsAvgAggregateInputType = {
    followers?: true
    following?: true
    posts?: true
    impressions?: true
    reach?: true
    profileViews?: true
    websiteClicks?: true
  }

  export type PlatformMetricsSumAggregateInputType = {
    followers?: true
    following?: true
    posts?: true
    impressions?: true
    reach?: true
    profileViews?: true
    websiteClicks?: true
  }

  export type PlatformMetricsMinAggregateInputType = {
    id?: true
    accountId?: true
    date?: true
    followers?: true
    following?: true
    posts?: true
    impressions?: true
    reach?: true
    profileViews?: true
    websiteClicks?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlatformMetricsMaxAggregateInputType = {
    id?: true
    accountId?: true
    date?: true
    followers?: true
    following?: true
    posts?: true
    impressions?: true
    reach?: true
    profileViews?: true
    websiteClicks?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlatformMetricsCountAggregateInputType = {
    id?: true
    accountId?: true
    date?: true
    followers?: true
    following?: true
    posts?: true
    impressions?: true
    reach?: true
    profileViews?: true
    websiteClicks?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlatformMetricsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlatformMetrics to aggregate.
     */
    where?: PlatformMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformMetrics to fetch.
     */
    orderBy?: PlatformMetricsOrderByWithRelationInput | PlatformMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlatformMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlatformMetrics
    **/
    _count?: true | PlatformMetricsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlatformMetricsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlatformMetricsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlatformMetricsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlatformMetricsMaxAggregateInputType
  }

  export type GetPlatformMetricsAggregateType<T extends PlatformMetricsAggregateArgs> = {
        [P in keyof T & keyof AggregatePlatformMetrics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlatformMetrics[P]>
      : GetScalarType<T[P], AggregatePlatformMetrics[P]>
  }




  export type PlatformMetricsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlatformMetricsWhereInput
    orderBy?: PlatformMetricsOrderByWithAggregationInput | PlatformMetricsOrderByWithAggregationInput[]
    by: PlatformMetricsScalarFieldEnum[] | PlatformMetricsScalarFieldEnum
    having?: PlatformMetricsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlatformMetricsCountAggregateInputType | true
    _avg?: PlatformMetricsAvgAggregateInputType
    _sum?: PlatformMetricsSumAggregateInputType
    _min?: PlatformMetricsMinAggregateInputType
    _max?: PlatformMetricsMaxAggregateInputType
  }

  export type PlatformMetricsGroupByOutputType = {
    id: string
    accountId: string
    date: Date
    followers: number
    following: number
    posts: number
    impressions: number
    reach: number
    profileViews: number
    websiteClicks: number
    createdAt: Date
    updatedAt: Date
    _count: PlatformMetricsCountAggregateOutputType | null
    _avg: PlatformMetricsAvgAggregateOutputType | null
    _sum: PlatformMetricsSumAggregateOutputType | null
    _min: PlatformMetricsMinAggregateOutputType | null
    _max: PlatformMetricsMaxAggregateOutputType | null
  }

  type GetPlatformMetricsGroupByPayload<T extends PlatformMetricsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlatformMetricsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlatformMetricsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlatformMetricsGroupByOutputType[P]>
            : GetScalarType<T[P], PlatformMetricsGroupByOutputType[P]>
        }
      >
    >


  export type PlatformMetricsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    date?: boolean
    followers?: boolean
    following?: boolean
    posts?: boolean
    impressions?: boolean
    reach?: boolean
    profileViews?: boolean
    websiteClicks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | SocialMediaAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["platformMetrics"]>

  export type PlatformMetricsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    date?: boolean
    followers?: boolean
    following?: boolean
    posts?: boolean
    impressions?: boolean
    reach?: boolean
    profileViews?: boolean
    websiteClicks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | SocialMediaAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["platformMetrics"]>

  export type PlatformMetricsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    date?: boolean
    followers?: boolean
    following?: boolean
    posts?: boolean
    impressions?: boolean
    reach?: boolean
    profileViews?: boolean
    websiteClicks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | SocialMediaAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["platformMetrics"]>

  export type PlatformMetricsSelectScalar = {
    id?: boolean
    accountId?: boolean
    date?: boolean
    followers?: boolean
    following?: boolean
    posts?: boolean
    impressions?: boolean
    reach?: boolean
    profileViews?: boolean
    websiteClicks?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlatformMetricsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "date" | "followers" | "following" | "posts" | "impressions" | "reach" | "profileViews" | "websiteClicks" | "createdAt" | "updatedAt", ExtArgs["result"]["platformMetrics"]>
  export type PlatformMetricsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | SocialMediaAccountDefaultArgs<ExtArgs>
  }
  export type PlatformMetricsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | SocialMediaAccountDefaultArgs<ExtArgs>
  }
  export type PlatformMetricsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | SocialMediaAccountDefaultArgs<ExtArgs>
  }

  export type $PlatformMetricsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlatformMetrics"
    objects: {
      account: Prisma.$SocialMediaAccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      date: Date
      followers: number
      following: number
      posts: number
      impressions: number
      reach: number
      profileViews: number
      websiteClicks: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["platformMetrics"]>
    composites: {}
  }

  type PlatformMetricsGetPayload<S extends boolean | null | undefined | PlatformMetricsDefaultArgs> = $Result.GetResult<Prisma.$PlatformMetricsPayload, S>

  type PlatformMetricsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlatformMetricsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlatformMetricsCountAggregateInputType | true
    }

  export interface PlatformMetricsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlatformMetrics'], meta: { name: 'PlatformMetrics' } }
    /**
     * Find zero or one PlatformMetrics that matches the filter.
     * @param {PlatformMetricsFindUniqueArgs} args - Arguments to find a PlatformMetrics
     * @example
     * // Get one PlatformMetrics
     * const platformMetrics = await prisma.platformMetrics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlatformMetricsFindUniqueArgs>(args: SelectSubset<T, PlatformMetricsFindUniqueArgs<ExtArgs>>): Prisma__PlatformMetricsClient<$Result.GetResult<Prisma.$PlatformMetricsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlatformMetrics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlatformMetricsFindUniqueOrThrowArgs} args - Arguments to find a PlatformMetrics
     * @example
     * // Get one PlatformMetrics
     * const platformMetrics = await prisma.platformMetrics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlatformMetricsFindUniqueOrThrowArgs>(args: SelectSubset<T, PlatformMetricsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlatformMetricsClient<$Result.GetResult<Prisma.$PlatformMetricsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlatformMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformMetricsFindFirstArgs} args - Arguments to find a PlatformMetrics
     * @example
     * // Get one PlatformMetrics
     * const platformMetrics = await prisma.platformMetrics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlatformMetricsFindFirstArgs>(args?: SelectSubset<T, PlatformMetricsFindFirstArgs<ExtArgs>>): Prisma__PlatformMetricsClient<$Result.GetResult<Prisma.$PlatformMetricsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlatformMetrics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformMetricsFindFirstOrThrowArgs} args - Arguments to find a PlatformMetrics
     * @example
     * // Get one PlatformMetrics
     * const platformMetrics = await prisma.platformMetrics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlatformMetricsFindFirstOrThrowArgs>(args?: SelectSubset<T, PlatformMetricsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlatformMetricsClient<$Result.GetResult<Prisma.$PlatformMetricsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlatformMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformMetricsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlatformMetrics
     * const platformMetrics = await prisma.platformMetrics.findMany()
     * 
     * // Get first 10 PlatformMetrics
     * const platformMetrics = await prisma.platformMetrics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const platformMetricsWithIdOnly = await prisma.platformMetrics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlatformMetricsFindManyArgs>(args?: SelectSubset<T, PlatformMetricsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformMetricsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlatformMetrics.
     * @param {PlatformMetricsCreateArgs} args - Arguments to create a PlatformMetrics.
     * @example
     * // Create one PlatformMetrics
     * const PlatformMetrics = await prisma.platformMetrics.create({
     *   data: {
     *     // ... data to create a PlatformMetrics
     *   }
     * })
     * 
     */
    create<T extends PlatformMetricsCreateArgs>(args: SelectSubset<T, PlatformMetricsCreateArgs<ExtArgs>>): Prisma__PlatformMetricsClient<$Result.GetResult<Prisma.$PlatformMetricsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlatformMetrics.
     * @param {PlatformMetricsCreateManyArgs} args - Arguments to create many PlatformMetrics.
     * @example
     * // Create many PlatformMetrics
     * const platformMetrics = await prisma.platformMetrics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlatformMetricsCreateManyArgs>(args?: SelectSubset<T, PlatformMetricsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlatformMetrics and returns the data saved in the database.
     * @param {PlatformMetricsCreateManyAndReturnArgs} args - Arguments to create many PlatformMetrics.
     * @example
     * // Create many PlatformMetrics
     * const platformMetrics = await prisma.platformMetrics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlatformMetrics and only return the `id`
     * const platformMetricsWithIdOnly = await prisma.platformMetrics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlatformMetricsCreateManyAndReturnArgs>(args?: SelectSubset<T, PlatformMetricsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformMetricsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlatformMetrics.
     * @param {PlatformMetricsDeleteArgs} args - Arguments to delete one PlatformMetrics.
     * @example
     * // Delete one PlatformMetrics
     * const PlatformMetrics = await prisma.platformMetrics.delete({
     *   where: {
     *     // ... filter to delete one PlatformMetrics
     *   }
     * })
     * 
     */
    delete<T extends PlatformMetricsDeleteArgs>(args: SelectSubset<T, PlatformMetricsDeleteArgs<ExtArgs>>): Prisma__PlatformMetricsClient<$Result.GetResult<Prisma.$PlatformMetricsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlatformMetrics.
     * @param {PlatformMetricsUpdateArgs} args - Arguments to update one PlatformMetrics.
     * @example
     * // Update one PlatformMetrics
     * const platformMetrics = await prisma.platformMetrics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlatformMetricsUpdateArgs>(args: SelectSubset<T, PlatformMetricsUpdateArgs<ExtArgs>>): Prisma__PlatformMetricsClient<$Result.GetResult<Prisma.$PlatformMetricsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlatformMetrics.
     * @param {PlatformMetricsDeleteManyArgs} args - Arguments to filter PlatformMetrics to delete.
     * @example
     * // Delete a few PlatformMetrics
     * const { count } = await prisma.platformMetrics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlatformMetricsDeleteManyArgs>(args?: SelectSubset<T, PlatformMetricsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlatformMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformMetricsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlatformMetrics
     * const platformMetrics = await prisma.platformMetrics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlatformMetricsUpdateManyArgs>(args: SelectSubset<T, PlatformMetricsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlatformMetrics and returns the data updated in the database.
     * @param {PlatformMetricsUpdateManyAndReturnArgs} args - Arguments to update many PlatformMetrics.
     * @example
     * // Update many PlatformMetrics
     * const platformMetrics = await prisma.platformMetrics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlatformMetrics and only return the `id`
     * const platformMetricsWithIdOnly = await prisma.platformMetrics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlatformMetricsUpdateManyAndReturnArgs>(args: SelectSubset<T, PlatformMetricsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformMetricsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlatformMetrics.
     * @param {PlatformMetricsUpsertArgs} args - Arguments to update or create a PlatformMetrics.
     * @example
     * // Update or create a PlatformMetrics
     * const platformMetrics = await prisma.platformMetrics.upsert({
     *   create: {
     *     // ... data to create a PlatformMetrics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlatformMetrics we want to update
     *   }
     * })
     */
    upsert<T extends PlatformMetricsUpsertArgs>(args: SelectSubset<T, PlatformMetricsUpsertArgs<ExtArgs>>): Prisma__PlatformMetricsClient<$Result.GetResult<Prisma.$PlatformMetricsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlatformMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformMetricsCountArgs} args - Arguments to filter PlatformMetrics to count.
     * @example
     * // Count the number of PlatformMetrics
     * const count = await prisma.platformMetrics.count({
     *   where: {
     *     // ... the filter for the PlatformMetrics we want to count
     *   }
     * })
    **/
    count<T extends PlatformMetricsCountArgs>(
      args?: Subset<T, PlatformMetricsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlatformMetricsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlatformMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformMetricsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlatformMetricsAggregateArgs>(args: Subset<T, PlatformMetricsAggregateArgs>): Prisma.PrismaPromise<GetPlatformMetricsAggregateType<T>>

    /**
     * Group by PlatformMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformMetricsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlatformMetricsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlatformMetricsGroupByArgs['orderBy'] }
        : { orderBy?: PlatformMetricsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlatformMetricsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlatformMetricsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlatformMetrics model
   */
  readonly fields: PlatformMetricsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlatformMetrics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlatformMetricsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends SocialMediaAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocialMediaAccountDefaultArgs<ExtArgs>>): Prisma__SocialMediaAccountClient<$Result.GetResult<Prisma.$SocialMediaAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlatformMetrics model
   */
  interface PlatformMetricsFieldRefs {
    readonly id: FieldRef<"PlatformMetrics", 'String'>
    readonly accountId: FieldRef<"PlatformMetrics", 'String'>
    readonly date: FieldRef<"PlatformMetrics", 'DateTime'>
    readonly followers: FieldRef<"PlatformMetrics", 'Int'>
    readonly following: FieldRef<"PlatformMetrics", 'Int'>
    readonly posts: FieldRef<"PlatformMetrics", 'Int'>
    readonly impressions: FieldRef<"PlatformMetrics", 'Int'>
    readonly reach: FieldRef<"PlatformMetrics", 'Int'>
    readonly profileViews: FieldRef<"PlatformMetrics", 'Int'>
    readonly websiteClicks: FieldRef<"PlatformMetrics", 'Int'>
    readonly createdAt: FieldRef<"PlatformMetrics", 'DateTime'>
    readonly updatedAt: FieldRef<"PlatformMetrics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlatformMetrics findUnique
   */
  export type PlatformMetricsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformMetrics
     */
    select?: PlatformMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformMetrics
     */
    omit?: PlatformMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformMetricsInclude<ExtArgs> | null
    /**
     * Filter, which PlatformMetrics to fetch.
     */
    where: PlatformMetricsWhereUniqueInput
  }

  /**
   * PlatformMetrics findUniqueOrThrow
   */
  export type PlatformMetricsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformMetrics
     */
    select?: PlatformMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformMetrics
     */
    omit?: PlatformMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformMetricsInclude<ExtArgs> | null
    /**
     * Filter, which PlatformMetrics to fetch.
     */
    where: PlatformMetricsWhereUniqueInput
  }

  /**
   * PlatformMetrics findFirst
   */
  export type PlatformMetricsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformMetrics
     */
    select?: PlatformMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformMetrics
     */
    omit?: PlatformMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformMetricsInclude<ExtArgs> | null
    /**
     * Filter, which PlatformMetrics to fetch.
     */
    where?: PlatformMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformMetrics to fetch.
     */
    orderBy?: PlatformMetricsOrderByWithRelationInput | PlatformMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlatformMetrics.
     */
    cursor?: PlatformMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlatformMetrics.
     */
    distinct?: PlatformMetricsScalarFieldEnum | PlatformMetricsScalarFieldEnum[]
  }

  /**
   * PlatformMetrics findFirstOrThrow
   */
  export type PlatformMetricsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformMetrics
     */
    select?: PlatformMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformMetrics
     */
    omit?: PlatformMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformMetricsInclude<ExtArgs> | null
    /**
     * Filter, which PlatformMetrics to fetch.
     */
    where?: PlatformMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformMetrics to fetch.
     */
    orderBy?: PlatformMetricsOrderByWithRelationInput | PlatformMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlatformMetrics.
     */
    cursor?: PlatformMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlatformMetrics.
     */
    distinct?: PlatformMetricsScalarFieldEnum | PlatformMetricsScalarFieldEnum[]
  }

  /**
   * PlatformMetrics findMany
   */
  export type PlatformMetricsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformMetrics
     */
    select?: PlatformMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformMetrics
     */
    omit?: PlatformMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformMetricsInclude<ExtArgs> | null
    /**
     * Filter, which PlatformMetrics to fetch.
     */
    where?: PlatformMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformMetrics to fetch.
     */
    orderBy?: PlatformMetricsOrderByWithRelationInput | PlatformMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlatformMetrics.
     */
    cursor?: PlatformMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformMetrics.
     */
    skip?: number
    distinct?: PlatformMetricsScalarFieldEnum | PlatformMetricsScalarFieldEnum[]
  }

  /**
   * PlatformMetrics create
   */
  export type PlatformMetricsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformMetrics
     */
    select?: PlatformMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformMetrics
     */
    omit?: PlatformMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformMetricsInclude<ExtArgs> | null
    /**
     * The data needed to create a PlatformMetrics.
     */
    data: XOR<PlatformMetricsCreateInput, PlatformMetricsUncheckedCreateInput>
  }

  /**
   * PlatformMetrics createMany
   */
  export type PlatformMetricsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlatformMetrics.
     */
    data: PlatformMetricsCreateManyInput | PlatformMetricsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlatformMetrics createManyAndReturn
   */
  export type PlatformMetricsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformMetrics
     */
    select?: PlatformMetricsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformMetrics
     */
    omit?: PlatformMetricsOmit<ExtArgs> | null
    /**
     * The data used to create many PlatformMetrics.
     */
    data: PlatformMetricsCreateManyInput | PlatformMetricsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformMetricsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlatformMetrics update
   */
  export type PlatformMetricsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformMetrics
     */
    select?: PlatformMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformMetrics
     */
    omit?: PlatformMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformMetricsInclude<ExtArgs> | null
    /**
     * The data needed to update a PlatformMetrics.
     */
    data: XOR<PlatformMetricsUpdateInput, PlatformMetricsUncheckedUpdateInput>
    /**
     * Choose, which PlatformMetrics to update.
     */
    where: PlatformMetricsWhereUniqueInput
  }

  /**
   * PlatformMetrics updateMany
   */
  export type PlatformMetricsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlatformMetrics.
     */
    data: XOR<PlatformMetricsUpdateManyMutationInput, PlatformMetricsUncheckedUpdateManyInput>
    /**
     * Filter which PlatformMetrics to update
     */
    where?: PlatformMetricsWhereInput
    /**
     * Limit how many PlatformMetrics to update.
     */
    limit?: number
  }

  /**
   * PlatformMetrics updateManyAndReturn
   */
  export type PlatformMetricsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformMetrics
     */
    select?: PlatformMetricsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformMetrics
     */
    omit?: PlatformMetricsOmit<ExtArgs> | null
    /**
     * The data used to update PlatformMetrics.
     */
    data: XOR<PlatformMetricsUpdateManyMutationInput, PlatformMetricsUncheckedUpdateManyInput>
    /**
     * Filter which PlatformMetrics to update
     */
    where?: PlatformMetricsWhereInput
    /**
     * Limit how many PlatformMetrics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformMetricsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlatformMetrics upsert
   */
  export type PlatformMetricsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformMetrics
     */
    select?: PlatformMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformMetrics
     */
    omit?: PlatformMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformMetricsInclude<ExtArgs> | null
    /**
     * The filter to search for the PlatformMetrics to update in case it exists.
     */
    where: PlatformMetricsWhereUniqueInput
    /**
     * In case the PlatformMetrics found by the `where` argument doesn't exist, create a new PlatformMetrics with this data.
     */
    create: XOR<PlatformMetricsCreateInput, PlatformMetricsUncheckedCreateInput>
    /**
     * In case the PlatformMetrics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlatformMetricsUpdateInput, PlatformMetricsUncheckedUpdateInput>
  }

  /**
   * PlatformMetrics delete
   */
  export type PlatformMetricsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformMetrics
     */
    select?: PlatformMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformMetrics
     */
    omit?: PlatformMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformMetricsInclude<ExtArgs> | null
    /**
     * Filter which PlatformMetrics to delete.
     */
    where: PlatformMetricsWhereUniqueInput
  }

  /**
   * PlatformMetrics deleteMany
   */
  export type PlatformMetricsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlatformMetrics to delete
     */
    where?: PlatformMetricsWhereInput
    /**
     * Limit how many PlatformMetrics to delete.
     */
    limit?: number
  }

  /**
   * PlatformMetrics without action
   */
  export type PlatformMetricsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformMetrics
     */
    select?: PlatformMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformMetrics
     */
    omit?: PlatformMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformMetricsInclude<ExtArgs> | null
  }


  /**
   * Model EngagementMetrics
   */

  export type AggregateEngagementMetrics = {
    _count: EngagementMetricsCountAggregateOutputType | null
    _avg: EngagementMetricsAvgAggregateOutputType | null
    _sum: EngagementMetricsSumAggregateOutputType | null
    _min: EngagementMetricsMinAggregateOutputType | null
    _max: EngagementMetricsMaxAggregateOutputType | null
  }

  export type EngagementMetricsAvgAggregateOutputType = {
    likes: number | null
    comments: number | null
    shares: number | null
    saves: number | null
    clicks: number | null
    engagementRate: number | null
  }

  export type EngagementMetricsSumAggregateOutputType = {
    likes: number | null
    comments: number | null
    shares: number | null
    saves: number | null
    clicks: number | null
    engagementRate: number | null
  }

  export type EngagementMetricsMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    date: Date | null
    likes: number | null
    comments: number | null
    shares: number | null
    saves: number | null
    clicks: number | null
    engagementRate: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EngagementMetricsMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    date: Date | null
    likes: number | null
    comments: number | null
    shares: number | null
    saves: number | null
    clicks: number | null
    engagementRate: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EngagementMetricsCountAggregateOutputType = {
    id: number
    accountId: number
    date: number
    likes: number
    comments: number
    shares: number
    saves: number
    clicks: number
    engagementRate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EngagementMetricsAvgAggregateInputType = {
    likes?: true
    comments?: true
    shares?: true
    saves?: true
    clicks?: true
    engagementRate?: true
  }

  export type EngagementMetricsSumAggregateInputType = {
    likes?: true
    comments?: true
    shares?: true
    saves?: true
    clicks?: true
    engagementRate?: true
  }

  export type EngagementMetricsMinAggregateInputType = {
    id?: true
    accountId?: true
    date?: true
    likes?: true
    comments?: true
    shares?: true
    saves?: true
    clicks?: true
    engagementRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EngagementMetricsMaxAggregateInputType = {
    id?: true
    accountId?: true
    date?: true
    likes?: true
    comments?: true
    shares?: true
    saves?: true
    clicks?: true
    engagementRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EngagementMetricsCountAggregateInputType = {
    id?: true
    accountId?: true
    date?: true
    likes?: true
    comments?: true
    shares?: true
    saves?: true
    clicks?: true
    engagementRate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EngagementMetricsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EngagementMetrics to aggregate.
     */
    where?: EngagementMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EngagementMetrics to fetch.
     */
    orderBy?: EngagementMetricsOrderByWithRelationInput | EngagementMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EngagementMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EngagementMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EngagementMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EngagementMetrics
    **/
    _count?: true | EngagementMetricsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EngagementMetricsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EngagementMetricsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EngagementMetricsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EngagementMetricsMaxAggregateInputType
  }

  export type GetEngagementMetricsAggregateType<T extends EngagementMetricsAggregateArgs> = {
        [P in keyof T & keyof AggregateEngagementMetrics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEngagementMetrics[P]>
      : GetScalarType<T[P], AggregateEngagementMetrics[P]>
  }




  export type EngagementMetricsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EngagementMetricsWhereInput
    orderBy?: EngagementMetricsOrderByWithAggregationInput | EngagementMetricsOrderByWithAggregationInput[]
    by: EngagementMetricsScalarFieldEnum[] | EngagementMetricsScalarFieldEnum
    having?: EngagementMetricsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EngagementMetricsCountAggregateInputType | true
    _avg?: EngagementMetricsAvgAggregateInputType
    _sum?: EngagementMetricsSumAggregateInputType
    _min?: EngagementMetricsMinAggregateInputType
    _max?: EngagementMetricsMaxAggregateInputType
  }

  export type EngagementMetricsGroupByOutputType = {
    id: string
    accountId: string
    date: Date
    likes: number
    comments: number
    shares: number
    saves: number
    clicks: number
    engagementRate: number | null
    createdAt: Date
    updatedAt: Date
    _count: EngagementMetricsCountAggregateOutputType | null
    _avg: EngagementMetricsAvgAggregateOutputType | null
    _sum: EngagementMetricsSumAggregateOutputType | null
    _min: EngagementMetricsMinAggregateOutputType | null
    _max: EngagementMetricsMaxAggregateOutputType | null
  }

  type GetEngagementMetricsGroupByPayload<T extends EngagementMetricsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EngagementMetricsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EngagementMetricsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EngagementMetricsGroupByOutputType[P]>
            : GetScalarType<T[P], EngagementMetricsGroupByOutputType[P]>
        }
      >
    >


  export type EngagementMetricsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    date?: boolean
    likes?: boolean
    comments?: boolean
    shares?: boolean
    saves?: boolean
    clicks?: boolean
    engagementRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | SocialMediaAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["engagementMetrics"]>

  export type EngagementMetricsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    date?: boolean
    likes?: boolean
    comments?: boolean
    shares?: boolean
    saves?: boolean
    clicks?: boolean
    engagementRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | SocialMediaAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["engagementMetrics"]>

  export type EngagementMetricsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    date?: boolean
    likes?: boolean
    comments?: boolean
    shares?: boolean
    saves?: boolean
    clicks?: boolean
    engagementRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | SocialMediaAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["engagementMetrics"]>

  export type EngagementMetricsSelectScalar = {
    id?: boolean
    accountId?: boolean
    date?: boolean
    likes?: boolean
    comments?: boolean
    shares?: boolean
    saves?: boolean
    clicks?: boolean
    engagementRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EngagementMetricsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "date" | "likes" | "comments" | "shares" | "saves" | "clicks" | "engagementRate" | "createdAt" | "updatedAt", ExtArgs["result"]["engagementMetrics"]>
  export type EngagementMetricsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | SocialMediaAccountDefaultArgs<ExtArgs>
  }
  export type EngagementMetricsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | SocialMediaAccountDefaultArgs<ExtArgs>
  }
  export type EngagementMetricsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | SocialMediaAccountDefaultArgs<ExtArgs>
  }

  export type $EngagementMetricsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EngagementMetrics"
    objects: {
      account: Prisma.$SocialMediaAccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      date: Date
      likes: number
      comments: number
      shares: number
      saves: number
      clicks: number
      engagementRate: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["engagementMetrics"]>
    composites: {}
  }

  type EngagementMetricsGetPayload<S extends boolean | null | undefined | EngagementMetricsDefaultArgs> = $Result.GetResult<Prisma.$EngagementMetricsPayload, S>

  type EngagementMetricsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EngagementMetricsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EngagementMetricsCountAggregateInputType | true
    }

  export interface EngagementMetricsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EngagementMetrics'], meta: { name: 'EngagementMetrics' } }
    /**
     * Find zero or one EngagementMetrics that matches the filter.
     * @param {EngagementMetricsFindUniqueArgs} args - Arguments to find a EngagementMetrics
     * @example
     * // Get one EngagementMetrics
     * const engagementMetrics = await prisma.engagementMetrics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EngagementMetricsFindUniqueArgs>(args: SelectSubset<T, EngagementMetricsFindUniqueArgs<ExtArgs>>): Prisma__EngagementMetricsClient<$Result.GetResult<Prisma.$EngagementMetricsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EngagementMetrics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EngagementMetricsFindUniqueOrThrowArgs} args - Arguments to find a EngagementMetrics
     * @example
     * // Get one EngagementMetrics
     * const engagementMetrics = await prisma.engagementMetrics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EngagementMetricsFindUniqueOrThrowArgs>(args: SelectSubset<T, EngagementMetricsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EngagementMetricsClient<$Result.GetResult<Prisma.$EngagementMetricsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EngagementMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementMetricsFindFirstArgs} args - Arguments to find a EngagementMetrics
     * @example
     * // Get one EngagementMetrics
     * const engagementMetrics = await prisma.engagementMetrics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EngagementMetricsFindFirstArgs>(args?: SelectSubset<T, EngagementMetricsFindFirstArgs<ExtArgs>>): Prisma__EngagementMetricsClient<$Result.GetResult<Prisma.$EngagementMetricsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EngagementMetrics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementMetricsFindFirstOrThrowArgs} args - Arguments to find a EngagementMetrics
     * @example
     * // Get one EngagementMetrics
     * const engagementMetrics = await prisma.engagementMetrics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EngagementMetricsFindFirstOrThrowArgs>(args?: SelectSubset<T, EngagementMetricsFindFirstOrThrowArgs<ExtArgs>>): Prisma__EngagementMetricsClient<$Result.GetResult<Prisma.$EngagementMetricsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EngagementMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementMetricsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EngagementMetrics
     * const engagementMetrics = await prisma.engagementMetrics.findMany()
     * 
     * // Get first 10 EngagementMetrics
     * const engagementMetrics = await prisma.engagementMetrics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const engagementMetricsWithIdOnly = await prisma.engagementMetrics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EngagementMetricsFindManyArgs>(args?: SelectSubset<T, EngagementMetricsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EngagementMetricsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EngagementMetrics.
     * @param {EngagementMetricsCreateArgs} args - Arguments to create a EngagementMetrics.
     * @example
     * // Create one EngagementMetrics
     * const EngagementMetrics = await prisma.engagementMetrics.create({
     *   data: {
     *     // ... data to create a EngagementMetrics
     *   }
     * })
     * 
     */
    create<T extends EngagementMetricsCreateArgs>(args: SelectSubset<T, EngagementMetricsCreateArgs<ExtArgs>>): Prisma__EngagementMetricsClient<$Result.GetResult<Prisma.$EngagementMetricsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EngagementMetrics.
     * @param {EngagementMetricsCreateManyArgs} args - Arguments to create many EngagementMetrics.
     * @example
     * // Create many EngagementMetrics
     * const engagementMetrics = await prisma.engagementMetrics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EngagementMetricsCreateManyArgs>(args?: SelectSubset<T, EngagementMetricsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EngagementMetrics and returns the data saved in the database.
     * @param {EngagementMetricsCreateManyAndReturnArgs} args - Arguments to create many EngagementMetrics.
     * @example
     * // Create many EngagementMetrics
     * const engagementMetrics = await prisma.engagementMetrics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EngagementMetrics and only return the `id`
     * const engagementMetricsWithIdOnly = await prisma.engagementMetrics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EngagementMetricsCreateManyAndReturnArgs>(args?: SelectSubset<T, EngagementMetricsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EngagementMetricsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EngagementMetrics.
     * @param {EngagementMetricsDeleteArgs} args - Arguments to delete one EngagementMetrics.
     * @example
     * // Delete one EngagementMetrics
     * const EngagementMetrics = await prisma.engagementMetrics.delete({
     *   where: {
     *     // ... filter to delete one EngagementMetrics
     *   }
     * })
     * 
     */
    delete<T extends EngagementMetricsDeleteArgs>(args: SelectSubset<T, EngagementMetricsDeleteArgs<ExtArgs>>): Prisma__EngagementMetricsClient<$Result.GetResult<Prisma.$EngagementMetricsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EngagementMetrics.
     * @param {EngagementMetricsUpdateArgs} args - Arguments to update one EngagementMetrics.
     * @example
     * // Update one EngagementMetrics
     * const engagementMetrics = await prisma.engagementMetrics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EngagementMetricsUpdateArgs>(args: SelectSubset<T, EngagementMetricsUpdateArgs<ExtArgs>>): Prisma__EngagementMetricsClient<$Result.GetResult<Prisma.$EngagementMetricsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EngagementMetrics.
     * @param {EngagementMetricsDeleteManyArgs} args - Arguments to filter EngagementMetrics to delete.
     * @example
     * // Delete a few EngagementMetrics
     * const { count } = await prisma.engagementMetrics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EngagementMetricsDeleteManyArgs>(args?: SelectSubset<T, EngagementMetricsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EngagementMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementMetricsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EngagementMetrics
     * const engagementMetrics = await prisma.engagementMetrics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EngagementMetricsUpdateManyArgs>(args: SelectSubset<T, EngagementMetricsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EngagementMetrics and returns the data updated in the database.
     * @param {EngagementMetricsUpdateManyAndReturnArgs} args - Arguments to update many EngagementMetrics.
     * @example
     * // Update many EngagementMetrics
     * const engagementMetrics = await prisma.engagementMetrics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EngagementMetrics and only return the `id`
     * const engagementMetricsWithIdOnly = await prisma.engagementMetrics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EngagementMetricsUpdateManyAndReturnArgs>(args: SelectSubset<T, EngagementMetricsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EngagementMetricsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EngagementMetrics.
     * @param {EngagementMetricsUpsertArgs} args - Arguments to update or create a EngagementMetrics.
     * @example
     * // Update or create a EngagementMetrics
     * const engagementMetrics = await prisma.engagementMetrics.upsert({
     *   create: {
     *     // ... data to create a EngagementMetrics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EngagementMetrics we want to update
     *   }
     * })
     */
    upsert<T extends EngagementMetricsUpsertArgs>(args: SelectSubset<T, EngagementMetricsUpsertArgs<ExtArgs>>): Prisma__EngagementMetricsClient<$Result.GetResult<Prisma.$EngagementMetricsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EngagementMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementMetricsCountArgs} args - Arguments to filter EngagementMetrics to count.
     * @example
     * // Count the number of EngagementMetrics
     * const count = await prisma.engagementMetrics.count({
     *   where: {
     *     // ... the filter for the EngagementMetrics we want to count
     *   }
     * })
    **/
    count<T extends EngagementMetricsCountArgs>(
      args?: Subset<T, EngagementMetricsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EngagementMetricsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EngagementMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementMetricsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EngagementMetricsAggregateArgs>(args: Subset<T, EngagementMetricsAggregateArgs>): Prisma.PrismaPromise<GetEngagementMetricsAggregateType<T>>

    /**
     * Group by EngagementMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementMetricsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EngagementMetricsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EngagementMetricsGroupByArgs['orderBy'] }
        : { orderBy?: EngagementMetricsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EngagementMetricsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEngagementMetricsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EngagementMetrics model
   */
  readonly fields: EngagementMetricsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EngagementMetrics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EngagementMetricsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends SocialMediaAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocialMediaAccountDefaultArgs<ExtArgs>>): Prisma__SocialMediaAccountClient<$Result.GetResult<Prisma.$SocialMediaAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EngagementMetrics model
   */
  interface EngagementMetricsFieldRefs {
    readonly id: FieldRef<"EngagementMetrics", 'String'>
    readonly accountId: FieldRef<"EngagementMetrics", 'String'>
    readonly date: FieldRef<"EngagementMetrics", 'DateTime'>
    readonly likes: FieldRef<"EngagementMetrics", 'Int'>
    readonly comments: FieldRef<"EngagementMetrics", 'Int'>
    readonly shares: FieldRef<"EngagementMetrics", 'Int'>
    readonly saves: FieldRef<"EngagementMetrics", 'Int'>
    readonly clicks: FieldRef<"EngagementMetrics", 'Int'>
    readonly engagementRate: FieldRef<"EngagementMetrics", 'Float'>
    readonly createdAt: FieldRef<"EngagementMetrics", 'DateTime'>
    readonly updatedAt: FieldRef<"EngagementMetrics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EngagementMetrics findUnique
   */
  export type EngagementMetricsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementMetrics
     */
    select?: EngagementMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EngagementMetrics
     */
    omit?: EngagementMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementMetricsInclude<ExtArgs> | null
    /**
     * Filter, which EngagementMetrics to fetch.
     */
    where: EngagementMetricsWhereUniqueInput
  }

  /**
   * EngagementMetrics findUniqueOrThrow
   */
  export type EngagementMetricsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementMetrics
     */
    select?: EngagementMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EngagementMetrics
     */
    omit?: EngagementMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementMetricsInclude<ExtArgs> | null
    /**
     * Filter, which EngagementMetrics to fetch.
     */
    where: EngagementMetricsWhereUniqueInput
  }

  /**
   * EngagementMetrics findFirst
   */
  export type EngagementMetricsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementMetrics
     */
    select?: EngagementMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EngagementMetrics
     */
    omit?: EngagementMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementMetricsInclude<ExtArgs> | null
    /**
     * Filter, which EngagementMetrics to fetch.
     */
    where?: EngagementMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EngagementMetrics to fetch.
     */
    orderBy?: EngagementMetricsOrderByWithRelationInput | EngagementMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EngagementMetrics.
     */
    cursor?: EngagementMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EngagementMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EngagementMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EngagementMetrics.
     */
    distinct?: EngagementMetricsScalarFieldEnum | EngagementMetricsScalarFieldEnum[]
  }

  /**
   * EngagementMetrics findFirstOrThrow
   */
  export type EngagementMetricsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementMetrics
     */
    select?: EngagementMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EngagementMetrics
     */
    omit?: EngagementMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementMetricsInclude<ExtArgs> | null
    /**
     * Filter, which EngagementMetrics to fetch.
     */
    where?: EngagementMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EngagementMetrics to fetch.
     */
    orderBy?: EngagementMetricsOrderByWithRelationInput | EngagementMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EngagementMetrics.
     */
    cursor?: EngagementMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EngagementMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EngagementMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EngagementMetrics.
     */
    distinct?: EngagementMetricsScalarFieldEnum | EngagementMetricsScalarFieldEnum[]
  }

  /**
   * EngagementMetrics findMany
   */
  export type EngagementMetricsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementMetrics
     */
    select?: EngagementMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EngagementMetrics
     */
    omit?: EngagementMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementMetricsInclude<ExtArgs> | null
    /**
     * Filter, which EngagementMetrics to fetch.
     */
    where?: EngagementMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EngagementMetrics to fetch.
     */
    orderBy?: EngagementMetricsOrderByWithRelationInput | EngagementMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EngagementMetrics.
     */
    cursor?: EngagementMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EngagementMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EngagementMetrics.
     */
    skip?: number
    distinct?: EngagementMetricsScalarFieldEnum | EngagementMetricsScalarFieldEnum[]
  }

  /**
   * EngagementMetrics create
   */
  export type EngagementMetricsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementMetrics
     */
    select?: EngagementMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EngagementMetrics
     */
    omit?: EngagementMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementMetricsInclude<ExtArgs> | null
    /**
     * The data needed to create a EngagementMetrics.
     */
    data: XOR<EngagementMetricsCreateInput, EngagementMetricsUncheckedCreateInput>
  }

  /**
   * EngagementMetrics createMany
   */
  export type EngagementMetricsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EngagementMetrics.
     */
    data: EngagementMetricsCreateManyInput | EngagementMetricsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EngagementMetrics createManyAndReturn
   */
  export type EngagementMetricsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementMetrics
     */
    select?: EngagementMetricsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EngagementMetrics
     */
    omit?: EngagementMetricsOmit<ExtArgs> | null
    /**
     * The data used to create many EngagementMetrics.
     */
    data: EngagementMetricsCreateManyInput | EngagementMetricsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementMetricsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EngagementMetrics update
   */
  export type EngagementMetricsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementMetrics
     */
    select?: EngagementMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EngagementMetrics
     */
    omit?: EngagementMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementMetricsInclude<ExtArgs> | null
    /**
     * The data needed to update a EngagementMetrics.
     */
    data: XOR<EngagementMetricsUpdateInput, EngagementMetricsUncheckedUpdateInput>
    /**
     * Choose, which EngagementMetrics to update.
     */
    where: EngagementMetricsWhereUniqueInput
  }

  /**
   * EngagementMetrics updateMany
   */
  export type EngagementMetricsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EngagementMetrics.
     */
    data: XOR<EngagementMetricsUpdateManyMutationInput, EngagementMetricsUncheckedUpdateManyInput>
    /**
     * Filter which EngagementMetrics to update
     */
    where?: EngagementMetricsWhereInput
    /**
     * Limit how many EngagementMetrics to update.
     */
    limit?: number
  }

  /**
   * EngagementMetrics updateManyAndReturn
   */
  export type EngagementMetricsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementMetrics
     */
    select?: EngagementMetricsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EngagementMetrics
     */
    omit?: EngagementMetricsOmit<ExtArgs> | null
    /**
     * The data used to update EngagementMetrics.
     */
    data: XOR<EngagementMetricsUpdateManyMutationInput, EngagementMetricsUncheckedUpdateManyInput>
    /**
     * Filter which EngagementMetrics to update
     */
    where?: EngagementMetricsWhereInput
    /**
     * Limit how many EngagementMetrics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementMetricsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EngagementMetrics upsert
   */
  export type EngagementMetricsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementMetrics
     */
    select?: EngagementMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EngagementMetrics
     */
    omit?: EngagementMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementMetricsInclude<ExtArgs> | null
    /**
     * The filter to search for the EngagementMetrics to update in case it exists.
     */
    where: EngagementMetricsWhereUniqueInput
    /**
     * In case the EngagementMetrics found by the `where` argument doesn't exist, create a new EngagementMetrics with this data.
     */
    create: XOR<EngagementMetricsCreateInput, EngagementMetricsUncheckedCreateInput>
    /**
     * In case the EngagementMetrics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EngagementMetricsUpdateInput, EngagementMetricsUncheckedUpdateInput>
  }

  /**
   * EngagementMetrics delete
   */
  export type EngagementMetricsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementMetrics
     */
    select?: EngagementMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EngagementMetrics
     */
    omit?: EngagementMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementMetricsInclude<ExtArgs> | null
    /**
     * Filter which EngagementMetrics to delete.
     */
    where: EngagementMetricsWhereUniqueInput
  }

  /**
   * EngagementMetrics deleteMany
   */
  export type EngagementMetricsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EngagementMetrics to delete
     */
    where?: EngagementMetricsWhereInput
    /**
     * Limit how many EngagementMetrics to delete.
     */
    limit?: number
  }

  /**
   * EngagementMetrics without action
   */
  export type EngagementMetricsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementMetrics
     */
    select?: EngagementMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EngagementMetrics
     */
    omit?: EngagementMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementMetricsInclude<ExtArgs> | null
  }


  /**
   * Model Influencer
   */

  export type AggregateInfluencer = {
    _count: InfluencerCountAggregateOutputType | null
    _avg: InfluencerAvgAggregateOutputType | null
    _sum: InfluencerSumAggregateOutputType | null
    _min: InfluencerMinAggregateOutputType | null
    _max: InfluencerMaxAggregateOutputType | null
  }

  export type InfluencerAvgAggregateOutputType = {
    reach: number | null
    engagementRate: number | null
    cost: number | null
  }

  export type InfluencerSumAggregateOutputType = {
    reach: number | null
    engagementRate: number | null
    cost: number | null
  }

  export type InfluencerMinAggregateOutputType = {
    id: string | null
    userId: string | null
    accountId: string | null
    name: string | null
    contactInfo: string | null
    reach: number | null
    engagementRate: number | null
    niche: string | null
    cost: number | null
    status: $Enums.InfluencerStatus | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InfluencerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    accountId: string | null
    name: string | null
    contactInfo: string | null
    reach: number | null
    engagementRate: number | null
    niche: string | null
    cost: number | null
    status: $Enums.InfluencerStatus | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InfluencerCountAggregateOutputType = {
    id: number
    userId: number
    accountId: number
    name: number
    contactInfo: number
    reach: number
    engagementRate: number
    niche: number
    cost: number
    status: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InfluencerAvgAggregateInputType = {
    reach?: true
    engagementRate?: true
    cost?: true
  }

  export type InfluencerSumAggregateInputType = {
    reach?: true
    engagementRate?: true
    cost?: true
  }

  export type InfluencerMinAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    name?: true
    contactInfo?: true
    reach?: true
    engagementRate?: true
    niche?: true
    cost?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InfluencerMaxAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    name?: true
    contactInfo?: true
    reach?: true
    engagementRate?: true
    niche?: true
    cost?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InfluencerCountAggregateInputType = {
    id?: true
    userId?: true
    accountId?: true
    name?: true
    contactInfo?: true
    reach?: true
    engagementRate?: true
    niche?: true
    cost?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InfluencerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Influencer to aggregate.
     */
    where?: InfluencerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Influencers to fetch.
     */
    orderBy?: InfluencerOrderByWithRelationInput | InfluencerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InfluencerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Influencers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Influencers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Influencers
    **/
    _count?: true | InfluencerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InfluencerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InfluencerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InfluencerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InfluencerMaxAggregateInputType
  }

  export type GetInfluencerAggregateType<T extends InfluencerAggregateArgs> = {
        [P in keyof T & keyof AggregateInfluencer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInfluencer[P]>
      : GetScalarType<T[P], AggregateInfluencer[P]>
  }




  export type InfluencerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InfluencerWhereInput
    orderBy?: InfluencerOrderByWithAggregationInput | InfluencerOrderByWithAggregationInput[]
    by: InfluencerScalarFieldEnum[] | InfluencerScalarFieldEnum
    having?: InfluencerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InfluencerCountAggregateInputType | true
    _avg?: InfluencerAvgAggregateInputType
    _sum?: InfluencerSumAggregateInputType
    _min?: InfluencerMinAggregateInputType
    _max?: InfluencerMaxAggregateInputType
  }

  export type InfluencerGroupByOutputType = {
    id: string
    userId: string
    accountId: string
    name: string
    contactInfo: string | null
    reach: number
    engagementRate: number | null
    niche: string | null
    cost: number | null
    status: $Enums.InfluencerStatus
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: InfluencerCountAggregateOutputType | null
    _avg: InfluencerAvgAggregateOutputType | null
    _sum: InfluencerSumAggregateOutputType | null
    _min: InfluencerMinAggregateOutputType | null
    _max: InfluencerMaxAggregateOutputType | null
  }

  type GetInfluencerGroupByPayload<T extends InfluencerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InfluencerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InfluencerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InfluencerGroupByOutputType[P]>
            : GetScalarType<T[P], InfluencerGroupByOutputType[P]>
        }
      >
    >


  export type InfluencerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountId?: boolean
    name?: boolean
    contactInfo?: boolean
    reach?: boolean
    engagementRate?: boolean
    niche?: boolean
    cost?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    account?: boolean | SocialMediaAccountDefaultArgs<ExtArgs>
    campaigns?: boolean | Influencer$campaignsArgs<ExtArgs>
    _count?: boolean | InfluencerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["influencer"]>

  export type InfluencerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountId?: boolean
    name?: boolean
    contactInfo?: boolean
    reach?: boolean
    engagementRate?: boolean
    niche?: boolean
    cost?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    account?: boolean | SocialMediaAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["influencer"]>

  export type InfluencerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountId?: boolean
    name?: boolean
    contactInfo?: boolean
    reach?: boolean
    engagementRate?: boolean
    niche?: boolean
    cost?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    account?: boolean | SocialMediaAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["influencer"]>

  export type InfluencerSelectScalar = {
    id?: boolean
    userId?: boolean
    accountId?: boolean
    name?: boolean
    contactInfo?: boolean
    reach?: boolean
    engagementRate?: boolean
    niche?: boolean
    cost?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InfluencerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "accountId" | "name" | "contactInfo" | "reach" | "engagementRate" | "niche" | "cost" | "status" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["influencer"]>
  export type InfluencerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    account?: boolean | SocialMediaAccountDefaultArgs<ExtArgs>
    campaigns?: boolean | Influencer$campaignsArgs<ExtArgs>
    _count?: boolean | InfluencerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InfluencerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    account?: boolean | SocialMediaAccountDefaultArgs<ExtArgs>
  }
  export type InfluencerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    account?: boolean | SocialMediaAccountDefaultArgs<ExtArgs>
  }

  export type $InfluencerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Influencer"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      account: Prisma.$SocialMediaAccountPayload<ExtArgs>
      campaigns: Prisma.$InfluencerCampaignsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      accountId: string
      name: string
      contactInfo: string | null
      reach: number
      engagementRate: number | null
      niche: string | null
      cost: number | null
      status: $Enums.InfluencerStatus
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["influencer"]>
    composites: {}
  }

  type InfluencerGetPayload<S extends boolean | null | undefined | InfluencerDefaultArgs> = $Result.GetResult<Prisma.$InfluencerPayload, S>

  type InfluencerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InfluencerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InfluencerCountAggregateInputType | true
    }

  export interface InfluencerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Influencer'], meta: { name: 'Influencer' } }
    /**
     * Find zero or one Influencer that matches the filter.
     * @param {InfluencerFindUniqueArgs} args - Arguments to find a Influencer
     * @example
     * // Get one Influencer
     * const influencer = await prisma.influencer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InfluencerFindUniqueArgs>(args: SelectSubset<T, InfluencerFindUniqueArgs<ExtArgs>>): Prisma__InfluencerClient<$Result.GetResult<Prisma.$InfluencerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Influencer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InfluencerFindUniqueOrThrowArgs} args - Arguments to find a Influencer
     * @example
     * // Get one Influencer
     * const influencer = await prisma.influencer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InfluencerFindUniqueOrThrowArgs>(args: SelectSubset<T, InfluencerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InfluencerClient<$Result.GetResult<Prisma.$InfluencerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Influencer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfluencerFindFirstArgs} args - Arguments to find a Influencer
     * @example
     * // Get one Influencer
     * const influencer = await prisma.influencer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InfluencerFindFirstArgs>(args?: SelectSubset<T, InfluencerFindFirstArgs<ExtArgs>>): Prisma__InfluencerClient<$Result.GetResult<Prisma.$InfluencerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Influencer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfluencerFindFirstOrThrowArgs} args - Arguments to find a Influencer
     * @example
     * // Get one Influencer
     * const influencer = await prisma.influencer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InfluencerFindFirstOrThrowArgs>(args?: SelectSubset<T, InfluencerFindFirstOrThrowArgs<ExtArgs>>): Prisma__InfluencerClient<$Result.GetResult<Prisma.$InfluencerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Influencers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfluencerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Influencers
     * const influencers = await prisma.influencer.findMany()
     * 
     * // Get first 10 Influencers
     * const influencers = await prisma.influencer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const influencerWithIdOnly = await prisma.influencer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InfluencerFindManyArgs>(args?: SelectSubset<T, InfluencerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InfluencerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Influencer.
     * @param {InfluencerCreateArgs} args - Arguments to create a Influencer.
     * @example
     * // Create one Influencer
     * const Influencer = await prisma.influencer.create({
     *   data: {
     *     // ... data to create a Influencer
     *   }
     * })
     * 
     */
    create<T extends InfluencerCreateArgs>(args: SelectSubset<T, InfluencerCreateArgs<ExtArgs>>): Prisma__InfluencerClient<$Result.GetResult<Prisma.$InfluencerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Influencers.
     * @param {InfluencerCreateManyArgs} args - Arguments to create many Influencers.
     * @example
     * // Create many Influencers
     * const influencer = await prisma.influencer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InfluencerCreateManyArgs>(args?: SelectSubset<T, InfluencerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Influencers and returns the data saved in the database.
     * @param {InfluencerCreateManyAndReturnArgs} args - Arguments to create many Influencers.
     * @example
     * // Create many Influencers
     * const influencer = await prisma.influencer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Influencers and only return the `id`
     * const influencerWithIdOnly = await prisma.influencer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InfluencerCreateManyAndReturnArgs>(args?: SelectSubset<T, InfluencerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InfluencerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Influencer.
     * @param {InfluencerDeleteArgs} args - Arguments to delete one Influencer.
     * @example
     * // Delete one Influencer
     * const Influencer = await prisma.influencer.delete({
     *   where: {
     *     // ... filter to delete one Influencer
     *   }
     * })
     * 
     */
    delete<T extends InfluencerDeleteArgs>(args: SelectSubset<T, InfluencerDeleteArgs<ExtArgs>>): Prisma__InfluencerClient<$Result.GetResult<Prisma.$InfluencerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Influencer.
     * @param {InfluencerUpdateArgs} args - Arguments to update one Influencer.
     * @example
     * // Update one Influencer
     * const influencer = await prisma.influencer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InfluencerUpdateArgs>(args: SelectSubset<T, InfluencerUpdateArgs<ExtArgs>>): Prisma__InfluencerClient<$Result.GetResult<Prisma.$InfluencerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Influencers.
     * @param {InfluencerDeleteManyArgs} args - Arguments to filter Influencers to delete.
     * @example
     * // Delete a few Influencers
     * const { count } = await prisma.influencer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InfluencerDeleteManyArgs>(args?: SelectSubset<T, InfluencerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Influencers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfluencerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Influencers
     * const influencer = await prisma.influencer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InfluencerUpdateManyArgs>(args: SelectSubset<T, InfluencerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Influencers and returns the data updated in the database.
     * @param {InfluencerUpdateManyAndReturnArgs} args - Arguments to update many Influencers.
     * @example
     * // Update many Influencers
     * const influencer = await prisma.influencer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Influencers and only return the `id`
     * const influencerWithIdOnly = await prisma.influencer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InfluencerUpdateManyAndReturnArgs>(args: SelectSubset<T, InfluencerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InfluencerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Influencer.
     * @param {InfluencerUpsertArgs} args - Arguments to update or create a Influencer.
     * @example
     * // Update or create a Influencer
     * const influencer = await prisma.influencer.upsert({
     *   create: {
     *     // ... data to create a Influencer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Influencer we want to update
     *   }
     * })
     */
    upsert<T extends InfluencerUpsertArgs>(args: SelectSubset<T, InfluencerUpsertArgs<ExtArgs>>): Prisma__InfluencerClient<$Result.GetResult<Prisma.$InfluencerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Influencers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfluencerCountArgs} args - Arguments to filter Influencers to count.
     * @example
     * // Count the number of Influencers
     * const count = await prisma.influencer.count({
     *   where: {
     *     // ... the filter for the Influencers we want to count
     *   }
     * })
    **/
    count<T extends InfluencerCountArgs>(
      args?: Subset<T, InfluencerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InfluencerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Influencer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfluencerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InfluencerAggregateArgs>(args: Subset<T, InfluencerAggregateArgs>): Prisma.PrismaPromise<GetInfluencerAggregateType<T>>

    /**
     * Group by Influencer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfluencerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InfluencerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InfluencerGroupByArgs['orderBy'] }
        : { orderBy?: InfluencerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InfluencerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInfluencerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Influencer model
   */
  readonly fields: InfluencerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Influencer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InfluencerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    account<T extends SocialMediaAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SocialMediaAccountDefaultArgs<ExtArgs>>): Prisma__SocialMediaAccountClient<$Result.GetResult<Prisma.$SocialMediaAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    campaigns<T extends Influencer$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, Influencer$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InfluencerCampaignsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Influencer model
   */
  interface InfluencerFieldRefs {
    readonly id: FieldRef<"Influencer", 'String'>
    readonly userId: FieldRef<"Influencer", 'String'>
    readonly accountId: FieldRef<"Influencer", 'String'>
    readonly name: FieldRef<"Influencer", 'String'>
    readonly contactInfo: FieldRef<"Influencer", 'String'>
    readonly reach: FieldRef<"Influencer", 'Int'>
    readonly engagementRate: FieldRef<"Influencer", 'Float'>
    readonly niche: FieldRef<"Influencer", 'String'>
    readonly cost: FieldRef<"Influencer", 'Float'>
    readonly status: FieldRef<"Influencer", 'InfluencerStatus'>
    readonly notes: FieldRef<"Influencer", 'String'>
    readonly createdAt: FieldRef<"Influencer", 'DateTime'>
    readonly updatedAt: FieldRef<"Influencer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Influencer findUnique
   */
  export type InfluencerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Influencer
     */
    select?: InfluencerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Influencer
     */
    omit?: InfluencerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerInclude<ExtArgs> | null
    /**
     * Filter, which Influencer to fetch.
     */
    where: InfluencerWhereUniqueInput
  }

  /**
   * Influencer findUniqueOrThrow
   */
  export type InfluencerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Influencer
     */
    select?: InfluencerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Influencer
     */
    omit?: InfluencerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerInclude<ExtArgs> | null
    /**
     * Filter, which Influencer to fetch.
     */
    where: InfluencerWhereUniqueInput
  }

  /**
   * Influencer findFirst
   */
  export type InfluencerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Influencer
     */
    select?: InfluencerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Influencer
     */
    omit?: InfluencerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerInclude<ExtArgs> | null
    /**
     * Filter, which Influencer to fetch.
     */
    where?: InfluencerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Influencers to fetch.
     */
    orderBy?: InfluencerOrderByWithRelationInput | InfluencerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Influencers.
     */
    cursor?: InfluencerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Influencers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Influencers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Influencers.
     */
    distinct?: InfluencerScalarFieldEnum | InfluencerScalarFieldEnum[]
  }

  /**
   * Influencer findFirstOrThrow
   */
  export type InfluencerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Influencer
     */
    select?: InfluencerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Influencer
     */
    omit?: InfluencerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerInclude<ExtArgs> | null
    /**
     * Filter, which Influencer to fetch.
     */
    where?: InfluencerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Influencers to fetch.
     */
    orderBy?: InfluencerOrderByWithRelationInput | InfluencerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Influencers.
     */
    cursor?: InfluencerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Influencers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Influencers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Influencers.
     */
    distinct?: InfluencerScalarFieldEnum | InfluencerScalarFieldEnum[]
  }

  /**
   * Influencer findMany
   */
  export type InfluencerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Influencer
     */
    select?: InfluencerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Influencer
     */
    omit?: InfluencerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerInclude<ExtArgs> | null
    /**
     * Filter, which Influencers to fetch.
     */
    where?: InfluencerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Influencers to fetch.
     */
    orderBy?: InfluencerOrderByWithRelationInput | InfluencerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Influencers.
     */
    cursor?: InfluencerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Influencers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Influencers.
     */
    skip?: number
    distinct?: InfluencerScalarFieldEnum | InfluencerScalarFieldEnum[]
  }

  /**
   * Influencer create
   */
  export type InfluencerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Influencer
     */
    select?: InfluencerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Influencer
     */
    omit?: InfluencerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerInclude<ExtArgs> | null
    /**
     * The data needed to create a Influencer.
     */
    data: XOR<InfluencerCreateInput, InfluencerUncheckedCreateInput>
  }

  /**
   * Influencer createMany
   */
  export type InfluencerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Influencers.
     */
    data: InfluencerCreateManyInput | InfluencerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Influencer createManyAndReturn
   */
  export type InfluencerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Influencer
     */
    select?: InfluencerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Influencer
     */
    omit?: InfluencerOmit<ExtArgs> | null
    /**
     * The data used to create many Influencers.
     */
    data: InfluencerCreateManyInput | InfluencerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Influencer update
   */
  export type InfluencerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Influencer
     */
    select?: InfluencerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Influencer
     */
    omit?: InfluencerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerInclude<ExtArgs> | null
    /**
     * The data needed to update a Influencer.
     */
    data: XOR<InfluencerUpdateInput, InfluencerUncheckedUpdateInput>
    /**
     * Choose, which Influencer to update.
     */
    where: InfluencerWhereUniqueInput
  }

  /**
   * Influencer updateMany
   */
  export type InfluencerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Influencers.
     */
    data: XOR<InfluencerUpdateManyMutationInput, InfluencerUncheckedUpdateManyInput>
    /**
     * Filter which Influencers to update
     */
    where?: InfluencerWhereInput
    /**
     * Limit how many Influencers to update.
     */
    limit?: number
  }

  /**
   * Influencer updateManyAndReturn
   */
  export type InfluencerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Influencer
     */
    select?: InfluencerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Influencer
     */
    omit?: InfluencerOmit<ExtArgs> | null
    /**
     * The data used to update Influencers.
     */
    data: XOR<InfluencerUpdateManyMutationInput, InfluencerUncheckedUpdateManyInput>
    /**
     * Filter which Influencers to update
     */
    where?: InfluencerWhereInput
    /**
     * Limit how many Influencers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Influencer upsert
   */
  export type InfluencerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Influencer
     */
    select?: InfluencerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Influencer
     */
    omit?: InfluencerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerInclude<ExtArgs> | null
    /**
     * The filter to search for the Influencer to update in case it exists.
     */
    where: InfluencerWhereUniqueInput
    /**
     * In case the Influencer found by the `where` argument doesn't exist, create a new Influencer with this data.
     */
    create: XOR<InfluencerCreateInput, InfluencerUncheckedCreateInput>
    /**
     * In case the Influencer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InfluencerUpdateInput, InfluencerUncheckedUpdateInput>
  }

  /**
   * Influencer delete
   */
  export type InfluencerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Influencer
     */
    select?: InfluencerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Influencer
     */
    omit?: InfluencerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerInclude<ExtArgs> | null
    /**
     * Filter which Influencer to delete.
     */
    where: InfluencerWhereUniqueInput
  }

  /**
   * Influencer deleteMany
   */
  export type InfluencerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Influencers to delete
     */
    where?: InfluencerWhereInput
    /**
     * Limit how many Influencers to delete.
     */
    limit?: number
  }

  /**
   * Influencer.campaigns
   */
  export type Influencer$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfluencerCampaigns
     */
    select?: InfluencerCampaignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InfluencerCampaigns
     */
    omit?: InfluencerCampaignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerCampaignsInclude<ExtArgs> | null
    where?: InfluencerCampaignsWhereInput
    orderBy?: InfluencerCampaignsOrderByWithRelationInput | InfluencerCampaignsOrderByWithRelationInput[]
    cursor?: InfluencerCampaignsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InfluencerCampaignsScalarFieldEnum | InfluencerCampaignsScalarFieldEnum[]
  }

  /**
   * Influencer without action
   */
  export type InfluencerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Influencer
     */
    select?: InfluencerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Influencer
     */
    omit?: InfluencerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerInclude<ExtArgs> | null
  }


  /**
   * Model InfluencerCampaigns
   */

  export type AggregateInfluencerCampaigns = {
    _count: InfluencerCampaignsCountAggregateOutputType | null
    _avg: InfluencerCampaignsAvgAggregateOutputType | null
    _sum: InfluencerCampaignsSumAggregateOutputType | null
    _min: InfluencerCampaignsMinAggregateOutputType | null
    _max: InfluencerCampaignsMaxAggregateOutputType | null
  }

  export type InfluencerCampaignsAvgAggregateOutputType = {
    budget: number | null
  }

  export type InfluencerCampaignsSumAggregateOutputType = {
    budget: number | null
  }

  export type InfluencerCampaignsMinAggregateOutputType = {
    id: string | null
    influencerId: string | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    budget: number | null
    status: $Enums.InfluencerCampaignStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InfluencerCampaignsMaxAggregateOutputType = {
    id: string | null
    influencerId: string | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    budget: number | null
    status: $Enums.InfluencerCampaignStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InfluencerCampaignsCountAggregateOutputType = {
    id: number
    influencerId: number
    name: number
    startDate: number
    endDate: number
    budget: number
    results: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InfluencerCampaignsAvgAggregateInputType = {
    budget?: true
  }

  export type InfluencerCampaignsSumAggregateInputType = {
    budget?: true
  }

  export type InfluencerCampaignsMinAggregateInputType = {
    id?: true
    influencerId?: true
    name?: true
    startDate?: true
    endDate?: true
    budget?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InfluencerCampaignsMaxAggregateInputType = {
    id?: true
    influencerId?: true
    name?: true
    startDate?: true
    endDate?: true
    budget?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InfluencerCampaignsCountAggregateInputType = {
    id?: true
    influencerId?: true
    name?: true
    startDate?: true
    endDate?: true
    budget?: true
    results?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InfluencerCampaignsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InfluencerCampaigns to aggregate.
     */
    where?: InfluencerCampaignsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InfluencerCampaigns to fetch.
     */
    orderBy?: InfluencerCampaignsOrderByWithRelationInput | InfluencerCampaignsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InfluencerCampaignsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InfluencerCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InfluencerCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InfluencerCampaigns
    **/
    _count?: true | InfluencerCampaignsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InfluencerCampaignsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InfluencerCampaignsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InfluencerCampaignsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InfluencerCampaignsMaxAggregateInputType
  }

  export type GetInfluencerCampaignsAggregateType<T extends InfluencerCampaignsAggregateArgs> = {
        [P in keyof T & keyof AggregateInfluencerCampaigns]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInfluencerCampaigns[P]>
      : GetScalarType<T[P], AggregateInfluencerCampaigns[P]>
  }




  export type InfluencerCampaignsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InfluencerCampaignsWhereInput
    orderBy?: InfluencerCampaignsOrderByWithAggregationInput | InfluencerCampaignsOrderByWithAggregationInput[]
    by: InfluencerCampaignsScalarFieldEnum[] | InfluencerCampaignsScalarFieldEnum
    having?: InfluencerCampaignsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InfluencerCampaignsCountAggregateInputType | true
    _avg?: InfluencerCampaignsAvgAggregateInputType
    _sum?: InfluencerCampaignsSumAggregateInputType
    _min?: InfluencerCampaignsMinAggregateInputType
    _max?: InfluencerCampaignsMaxAggregateInputType
  }

  export type InfluencerCampaignsGroupByOutputType = {
    id: string
    influencerId: string
    name: string
    startDate: Date
    endDate: Date | null
    budget: number
    results: JsonValue | null
    status: $Enums.InfluencerCampaignStatus
    createdAt: Date
    updatedAt: Date
    _count: InfluencerCampaignsCountAggregateOutputType | null
    _avg: InfluencerCampaignsAvgAggregateOutputType | null
    _sum: InfluencerCampaignsSumAggregateOutputType | null
    _min: InfluencerCampaignsMinAggregateOutputType | null
    _max: InfluencerCampaignsMaxAggregateOutputType | null
  }

  type GetInfluencerCampaignsGroupByPayload<T extends InfluencerCampaignsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InfluencerCampaignsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InfluencerCampaignsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InfluencerCampaignsGroupByOutputType[P]>
            : GetScalarType<T[P], InfluencerCampaignsGroupByOutputType[P]>
        }
      >
    >


  export type InfluencerCampaignsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    influencerId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    budget?: boolean
    results?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    influencer?: boolean | InfluencerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["influencerCampaigns"]>

  export type InfluencerCampaignsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    influencerId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    budget?: boolean
    results?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    influencer?: boolean | InfluencerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["influencerCampaigns"]>

  export type InfluencerCampaignsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    influencerId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    budget?: boolean
    results?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    influencer?: boolean | InfluencerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["influencerCampaigns"]>

  export type InfluencerCampaignsSelectScalar = {
    id?: boolean
    influencerId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    budget?: boolean
    results?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InfluencerCampaignsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "influencerId" | "name" | "startDate" | "endDate" | "budget" | "results" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["influencerCampaigns"]>
  export type InfluencerCampaignsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    influencer?: boolean | InfluencerDefaultArgs<ExtArgs>
  }
  export type InfluencerCampaignsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    influencer?: boolean | InfluencerDefaultArgs<ExtArgs>
  }
  export type InfluencerCampaignsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    influencer?: boolean | InfluencerDefaultArgs<ExtArgs>
  }

  export type $InfluencerCampaignsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InfluencerCampaigns"
    objects: {
      influencer: Prisma.$InfluencerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      influencerId: string
      name: string
      startDate: Date
      endDate: Date | null
      budget: number
      results: Prisma.JsonValue | null
      status: $Enums.InfluencerCampaignStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["influencerCampaigns"]>
    composites: {}
  }

  type InfluencerCampaignsGetPayload<S extends boolean | null | undefined | InfluencerCampaignsDefaultArgs> = $Result.GetResult<Prisma.$InfluencerCampaignsPayload, S>

  type InfluencerCampaignsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InfluencerCampaignsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InfluencerCampaignsCountAggregateInputType | true
    }

  export interface InfluencerCampaignsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InfluencerCampaigns'], meta: { name: 'InfluencerCampaigns' } }
    /**
     * Find zero or one InfluencerCampaigns that matches the filter.
     * @param {InfluencerCampaignsFindUniqueArgs} args - Arguments to find a InfluencerCampaigns
     * @example
     * // Get one InfluencerCampaigns
     * const influencerCampaigns = await prisma.influencerCampaigns.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InfluencerCampaignsFindUniqueArgs>(args: SelectSubset<T, InfluencerCampaignsFindUniqueArgs<ExtArgs>>): Prisma__InfluencerCampaignsClient<$Result.GetResult<Prisma.$InfluencerCampaignsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InfluencerCampaigns that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InfluencerCampaignsFindUniqueOrThrowArgs} args - Arguments to find a InfluencerCampaigns
     * @example
     * // Get one InfluencerCampaigns
     * const influencerCampaigns = await prisma.influencerCampaigns.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InfluencerCampaignsFindUniqueOrThrowArgs>(args: SelectSubset<T, InfluencerCampaignsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InfluencerCampaignsClient<$Result.GetResult<Prisma.$InfluencerCampaignsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InfluencerCampaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfluencerCampaignsFindFirstArgs} args - Arguments to find a InfluencerCampaigns
     * @example
     * // Get one InfluencerCampaigns
     * const influencerCampaigns = await prisma.influencerCampaigns.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InfluencerCampaignsFindFirstArgs>(args?: SelectSubset<T, InfluencerCampaignsFindFirstArgs<ExtArgs>>): Prisma__InfluencerCampaignsClient<$Result.GetResult<Prisma.$InfluencerCampaignsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InfluencerCampaigns that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfluencerCampaignsFindFirstOrThrowArgs} args - Arguments to find a InfluencerCampaigns
     * @example
     * // Get one InfluencerCampaigns
     * const influencerCampaigns = await prisma.influencerCampaigns.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InfluencerCampaignsFindFirstOrThrowArgs>(args?: SelectSubset<T, InfluencerCampaignsFindFirstOrThrowArgs<ExtArgs>>): Prisma__InfluencerCampaignsClient<$Result.GetResult<Prisma.$InfluencerCampaignsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InfluencerCampaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfluencerCampaignsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InfluencerCampaigns
     * const influencerCampaigns = await prisma.influencerCampaigns.findMany()
     * 
     * // Get first 10 InfluencerCampaigns
     * const influencerCampaigns = await prisma.influencerCampaigns.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const influencerCampaignsWithIdOnly = await prisma.influencerCampaigns.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InfluencerCampaignsFindManyArgs>(args?: SelectSubset<T, InfluencerCampaignsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InfluencerCampaignsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InfluencerCampaigns.
     * @param {InfluencerCampaignsCreateArgs} args - Arguments to create a InfluencerCampaigns.
     * @example
     * // Create one InfluencerCampaigns
     * const InfluencerCampaigns = await prisma.influencerCampaigns.create({
     *   data: {
     *     // ... data to create a InfluencerCampaigns
     *   }
     * })
     * 
     */
    create<T extends InfluencerCampaignsCreateArgs>(args: SelectSubset<T, InfluencerCampaignsCreateArgs<ExtArgs>>): Prisma__InfluencerCampaignsClient<$Result.GetResult<Prisma.$InfluencerCampaignsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InfluencerCampaigns.
     * @param {InfluencerCampaignsCreateManyArgs} args - Arguments to create many InfluencerCampaigns.
     * @example
     * // Create many InfluencerCampaigns
     * const influencerCampaigns = await prisma.influencerCampaigns.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InfluencerCampaignsCreateManyArgs>(args?: SelectSubset<T, InfluencerCampaignsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InfluencerCampaigns and returns the data saved in the database.
     * @param {InfluencerCampaignsCreateManyAndReturnArgs} args - Arguments to create many InfluencerCampaigns.
     * @example
     * // Create many InfluencerCampaigns
     * const influencerCampaigns = await prisma.influencerCampaigns.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InfluencerCampaigns and only return the `id`
     * const influencerCampaignsWithIdOnly = await prisma.influencerCampaigns.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InfluencerCampaignsCreateManyAndReturnArgs>(args?: SelectSubset<T, InfluencerCampaignsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InfluencerCampaignsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InfluencerCampaigns.
     * @param {InfluencerCampaignsDeleteArgs} args - Arguments to delete one InfluencerCampaigns.
     * @example
     * // Delete one InfluencerCampaigns
     * const InfluencerCampaigns = await prisma.influencerCampaigns.delete({
     *   where: {
     *     // ... filter to delete one InfluencerCampaigns
     *   }
     * })
     * 
     */
    delete<T extends InfluencerCampaignsDeleteArgs>(args: SelectSubset<T, InfluencerCampaignsDeleteArgs<ExtArgs>>): Prisma__InfluencerCampaignsClient<$Result.GetResult<Prisma.$InfluencerCampaignsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InfluencerCampaigns.
     * @param {InfluencerCampaignsUpdateArgs} args - Arguments to update one InfluencerCampaigns.
     * @example
     * // Update one InfluencerCampaigns
     * const influencerCampaigns = await prisma.influencerCampaigns.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InfluencerCampaignsUpdateArgs>(args: SelectSubset<T, InfluencerCampaignsUpdateArgs<ExtArgs>>): Prisma__InfluencerCampaignsClient<$Result.GetResult<Prisma.$InfluencerCampaignsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InfluencerCampaigns.
     * @param {InfluencerCampaignsDeleteManyArgs} args - Arguments to filter InfluencerCampaigns to delete.
     * @example
     * // Delete a few InfluencerCampaigns
     * const { count } = await prisma.influencerCampaigns.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InfluencerCampaignsDeleteManyArgs>(args?: SelectSubset<T, InfluencerCampaignsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InfluencerCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfluencerCampaignsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InfluencerCampaigns
     * const influencerCampaigns = await prisma.influencerCampaigns.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InfluencerCampaignsUpdateManyArgs>(args: SelectSubset<T, InfluencerCampaignsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InfluencerCampaigns and returns the data updated in the database.
     * @param {InfluencerCampaignsUpdateManyAndReturnArgs} args - Arguments to update many InfluencerCampaigns.
     * @example
     * // Update many InfluencerCampaigns
     * const influencerCampaigns = await prisma.influencerCampaigns.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InfluencerCampaigns and only return the `id`
     * const influencerCampaignsWithIdOnly = await prisma.influencerCampaigns.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InfluencerCampaignsUpdateManyAndReturnArgs>(args: SelectSubset<T, InfluencerCampaignsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InfluencerCampaignsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InfluencerCampaigns.
     * @param {InfluencerCampaignsUpsertArgs} args - Arguments to update or create a InfluencerCampaigns.
     * @example
     * // Update or create a InfluencerCampaigns
     * const influencerCampaigns = await prisma.influencerCampaigns.upsert({
     *   create: {
     *     // ... data to create a InfluencerCampaigns
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InfluencerCampaigns we want to update
     *   }
     * })
     */
    upsert<T extends InfluencerCampaignsUpsertArgs>(args: SelectSubset<T, InfluencerCampaignsUpsertArgs<ExtArgs>>): Prisma__InfluencerCampaignsClient<$Result.GetResult<Prisma.$InfluencerCampaignsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InfluencerCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfluencerCampaignsCountArgs} args - Arguments to filter InfluencerCampaigns to count.
     * @example
     * // Count the number of InfluencerCampaigns
     * const count = await prisma.influencerCampaigns.count({
     *   where: {
     *     // ... the filter for the InfluencerCampaigns we want to count
     *   }
     * })
    **/
    count<T extends InfluencerCampaignsCountArgs>(
      args?: Subset<T, InfluencerCampaignsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InfluencerCampaignsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InfluencerCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfluencerCampaignsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InfluencerCampaignsAggregateArgs>(args: Subset<T, InfluencerCampaignsAggregateArgs>): Prisma.PrismaPromise<GetInfluencerCampaignsAggregateType<T>>

    /**
     * Group by InfluencerCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfluencerCampaignsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InfluencerCampaignsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InfluencerCampaignsGroupByArgs['orderBy'] }
        : { orderBy?: InfluencerCampaignsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InfluencerCampaignsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInfluencerCampaignsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InfluencerCampaigns model
   */
  readonly fields: InfluencerCampaignsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InfluencerCampaigns.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InfluencerCampaignsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    influencer<T extends InfluencerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InfluencerDefaultArgs<ExtArgs>>): Prisma__InfluencerClient<$Result.GetResult<Prisma.$InfluencerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InfluencerCampaigns model
   */
  interface InfluencerCampaignsFieldRefs {
    readonly id: FieldRef<"InfluencerCampaigns", 'String'>
    readonly influencerId: FieldRef<"InfluencerCampaigns", 'String'>
    readonly name: FieldRef<"InfluencerCampaigns", 'String'>
    readonly startDate: FieldRef<"InfluencerCampaigns", 'DateTime'>
    readonly endDate: FieldRef<"InfluencerCampaigns", 'DateTime'>
    readonly budget: FieldRef<"InfluencerCampaigns", 'Float'>
    readonly results: FieldRef<"InfluencerCampaigns", 'Json'>
    readonly status: FieldRef<"InfluencerCampaigns", 'InfluencerCampaignStatus'>
    readonly createdAt: FieldRef<"InfluencerCampaigns", 'DateTime'>
    readonly updatedAt: FieldRef<"InfluencerCampaigns", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InfluencerCampaigns findUnique
   */
  export type InfluencerCampaignsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfluencerCampaigns
     */
    select?: InfluencerCampaignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InfluencerCampaigns
     */
    omit?: InfluencerCampaignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerCampaignsInclude<ExtArgs> | null
    /**
     * Filter, which InfluencerCampaigns to fetch.
     */
    where: InfluencerCampaignsWhereUniqueInput
  }

  /**
   * InfluencerCampaigns findUniqueOrThrow
   */
  export type InfluencerCampaignsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfluencerCampaigns
     */
    select?: InfluencerCampaignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InfluencerCampaigns
     */
    omit?: InfluencerCampaignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerCampaignsInclude<ExtArgs> | null
    /**
     * Filter, which InfluencerCampaigns to fetch.
     */
    where: InfluencerCampaignsWhereUniqueInput
  }

  /**
   * InfluencerCampaigns findFirst
   */
  export type InfluencerCampaignsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfluencerCampaigns
     */
    select?: InfluencerCampaignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InfluencerCampaigns
     */
    omit?: InfluencerCampaignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerCampaignsInclude<ExtArgs> | null
    /**
     * Filter, which InfluencerCampaigns to fetch.
     */
    where?: InfluencerCampaignsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InfluencerCampaigns to fetch.
     */
    orderBy?: InfluencerCampaignsOrderByWithRelationInput | InfluencerCampaignsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InfluencerCampaigns.
     */
    cursor?: InfluencerCampaignsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InfluencerCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InfluencerCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InfluencerCampaigns.
     */
    distinct?: InfluencerCampaignsScalarFieldEnum | InfluencerCampaignsScalarFieldEnum[]
  }

  /**
   * InfluencerCampaigns findFirstOrThrow
   */
  export type InfluencerCampaignsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfluencerCampaigns
     */
    select?: InfluencerCampaignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InfluencerCampaigns
     */
    omit?: InfluencerCampaignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerCampaignsInclude<ExtArgs> | null
    /**
     * Filter, which InfluencerCampaigns to fetch.
     */
    where?: InfluencerCampaignsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InfluencerCampaigns to fetch.
     */
    orderBy?: InfluencerCampaignsOrderByWithRelationInput | InfluencerCampaignsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InfluencerCampaigns.
     */
    cursor?: InfluencerCampaignsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InfluencerCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InfluencerCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InfluencerCampaigns.
     */
    distinct?: InfluencerCampaignsScalarFieldEnum | InfluencerCampaignsScalarFieldEnum[]
  }

  /**
   * InfluencerCampaigns findMany
   */
  export type InfluencerCampaignsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfluencerCampaigns
     */
    select?: InfluencerCampaignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InfluencerCampaigns
     */
    omit?: InfluencerCampaignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerCampaignsInclude<ExtArgs> | null
    /**
     * Filter, which InfluencerCampaigns to fetch.
     */
    where?: InfluencerCampaignsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InfluencerCampaigns to fetch.
     */
    orderBy?: InfluencerCampaignsOrderByWithRelationInput | InfluencerCampaignsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InfluencerCampaigns.
     */
    cursor?: InfluencerCampaignsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InfluencerCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InfluencerCampaigns.
     */
    skip?: number
    distinct?: InfluencerCampaignsScalarFieldEnum | InfluencerCampaignsScalarFieldEnum[]
  }

  /**
   * InfluencerCampaigns create
   */
  export type InfluencerCampaignsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfluencerCampaigns
     */
    select?: InfluencerCampaignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InfluencerCampaigns
     */
    omit?: InfluencerCampaignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerCampaignsInclude<ExtArgs> | null
    /**
     * The data needed to create a InfluencerCampaigns.
     */
    data: XOR<InfluencerCampaignsCreateInput, InfluencerCampaignsUncheckedCreateInput>
  }

  /**
   * InfluencerCampaigns createMany
   */
  export type InfluencerCampaignsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InfluencerCampaigns.
     */
    data: InfluencerCampaignsCreateManyInput | InfluencerCampaignsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InfluencerCampaigns createManyAndReturn
   */
  export type InfluencerCampaignsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfluencerCampaigns
     */
    select?: InfluencerCampaignsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InfluencerCampaigns
     */
    omit?: InfluencerCampaignsOmit<ExtArgs> | null
    /**
     * The data used to create many InfluencerCampaigns.
     */
    data: InfluencerCampaignsCreateManyInput | InfluencerCampaignsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerCampaignsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InfluencerCampaigns update
   */
  export type InfluencerCampaignsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfluencerCampaigns
     */
    select?: InfluencerCampaignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InfluencerCampaigns
     */
    omit?: InfluencerCampaignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerCampaignsInclude<ExtArgs> | null
    /**
     * The data needed to update a InfluencerCampaigns.
     */
    data: XOR<InfluencerCampaignsUpdateInput, InfluencerCampaignsUncheckedUpdateInput>
    /**
     * Choose, which InfluencerCampaigns to update.
     */
    where: InfluencerCampaignsWhereUniqueInput
  }

  /**
   * InfluencerCampaigns updateMany
   */
  export type InfluencerCampaignsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InfluencerCampaigns.
     */
    data: XOR<InfluencerCampaignsUpdateManyMutationInput, InfluencerCampaignsUncheckedUpdateManyInput>
    /**
     * Filter which InfluencerCampaigns to update
     */
    where?: InfluencerCampaignsWhereInput
    /**
     * Limit how many InfluencerCampaigns to update.
     */
    limit?: number
  }

  /**
   * InfluencerCampaigns updateManyAndReturn
   */
  export type InfluencerCampaignsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfluencerCampaigns
     */
    select?: InfluencerCampaignsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InfluencerCampaigns
     */
    omit?: InfluencerCampaignsOmit<ExtArgs> | null
    /**
     * The data used to update InfluencerCampaigns.
     */
    data: XOR<InfluencerCampaignsUpdateManyMutationInput, InfluencerCampaignsUncheckedUpdateManyInput>
    /**
     * Filter which InfluencerCampaigns to update
     */
    where?: InfluencerCampaignsWhereInput
    /**
     * Limit how many InfluencerCampaigns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerCampaignsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InfluencerCampaigns upsert
   */
  export type InfluencerCampaignsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfluencerCampaigns
     */
    select?: InfluencerCampaignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InfluencerCampaigns
     */
    omit?: InfluencerCampaignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerCampaignsInclude<ExtArgs> | null
    /**
     * The filter to search for the InfluencerCampaigns to update in case it exists.
     */
    where: InfluencerCampaignsWhereUniqueInput
    /**
     * In case the InfluencerCampaigns found by the `where` argument doesn't exist, create a new InfluencerCampaigns with this data.
     */
    create: XOR<InfluencerCampaignsCreateInput, InfluencerCampaignsUncheckedCreateInput>
    /**
     * In case the InfluencerCampaigns was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InfluencerCampaignsUpdateInput, InfluencerCampaignsUncheckedUpdateInput>
  }

  /**
   * InfluencerCampaigns delete
   */
  export type InfluencerCampaignsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfluencerCampaigns
     */
    select?: InfluencerCampaignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InfluencerCampaigns
     */
    omit?: InfluencerCampaignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerCampaignsInclude<ExtArgs> | null
    /**
     * Filter which InfluencerCampaigns to delete.
     */
    where: InfluencerCampaignsWhereUniqueInput
  }

  /**
   * InfluencerCampaigns deleteMany
   */
  export type InfluencerCampaignsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InfluencerCampaigns to delete
     */
    where?: InfluencerCampaignsWhereInput
    /**
     * Limit how many InfluencerCampaigns to delete.
     */
    limit?: number
  }

  /**
   * InfluencerCampaigns without action
   */
  export type InfluencerCampaignsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InfluencerCampaigns
     */
    select?: InfluencerCampaignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InfluencerCampaigns
     */
    omit?: InfluencerCampaignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfluencerCampaignsInclude<ExtArgs> | null
  }


  /**
   * Model Clinic
   */

  export type AggregateClinic = {
    _count: ClinicCountAggregateOutputType | null
    _avg: ClinicAvgAggregateOutputType | null
    _sum: ClinicSumAggregateOutputType | null
    _min: ClinicMinAggregateOutputType | null
    _max: ClinicMaxAggregateOutputType | null
  }

  export type ClinicAvgAggregateOutputType = {
    rating: number | null
    reviewCount: number | null
  }

  export type ClinicSumAggregateOutputType = {
    rating: number | null
    reviewCount: number | null
  }

  export type ClinicMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    address: string | null
    city: string | null
    phone: string | null
    email: string | null
    website: string | null
    description: string | null
    featured: boolean | null
    logoUrl: string | null
    rating: number | null
    reviewCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClinicMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    address: string | null
    city: string | null
    phone: string | null
    email: string | null
    website: string | null
    description: string | null
    featured: boolean | null
    logoUrl: string | null
    rating: number | null
    reviewCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClinicCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    address: number
    city: number
    phone: number
    email: number
    website: number
    description: number
    featured: number
    logoUrl: number
    rating: number
    reviewCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClinicAvgAggregateInputType = {
    rating?: true
    reviewCount?: true
  }

  export type ClinicSumAggregateInputType = {
    rating?: true
    reviewCount?: true
  }

  export type ClinicMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    address?: true
    city?: true
    phone?: true
    email?: true
    website?: true
    description?: true
    featured?: true
    logoUrl?: true
    rating?: true
    reviewCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClinicMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    address?: true
    city?: true
    phone?: true
    email?: true
    website?: true
    description?: true
    featured?: true
    logoUrl?: true
    rating?: true
    reviewCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClinicCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    address?: true
    city?: true
    phone?: true
    email?: true
    website?: true
    description?: true
    featured?: true
    logoUrl?: true
    rating?: true
    reviewCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClinicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clinic to aggregate.
     */
    where?: ClinicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clinics to fetch.
     */
    orderBy?: ClinicOrderByWithRelationInput | ClinicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClinicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clinics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clinics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clinics
    **/
    _count?: true | ClinicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClinicAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClinicSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClinicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClinicMaxAggregateInputType
  }

  export type GetClinicAggregateType<T extends ClinicAggregateArgs> = {
        [P in keyof T & keyof AggregateClinic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClinic[P]>
      : GetScalarType<T[P], AggregateClinic[P]>
  }




  export type ClinicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicWhereInput
    orderBy?: ClinicOrderByWithAggregationInput | ClinicOrderByWithAggregationInput[]
    by: ClinicScalarFieldEnum[] | ClinicScalarFieldEnum
    having?: ClinicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClinicCountAggregateInputType | true
    _avg?: ClinicAvgAggregateInputType
    _sum?: ClinicSumAggregateInputType
    _min?: ClinicMinAggregateInputType
    _max?: ClinicMaxAggregateInputType
  }

  export type ClinicGroupByOutputType = {
    id: string
    userId: string
    name: string
    address: string | null
    city: string | null
    phone: string | null
    email: string | null
    website: string | null
    description: string | null
    featured: boolean
    logoUrl: string | null
    rating: number | null
    reviewCount: number
    createdAt: Date
    updatedAt: Date
    _count: ClinicCountAggregateOutputType | null
    _avg: ClinicAvgAggregateOutputType | null
    _sum: ClinicSumAggregateOutputType | null
    _min: ClinicMinAggregateOutputType | null
    _max: ClinicMaxAggregateOutputType | null
  }

  type GetClinicGroupByPayload<T extends ClinicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClinicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClinicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClinicGroupByOutputType[P]>
            : GetScalarType<T[P], ClinicGroupByOutputType[P]>
        }
      >
    >


  export type ClinicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    description?: boolean
    featured?: boolean
    logoUrl?: boolean
    rating?: boolean
    reviewCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    schedules?: boolean | Clinic$schedulesArgs<ExtArgs>
    campaigns?: boolean | Clinic$campaignsArgs<ExtArgs>
    _count?: boolean | ClinicCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinic"]>

  export type ClinicSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    description?: boolean
    featured?: boolean
    logoUrl?: boolean
    rating?: boolean
    reviewCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinic"]>

  export type ClinicSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    description?: boolean
    featured?: boolean
    logoUrl?: boolean
    rating?: boolean
    reviewCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinic"]>

  export type ClinicSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    address?: boolean
    city?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    description?: boolean
    featured?: boolean
    logoUrl?: boolean
    rating?: boolean
    reviewCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClinicOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "address" | "city" | "phone" | "email" | "website" | "description" | "featured" | "logoUrl" | "rating" | "reviewCount" | "createdAt" | "updatedAt", ExtArgs["result"]["clinic"]>
  export type ClinicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    schedules?: boolean | Clinic$schedulesArgs<ExtArgs>
    campaigns?: boolean | Clinic$campaignsArgs<ExtArgs>
    _count?: boolean | ClinicCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClinicIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClinicIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClinicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Clinic"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      schedules: Prisma.$SchedulePayload<ExtArgs>[]
      campaigns: Prisma.$CampaignPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      address: string | null
      city: string | null
      phone: string | null
      email: string | null
      website: string | null
      description: string | null
      featured: boolean
      logoUrl: string | null
      rating: number | null
      reviewCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clinic"]>
    composites: {}
  }

  type ClinicGetPayload<S extends boolean | null | undefined | ClinicDefaultArgs> = $Result.GetResult<Prisma.$ClinicPayload, S>

  type ClinicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClinicFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClinicCountAggregateInputType | true
    }

  export interface ClinicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Clinic'], meta: { name: 'Clinic' } }
    /**
     * Find zero or one Clinic that matches the filter.
     * @param {ClinicFindUniqueArgs} args - Arguments to find a Clinic
     * @example
     * // Get one Clinic
     * const clinic = await prisma.clinic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClinicFindUniqueArgs>(args: SelectSubset<T, ClinicFindUniqueArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Clinic that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClinicFindUniqueOrThrowArgs} args - Arguments to find a Clinic
     * @example
     * // Get one Clinic
     * const clinic = await prisma.clinic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClinicFindUniqueOrThrowArgs>(args: SelectSubset<T, ClinicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Clinic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicFindFirstArgs} args - Arguments to find a Clinic
     * @example
     * // Get one Clinic
     * const clinic = await prisma.clinic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClinicFindFirstArgs>(args?: SelectSubset<T, ClinicFindFirstArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Clinic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicFindFirstOrThrowArgs} args - Arguments to find a Clinic
     * @example
     * // Get one Clinic
     * const clinic = await prisma.clinic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClinicFindFirstOrThrowArgs>(args?: SelectSubset<T, ClinicFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clinics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clinics
     * const clinics = await prisma.clinic.findMany()
     * 
     * // Get first 10 Clinics
     * const clinics = await prisma.clinic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clinicWithIdOnly = await prisma.clinic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClinicFindManyArgs>(args?: SelectSubset<T, ClinicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Clinic.
     * @param {ClinicCreateArgs} args - Arguments to create a Clinic.
     * @example
     * // Create one Clinic
     * const Clinic = await prisma.clinic.create({
     *   data: {
     *     // ... data to create a Clinic
     *   }
     * })
     * 
     */
    create<T extends ClinicCreateArgs>(args: SelectSubset<T, ClinicCreateArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clinics.
     * @param {ClinicCreateManyArgs} args - Arguments to create many Clinics.
     * @example
     * // Create many Clinics
     * const clinic = await prisma.clinic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClinicCreateManyArgs>(args?: SelectSubset<T, ClinicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clinics and returns the data saved in the database.
     * @param {ClinicCreateManyAndReturnArgs} args - Arguments to create many Clinics.
     * @example
     * // Create many Clinics
     * const clinic = await prisma.clinic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clinics and only return the `id`
     * const clinicWithIdOnly = await prisma.clinic.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClinicCreateManyAndReturnArgs>(args?: SelectSubset<T, ClinicCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Clinic.
     * @param {ClinicDeleteArgs} args - Arguments to delete one Clinic.
     * @example
     * // Delete one Clinic
     * const Clinic = await prisma.clinic.delete({
     *   where: {
     *     // ... filter to delete one Clinic
     *   }
     * })
     * 
     */
    delete<T extends ClinicDeleteArgs>(args: SelectSubset<T, ClinicDeleteArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Clinic.
     * @param {ClinicUpdateArgs} args - Arguments to update one Clinic.
     * @example
     * // Update one Clinic
     * const clinic = await prisma.clinic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClinicUpdateArgs>(args: SelectSubset<T, ClinicUpdateArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clinics.
     * @param {ClinicDeleteManyArgs} args - Arguments to filter Clinics to delete.
     * @example
     * // Delete a few Clinics
     * const { count } = await prisma.clinic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClinicDeleteManyArgs>(args?: SelectSubset<T, ClinicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clinics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clinics
     * const clinic = await prisma.clinic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClinicUpdateManyArgs>(args: SelectSubset<T, ClinicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clinics and returns the data updated in the database.
     * @param {ClinicUpdateManyAndReturnArgs} args - Arguments to update many Clinics.
     * @example
     * // Update many Clinics
     * const clinic = await prisma.clinic.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clinics and only return the `id`
     * const clinicWithIdOnly = await prisma.clinic.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClinicUpdateManyAndReturnArgs>(args: SelectSubset<T, ClinicUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Clinic.
     * @param {ClinicUpsertArgs} args - Arguments to update or create a Clinic.
     * @example
     * // Update or create a Clinic
     * const clinic = await prisma.clinic.upsert({
     *   create: {
     *     // ... data to create a Clinic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clinic we want to update
     *   }
     * })
     */
    upsert<T extends ClinicUpsertArgs>(args: SelectSubset<T, ClinicUpsertArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clinics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicCountArgs} args - Arguments to filter Clinics to count.
     * @example
     * // Count the number of Clinics
     * const count = await prisma.clinic.count({
     *   where: {
     *     // ... the filter for the Clinics we want to count
     *   }
     * })
    **/
    count<T extends ClinicCountArgs>(
      args?: Subset<T, ClinicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClinicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clinic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClinicAggregateArgs>(args: Subset<T, ClinicAggregateArgs>): Prisma.PrismaPromise<GetClinicAggregateType<T>>

    /**
     * Group by Clinic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClinicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClinicGroupByArgs['orderBy'] }
        : { orderBy?: ClinicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClinicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClinicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Clinic model
   */
  readonly fields: ClinicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Clinic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClinicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    schedules<T extends Clinic$schedulesArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$schedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    campaigns<T extends Clinic$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Clinic model
   */
  interface ClinicFieldRefs {
    readonly id: FieldRef<"Clinic", 'String'>
    readonly userId: FieldRef<"Clinic", 'String'>
    readonly name: FieldRef<"Clinic", 'String'>
    readonly address: FieldRef<"Clinic", 'String'>
    readonly city: FieldRef<"Clinic", 'String'>
    readonly phone: FieldRef<"Clinic", 'String'>
    readonly email: FieldRef<"Clinic", 'String'>
    readonly website: FieldRef<"Clinic", 'String'>
    readonly description: FieldRef<"Clinic", 'String'>
    readonly featured: FieldRef<"Clinic", 'Boolean'>
    readonly logoUrl: FieldRef<"Clinic", 'String'>
    readonly rating: FieldRef<"Clinic", 'Float'>
    readonly reviewCount: FieldRef<"Clinic", 'Int'>
    readonly createdAt: FieldRef<"Clinic", 'DateTime'>
    readonly updatedAt: FieldRef<"Clinic", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Clinic findUnique
   */
  export type ClinicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * Filter, which Clinic to fetch.
     */
    where: ClinicWhereUniqueInput
  }

  /**
   * Clinic findUniqueOrThrow
   */
  export type ClinicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * Filter, which Clinic to fetch.
     */
    where: ClinicWhereUniqueInput
  }

  /**
   * Clinic findFirst
   */
  export type ClinicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * Filter, which Clinic to fetch.
     */
    where?: ClinicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clinics to fetch.
     */
    orderBy?: ClinicOrderByWithRelationInput | ClinicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clinics.
     */
    cursor?: ClinicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clinics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clinics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clinics.
     */
    distinct?: ClinicScalarFieldEnum | ClinicScalarFieldEnum[]
  }

  /**
   * Clinic findFirstOrThrow
   */
  export type ClinicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * Filter, which Clinic to fetch.
     */
    where?: ClinicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clinics to fetch.
     */
    orderBy?: ClinicOrderByWithRelationInput | ClinicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clinics.
     */
    cursor?: ClinicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clinics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clinics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clinics.
     */
    distinct?: ClinicScalarFieldEnum | ClinicScalarFieldEnum[]
  }

  /**
   * Clinic findMany
   */
  export type ClinicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * Filter, which Clinics to fetch.
     */
    where?: ClinicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clinics to fetch.
     */
    orderBy?: ClinicOrderByWithRelationInput | ClinicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clinics.
     */
    cursor?: ClinicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clinics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clinics.
     */
    skip?: number
    distinct?: ClinicScalarFieldEnum | ClinicScalarFieldEnum[]
  }

  /**
   * Clinic create
   */
  export type ClinicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * The data needed to create a Clinic.
     */
    data: XOR<ClinicCreateInput, ClinicUncheckedCreateInput>
  }

  /**
   * Clinic createMany
   */
  export type ClinicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clinics.
     */
    data: ClinicCreateManyInput | ClinicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Clinic createManyAndReturn
   */
  export type ClinicCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * The data used to create many Clinics.
     */
    data: ClinicCreateManyInput | ClinicCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Clinic update
   */
  export type ClinicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * The data needed to update a Clinic.
     */
    data: XOR<ClinicUpdateInput, ClinicUncheckedUpdateInput>
    /**
     * Choose, which Clinic to update.
     */
    where: ClinicWhereUniqueInput
  }

  /**
   * Clinic updateMany
   */
  export type ClinicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clinics.
     */
    data: XOR<ClinicUpdateManyMutationInput, ClinicUncheckedUpdateManyInput>
    /**
     * Filter which Clinics to update
     */
    where?: ClinicWhereInput
    /**
     * Limit how many Clinics to update.
     */
    limit?: number
  }

  /**
   * Clinic updateManyAndReturn
   */
  export type ClinicUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * The data used to update Clinics.
     */
    data: XOR<ClinicUpdateManyMutationInput, ClinicUncheckedUpdateManyInput>
    /**
     * Filter which Clinics to update
     */
    where?: ClinicWhereInput
    /**
     * Limit how many Clinics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Clinic upsert
   */
  export type ClinicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * The filter to search for the Clinic to update in case it exists.
     */
    where: ClinicWhereUniqueInput
    /**
     * In case the Clinic found by the `where` argument doesn't exist, create a new Clinic with this data.
     */
    create: XOR<ClinicCreateInput, ClinicUncheckedCreateInput>
    /**
     * In case the Clinic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClinicUpdateInput, ClinicUncheckedUpdateInput>
  }

  /**
   * Clinic delete
   */
  export type ClinicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * Filter which Clinic to delete.
     */
    where: ClinicWhereUniqueInput
  }

  /**
   * Clinic deleteMany
   */
  export type ClinicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clinics to delete
     */
    where?: ClinicWhereInput
    /**
     * Limit how many Clinics to delete.
     */
    limit?: number
  }

  /**
   * Clinic.schedules
   */
  export type Clinic$schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    cursor?: ScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Clinic.campaigns
   */
  export type Clinic$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Clinic without action
   */
  export type ClinicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clinic
     */
    omit?: ClinicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    price: number | null
    stock: number | null
  }

  export type ProductSumAggregateOutputType = {
    price: number | null
    stock: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    price: number | null
    sku: string | null
    imageUrl: string | null
    featured: boolean | null
    category: string | null
    stock: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    price: number | null
    sku: string | null
    imageUrl: string | null
    featured: boolean | null
    category: string | null
    stock: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    description: number
    price: number
    sku: number
    imageUrl: number
    featured: number
    category: number
    stock: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    price?: true
    stock?: true
  }

  export type ProductSumAggregateInputType = {
    price?: true
    stock?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    price?: true
    sku?: true
    imageUrl?: true
    featured?: true
    category?: true
    stock?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    price?: true
    sku?: true
    imageUrl?: true
    featured?: true
    category?: true
    stock?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    price?: true
    sku?: true
    imageUrl?: true
    featured?: true
    category?: true
    stock?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    userId: string
    name: string
    description: string | null
    price: number | null
    sku: string | null
    imageUrl: string | null
    featured: boolean
    category: string | null
    stock: number | null
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    sku?: boolean
    imageUrl?: boolean
    featured?: boolean
    category?: boolean
    stock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    schedules?: boolean | Product$schedulesArgs<ExtArgs>
    campaigns?: boolean | Product$campaignsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    sku?: boolean
    imageUrl?: boolean
    featured?: boolean
    category?: boolean
    stock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    sku?: boolean
    imageUrl?: boolean
    featured?: boolean
    category?: boolean
    stock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    sku?: boolean
    imageUrl?: boolean
    featured?: boolean
    category?: boolean
    stock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "description" | "price" | "sku" | "imageUrl" | "featured" | "category" | "stock" | "createdAt" | "updatedAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    schedules?: boolean | Product$schedulesArgs<ExtArgs>
    campaigns?: boolean | Product$campaignsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      schedules: Prisma.$SchedulePayload<ExtArgs>[]
      campaigns: Prisma.$CampaignPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      description: string | null
      price: number | null
      sku: string | null
      imageUrl: string | null
      featured: boolean
      category: string | null
      stock: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    schedules<T extends Product$schedulesArgs<ExtArgs> = {}>(args?: Subset<T, Product$schedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    campaigns<T extends Product$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, Product$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly userId: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'Float'>
    readonly sku: FieldRef<"Product", 'String'>
    readonly imageUrl: FieldRef<"Product", 'String'>
    readonly featured: FieldRef<"Product", 'Boolean'>
    readonly category: FieldRef<"Product", 'String'>
    readonly stock: FieldRef<"Product", 'Int'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.schedules
   */
  export type Product$schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    cursor?: ScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Product.campaigns
   */
  export type Product$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Campaign
     */
    select?: CampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Campaign
     */
    omit?: CampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignInclude<ExtArgs> | null
    where?: CampaignWhereInput
    orderBy?: CampaignOrderByWithRelationInput | CampaignOrderByWithRelationInput[]
    cursor?: CampaignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignScalarFieldEnum | CampaignScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Income
   */

  export type AggregateIncome = {
    _count: IncomeCountAggregateOutputType | null
    _avg: IncomeAvgAggregateOutputType | null
    _sum: IncomeSumAggregateOutputType | null
    _min: IncomeMinAggregateOutputType | null
    _max: IncomeMaxAggregateOutputType | null
  }

  export type IncomeAvgAggregateOutputType = {
    amount: number | null
  }

  export type IncomeSumAggregateOutputType = {
    amount: number | null
  }

  export type IncomeMinAggregateOutputType = {
    id: string | null
    source: string | null
    amount: number | null
    description: string | null
    date: Date | null
    category: $Enums.IncomeCategory | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IncomeMaxAggregateOutputType = {
    id: string | null
    source: string | null
    amount: number | null
    description: string | null
    date: Date | null
    category: $Enums.IncomeCategory | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IncomeCountAggregateOutputType = {
    id: number
    source: number
    amount: number
    description: number
    date: number
    category: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IncomeAvgAggregateInputType = {
    amount?: true
  }

  export type IncomeSumAggregateInputType = {
    amount?: true
  }

  export type IncomeMinAggregateInputType = {
    id?: true
    source?: true
    amount?: true
    description?: true
    date?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IncomeMaxAggregateInputType = {
    id?: true
    source?: true
    amount?: true
    description?: true
    date?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IncomeCountAggregateInputType = {
    id?: true
    source?: true
    amount?: true
    description?: true
    date?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IncomeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Income to aggregate.
     */
    where?: IncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incomes to fetch.
     */
    orderBy?: IncomeOrderByWithRelationInput | IncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Incomes
    **/
    _count?: true | IncomeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IncomeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IncomeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncomeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncomeMaxAggregateInputType
  }

  export type GetIncomeAggregateType<T extends IncomeAggregateArgs> = {
        [P in keyof T & keyof AggregateIncome]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncome[P]>
      : GetScalarType<T[P], AggregateIncome[P]>
  }




  export type IncomeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IncomeWhereInput
    orderBy?: IncomeOrderByWithAggregationInput | IncomeOrderByWithAggregationInput[]
    by: IncomeScalarFieldEnum[] | IncomeScalarFieldEnum
    having?: IncomeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncomeCountAggregateInputType | true
    _avg?: IncomeAvgAggregateInputType
    _sum?: IncomeSumAggregateInputType
    _min?: IncomeMinAggregateInputType
    _max?: IncomeMaxAggregateInputType
  }

  export type IncomeGroupByOutputType = {
    id: string
    source: string
    amount: number
    description: string | null
    date: Date
    category: $Enums.IncomeCategory
    createdAt: Date
    updatedAt: Date
    _count: IncomeCountAggregateOutputType | null
    _avg: IncomeAvgAggregateOutputType | null
    _sum: IncomeSumAggregateOutputType | null
    _min: IncomeMinAggregateOutputType | null
    _max: IncomeMaxAggregateOutputType | null
  }

  type GetIncomeGroupByPayload<T extends IncomeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IncomeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncomeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncomeGroupByOutputType[P]>
            : GetScalarType<T[P], IncomeGroupByOutputType[P]>
        }
      >
    >


  export type IncomeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    source?: boolean
    amount?: boolean
    description?: boolean
    date?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["income"]>

  export type IncomeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    source?: boolean
    amount?: boolean
    description?: boolean
    date?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["income"]>

  export type IncomeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    source?: boolean
    amount?: boolean
    description?: boolean
    date?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["income"]>

  export type IncomeSelectScalar = {
    id?: boolean
    source?: boolean
    amount?: boolean
    description?: boolean
    date?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IncomeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "source" | "amount" | "description" | "date" | "category" | "createdAt" | "updatedAt", ExtArgs["result"]["income"]>

  export type $IncomePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Income"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      source: string
      amount: number
      description: string | null
      date: Date
      category: $Enums.IncomeCategory
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["income"]>
    composites: {}
  }

  type IncomeGetPayload<S extends boolean | null | undefined | IncomeDefaultArgs> = $Result.GetResult<Prisma.$IncomePayload, S>

  type IncomeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IncomeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IncomeCountAggregateInputType | true
    }

  export interface IncomeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Income'], meta: { name: 'Income' } }
    /**
     * Find zero or one Income that matches the filter.
     * @param {IncomeFindUniqueArgs} args - Arguments to find a Income
     * @example
     * // Get one Income
     * const income = await prisma.income.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IncomeFindUniqueArgs>(args: SelectSubset<T, IncomeFindUniqueArgs<ExtArgs>>): Prisma__IncomeClient<$Result.GetResult<Prisma.$IncomePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Income that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IncomeFindUniqueOrThrowArgs} args - Arguments to find a Income
     * @example
     * // Get one Income
     * const income = await prisma.income.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IncomeFindUniqueOrThrowArgs>(args: SelectSubset<T, IncomeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IncomeClient<$Result.GetResult<Prisma.$IncomePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Income that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeFindFirstArgs} args - Arguments to find a Income
     * @example
     * // Get one Income
     * const income = await prisma.income.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IncomeFindFirstArgs>(args?: SelectSubset<T, IncomeFindFirstArgs<ExtArgs>>): Prisma__IncomeClient<$Result.GetResult<Prisma.$IncomePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Income that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeFindFirstOrThrowArgs} args - Arguments to find a Income
     * @example
     * // Get one Income
     * const income = await prisma.income.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IncomeFindFirstOrThrowArgs>(args?: SelectSubset<T, IncomeFindFirstOrThrowArgs<ExtArgs>>): Prisma__IncomeClient<$Result.GetResult<Prisma.$IncomePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Incomes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Incomes
     * const incomes = await prisma.income.findMany()
     * 
     * // Get first 10 Incomes
     * const incomes = await prisma.income.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incomeWithIdOnly = await prisma.income.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IncomeFindManyArgs>(args?: SelectSubset<T, IncomeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncomePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Income.
     * @param {IncomeCreateArgs} args - Arguments to create a Income.
     * @example
     * // Create one Income
     * const Income = await prisma.income.create({
     *   data: {
     *     // ... data to create a Income
     *   }
     * })
     * 
     */
    create<T extends IncomeCreateArgs>(args: SelectSubset<T, IncomeCreateArgs<ExtArgs>>): Prisma__IncomeClient<$Result.GetResult<Prisma.$IncomePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Incomes.
     * @param {IncomeCreateManyArgs} args - Arguments to create many Incomes.
     * @example
     * // Create many Incomes
     * const income = await prisma.income.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IncomeCreateManyArgs>(args?: SelectSubset<T, IncomeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Incomes and returns the data saved in the database.
     * @param {IncomeCreateManyAndReturnArgs} args - Arguments to create many Incomes.
     * @example
     * // Create many Incomes
     * const income = await prisma.income.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Incomes and only return the `id`
     * const incomeWithIdOnly = await prisma.income.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IncomeCreateManyAndReturnArgs>(args?: SelectSubset<T, IncomeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncomePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Income.
     * @param {IncomeDeleteArgs} args - Arguments to delete one Income.
     * @example
     * // Delete one Income
     * const Income = await prisma.income.delete({
     *   where: {
     *     // ... filter to delete one Income
     *   }
     * })
     * 
     */
    delete<T extends IncomeDeleteArgs>(args: SelectSubset<T, IncomeDeleteArgs<ExtArgs>>): Prisma__IncomeClient<$Result.GetResult<Prisma.$IncomePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Income.
     * @param {IncomeUpdateArgs} args - Arguments to update one Income.
     * @example
     * // Update one Income
     * const income = await prisma.income.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IncomeUpdateArgs>(args: SelectSubset<T, IncomeUpdateArgs<ExtArgs>>): Prisma__IncomeClient<$Result.GetResult<Prisma.$IncomePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Incomes.
     * @param {IncomeDeleteManyArgs} args - Arguments to filter Incomes to delete.
     * @example
     * // Delete a few Incomes
     * const { count } = await prisma.income.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IncomeDeleteManyArgs>(args?: SelectSubset<T, IncomeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Incomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Incomes
     * const income = await prisma.income.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IncomeUpdateManyArgs>(args: SelectSubset<T, IncomeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Incomes and returns the data updated in the database.
     * @param {IncomeUpdateManyAndReturnArgs} args - Arguments to update many Incomes.
     * @example
     * // Update many Incomes
     * const income = await prisma.income.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Incomes and only return the `id`
     * const incomeWithIdOnly = await prisma.income.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IncomeUpdateManyAndReturnArgs>(args: SelectSubset<T, IncomeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IncomePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Income.
     * @param {IncomeUpsertArgs} args - Arguments to update or create a Income.
     * @example
     * // Update or create a Income
     * const income = await prisma.income.upsert({
     *   create: {
     *     // ... data to create a Income
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Income we want to update
     *   }
     * })
     */
    upsert<T extends IncomeUpsertArgs>(args: SelectSubset<T, IncomeUpsertArgs<ExtArgs>>): Prisma__IncomeClient<$Result.GetResult<Prisma.$IncomePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Incomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeCountArgs} args - Arguments to filter Incomes to count.
     * @example
     * // Count the number of Incomes
     * const count = await prisma.income.count({
     *   where: {
     *     // ... the filter for the Incomes we want to count
     *   }
     * })
    **/
    count<T extends IncomeCountArgs>(
      args?: Subset<T, IncomeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncomeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Income.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncomeAggregateArgs>(args: Subset<T, IncomeAggregateArgs>): Prisma.PrismaPromise<GetIncomeAggregateType<T>>

    /**
     * Group by Income.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncomeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IncomeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IncomeGroupByArgs['orderBy'] }
        : { orderBy?: IncomeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IncomeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncomeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Income model
   */
  readonly fields: IncomeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Income.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IncomeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Income model
   */
  interface IncomeFieldRefs {
    readonly id: FieldRef<"Income", 'String'>
    readonly source: FieldRef<"Income", 'String'>
    readonly amount: FieldRef<"Income", 'Float'>
    readonly description: FieldRef<"Income", 'String'>
    readonly date: FieldRef<"Income", 'DateTime'>
    readonly category: FieldRef<"Income", 'IncomeCategory'>
    readonly createdAt: FieldRef<"Income", 'DateTime'>
    readonly updatedAt: FieldRef<"Income", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Income findUnique
   */
  export type IncomeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Income
     */
    select?: IncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Income
     */
    omit?: IncomeOmit<ExtArgs> | null
    /**
     * Filter, which Income to fetch.
     */
    where: IncomeWhereUniqueInput
  }

  /**
   * Income findUniqueOrThrow
   */
  export type IncomeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Income
     */
    select?: IncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Income
     */
    omit?: IncomeOmit<ExtArgs> | null
    /**
     * Filter, which Income to fetch.
     */
    where: IncomeWhereUniqueInput
  }

  /**
   * Income findFirst
   */
  export type IncomeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Income
     */
    select?: IncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Income
     */
    omit?: IncomeOmit<ExtArgs> | null
    /**
     * Filter, which Income to fetch.
     */
    where?: IncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incomes to fetch.
     */
    orderBy?: IncomeOrderByWithRelationInput | IncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Incomes.
     */
    cursor?: IncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Incomes.
     */
    distinct?: IncomeScalarFieldEnum | IncomeScalarFieldEnum[]
  }

  /**
   * Income findFirstOrThrow
   */
  export type IncomeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Income
     */
    select?: IncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Income
     */
    omit?: IncomeOmit<ExtArgs> | null
    /**
     * Filter, which Income to fetch.
     */
    where?: IncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incomes to fetch.
     */
    orderBy?: IncomeOrderByWithRelationInput | IncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Incomes.
     */
    cursor?: IncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Incomes.
     */
    distinct?: IncomeScalarFieldEnum | IncomeScalarFieldEnum[]
  }

  /**
   * Income findMany
   */
  export type IncomeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Income
     */
    select?: IncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Income
     */
    omit?: IncomeOmit<ExtArgs> | null
    /**
     * Filter, which Incomes to fetch.
     */
    where?: IncomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Incomes to fetch.
     */
    orderBy?: IncomeOrderByWithRelationInput | IncomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Incomes.
     */
    cursor?: IncomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Incomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Incomes.
     */
    skip?: number
    distinct?: IncomeScalarFieldEnum | IncomeScalarFieldEnum[]
  }

  /**
   * Income create
   */
  export type IncomeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Income
     */
    select?: IncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Income
     */
    omit?: IncomeOmit<ExtArgs> | null
    /**
     * The data needed to create a Income.
     */
    data: XOR<IncomeCreateInput, IncomeUncheckedCreateInput>
  }

  /**
   * Income createMany
   */
  export type IncomeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Incomes.
     */
    data: IncomeCreateManyInput | IncomeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Income createManyAndReturn
   */
  export type IncomeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Income
     */
    select?: IncomeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Income
     */
    omit?: IncomeOmit<ExtArgs> | null
    /**
     * The data used to create many Incomes.
     */
    data: IncomeCreateManyInput | IncomeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Income update
   */
  export type IncomeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Income
     */
    select?: IncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Income
     */
    omit?: IncomeOmit<ExtArgs> | null
    /**
     * The data needed to update a Income.
     */
    data: XOR<IncomeUpdateInput, IncomeUncheckedUpdateInput>
    /**
     * Choose, which Income to update.
     */
    where: IncomeWhereUniqueInput
  }

  /**
   * Income updateMany
   */
  export type IncomeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Incomes.
     */
    data: XOR<IncomeUpdateManyMutationInput, IncomeUncheckedUpdateManyInput>
    /**
     * Filter which Incomes to update
     */
    where?: IncomeWhereInput
    /**
     * Limit how many Incomes to update.
     */
    limit?: number
  }

  /**
   * Income updateManyAndReturn
   */
  export type IncomeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Income
     */
    select?: IncomeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Income
     */
    omit?: IncomeOmit<ExtArgs> | null
    /**
     * The data used to update Incomes.
     */
    data: XOR<IncomeUpdateManyMutationInput, IncomeUncheckedUpdateManyInput>
    /**
     * Filter which Incomes to update
     */
    where?: IncomeWhereInput
    /**
     * Limit how many Incomes to update.
     */
    limit?: number
  }

  /**
   * Income upsert
   */
  export type IncomeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Income
     */
    select?: IncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Income
     */
    omit?: IncomeOmit<ExtArgs> | null
    /**
     * The filter to search for the Income to update in case it exists.
     */
    where: IncomeWhereUniqueInput
    /**
     * In case the Income found by the `where` argument doesn't exist, create a new Income with this data.
     */
    create: XOR<IncomeCreateInput, IncomeUncheckedCreateInput>
    /**
     * In case the Income was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IncomeUpdateInput, IncomeUncheckedUpdateInput>
  }

  /**
   * Income delete
   */
  export type IncomeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Income
     */
    select?: IncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Income
     */
    omit?: IncomeOmit<ExtArgs> | null
    /**
     * Filter which Income to delete.
     */
    where: IncomeWhereUniqueInput
  }

  /**
   * Income deleteMany
   */
  export type IncomeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Incomes to delete
     */
    where?: IncomeWhereInput
    /**
     * Limit how many Incomes to delete.
     */
    limit?: number
  }

  /**
   * Income without action
   */
  export type IncomeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Income
     */
    select?: IncomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Income
     */
    omit?: IncomeOmit<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: number | null
    currency: string | null
    status: $Enums.PaymentStatus | null
    method: $Enums.PaymentMethod | null
    description: string | null
    transactionId: string | null
    receiptUrl: string | null
    invoiceId: string | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: number | null
    currency: string | null
    status: $Enums.PaymentStatus | null
    method: $Enums.PaymentMethod | null
    description: string | null
    transactionId: string | null
    receiptUrl: string | null
    invoiceId: string | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    userId: number
    amount: number
    currency: number
    status: number
    method: number
    description: number
    transactionId: number
    receiptUrl: number
    invoiceId: number
    date: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    currency?: true
    status?: true
    method?: true
    description?: true
    transactionId?: true
    receiptUrl?: true
    invoiceId?: true
    date?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    currency?: true
    status?: true
    method?: true
    description?: true
    transactionId?: true
    receiptUrl?: true
    invoiceId?: true
    date?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    currency?: true
    status?: true
    method?: true
    description?: true
    transactionId?: true
    receiptUrl?: true
    invoiceId?: true
    date?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    userId: string
    amount: number
    currency: string
    status: $Enums.PaymentStatus
    method: $Enums.PaymentMethod
    description: string | null
    transactionId: string | null
    receiptUrl: string | null
    invoiceId: string | null
    date: Date
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    method?: boolean
    description?: boolean
    transactionId?: boolean
    receiptUrl?: boolean
    invoiceId?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    method?: boolean
    description?: boolean
    transactionId?: boolean
    receiptUrl?: boolean
    invoiceId?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    method?: boolean
    description?: boolean
    transactionId?: boolean
    receiptUrl?: boolean
    invoiceId?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    method?: boolean
    description?: boolean
    transactionId?: boolean
    receiptUrl?: boolean
    invoiceId?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "amount" | "currency" | "status" | "method" | "description" | "transactionId" | "receiptUrl" | "invoiceId" | "date" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    invoice?: boolean | Payment$invoiceArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      amount: number
      currency: string
      status: $Enums.PaymentStatus
      method: $Enums.PaymentMethod
      description: string | null
      transactionId: string | null
      receiptUrl: string | null
      invoiceId: string | null
      date: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invoice<T extends Payment$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, Payment$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly userId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly method: FieldRef<"Payment", 'PaymentMethod'>
    readonly description: FieldRef<"Payment", 'String'>
    readonly transactionId: FieldRef<"Payment", 'String'>
    readonly receiptUrl: FieldRef<"Payment", 'String'>
    readonly invoiceId: FieldRef<"Payment", 'String'>
    readonly date: FieldRef<"Payment", 'DateTime'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.invoice
   */
  export type Payment$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    amount: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    amount: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    invoiceNumber: string | null
    amount: number | null
    currency: string | null
    status: $Enums.InvoiceStatus | null
    dueDate: Date | null
    issueDate: Date | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    invoiceNumber: string | null
    amount: number | null
    currency: string | null
    status: $Enums.InvoiceStatus | null
    dueDate: Date | null
    issueDate: Date | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    userId: number
    invoiceNumber: number
    amount: number
    currency: number
    status: number
    dueDate: number
    issueDate: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    amount?: true
  }

  export type InvoiceSumAggregateInputType = {
    amount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    userId?: true
    invoiceNumber?: true
    amount?: true
    currency?: true
    status?: true
    dueDate?: true
    issueDate?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    userId?: true
    invoiceNumber?: true
    amount?: true
    currency?: true
    status?: true
    dueDate?: true
    issueDate?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    userId?: true
    invoiceNumber?: true
    amount?: true
    currency?: true
    status?: true
    dueDate?: true
    issueDate?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    userId: string
    invoiceNumber: string
    amount: number
    currency: string
    status: $Enums.InvoiceStatus
    dueDate: Date
    issueDate: Date
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    invoiceNumber?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    dueDate?: boolean
    issueDate?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    invoiceNumber?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    dueDate?: boolean
    issueDate?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    invoiceNumber?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    dueDate?: boolean
    issueDate?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    userId?: boolean
    invoiceNumber?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    dueDate?: boolean
    issueDate?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "invoiceNumber" | "amount" | "currency" | "status" | "dueDate" | "issueDate" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      invoiceNumber: string
      amount: number
      currency: string
      status: $Enums.InvoiceStatus
      dueDate: Date
      issueDate: Date
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payments<T extends Invoice$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly userId: FieldRef<"Invoice", 'String'>
    readonly invoiceNumber: FieldRef<"Invoice", 'String'>
    readonly amount: FieldRef<"Invoice", 'Float'>
    readonly currency: FieldRef<"Invoice", 'String'>
    readonly status: FieldRef<"Invoice", 'InvoiceStatus'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly issueDate: FieldRef<"Invoice", 'DateTime'>
    readonly description: FieldRef<"Invoice", 'String'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice.payments
   */
  export type Invoice$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model ROASMetrics
   */

  export type AggregateROASMetrics = {
    _count: ROASMetricsCountAggregateOutputType | null
    _avg: ROASMetricsAvgAggregateOutputType | null
    _sum: ROASMetricsSumAggregateOutputType | null
    _min: ROASMetricsMinAggregateOutputType | null
    _max: ROASMetricsMaxAggregateOutputType | null
  }

  export type ROASMetricsAvgAggregateOutputType = {
    adSpend: number | null
    revenue: number | null
    roasValue: number | null
  }

  export type ROASMetricsSumAggregateOutputType = {
    adSpend: number | null
    revenue: number | null
    roasValue: number | null
  }

  export type ROASMetricsMinAggregateOutputType = {
    id: string | null
    date: Date | null
    adSpend: number | null
    revenue: number | null
    roasValue: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ROASMetricsMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    adSpend: number | null
    revenue: number | null
    roasValue: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ROASMetricsCountAggregateOutputType = {
    id: number
    date: number
    adSpend: number
    revenue: number
    roasValue: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ROASMetricsAvgAggregateInputType = {
    adSpend?: true
    revenue?: true
    roasValue?: true
  }

  export type ROASMetricsSumAggregateInputType = {
    adSpend?: true
    revenue?: true
    roasValue?: true
  }

  export type ROASMetricsMinAggregateInputType = {
    id?: true
    date?: true
    adSpend?: true
    revenue?: true
    roasValue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ROASMetricsMaxAggregateInputType = {
    id?: true
    date?: true
    adSpend?: true
    revenue?: true
    roasValue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ROASMetricsCountAggregateInputType = {
    id?: true
    date?: true
    adSpend?: true
    revenue?: true
    roasValue?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ROASMetricsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ROASMetrics to aggregate.
     */
    where?: ROASMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ROASMetrics to fetch.
     */
    orderBy?: ROASMetricsOrderByWithRelationInput | ROASMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ROASMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ROASMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ROASMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ROASMetrics
    **/
    _count?: true | ROASMetricsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ROASMetricsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ROASMetricsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ROASMetricsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ROASMetricsMaxAggregateInputType
  }

  export type GetROASMetricsAggregateType<T extends ROASMetricsAggregateArgs> = {
        [P in keyof T & keyof AggregateROASMetrics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateROASMetrics[P]>
      : GetScalarType<T[P], AggregateROASMetrics[P]>
  }




  export type ROASMetricsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ROASMetricsWhereInput
    orderBy?: ROASMetricsOrderByWithAggregationInput | ROASMetricsOrderByWithAggregationInput[]
    by: ROASMetricsScalarFieldEnum[] | ROASMetricsScalarFieldEnum
    having?: ROASMetricsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ROASMetricsCountAggregateInputType | true
    _avg?: ROASMetricsAvgAggregateInputType
    _sum?: ROASMetricsSumAggregateInputType
    _min?: ROASMetricsMinAggregateInputType
    _max?: ROASMetricsMaxAggregateInputType
  }

  export type ROASMetricsGroupByOutputType = {
    id: string
    date: Date
    adSpend: number
    revenue: number
    roasValue: number | null
    createdAt: Date
    updatedAt: Date
    _count: ROASMetricsCountAggregateOutputType | null
    _avg: ROASMetricsAvgAggregateOutputType | null
    _sum: ROASMetricsSumAggregateOutputType | null
    _min: ROASMetricsMinAggregateOutputType | null
    _max: ROASMetricsMaxAggregateOutputType | null
  }

  type GetROASMetricsGroupByPayload<T extends ROASMetricsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ROASMetricsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ROASMetricsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ROASMetricsGroupByOutputType[P]>
            : GetScalarType<T[P], ROASMetricsGroupByOutputType[P]>
        }
      >
    >


  export type ROASMetricsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    adSpend?: boolean
    revenue?: boolean
    roasValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["rOASMetrics"]>

  export type ROASMetricsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    adSpend?: boolean
    revenue?: boolean
    roasValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["rOASMetrics"]>

  export type ROASMetricsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    adSpend?: boolean
    revenue?: boolean
    roasValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["rOASMetrics"]>

  export type ROASMetricsSelectScalar = {
    id?: boolean
    date?: boolean
    adSpend?: boolean
    revenue?: boolean
    roasValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ROASMetricsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "adSpend" | "revenue" | "roasValue" | "createdAt" | "updatedAt", ExtArgs["result"]["rOASMetrics"]>

  export type $ROASMetricsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ROASMetrics"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      adSpend: number
      revenue: number
      roasValue: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rOASMetrics"]>
    composites: {}
  }

  type ROASMetricsGetPayload<S extends boolean | null | undefined | ROASMetricsDefaultArgs> = $Result.GetResult<Prisma.$ROASMetricsPayload, S>

  type ROASMetricsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ROASMetricsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ROASMetricsCountAggregateInputType | true
    }

  export interface ROASMetricsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ROASMetrics'], meta: { name: 'ROASMetrics' } }
    /**
     * Find zero or one ROASMetrics that matches the filter.
     * @param {ROASMetricsFindUniqueArgs} args - Arguments to find a ROASMetrics
     * @example
     * // Get one ROASMetrics
     * const rOASMetrics = await prisma.rOASMetrics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ROASMetricsFindUniqueArgs>(args: SelectSubset<T, ROASMetricsFindUniqueArgs<ExtArgs>>): Prisma__ROASMetricsClient<$Result.GetResult<Prisma.$ROASMetricsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ROASMetrics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ROASMetricsFindUniqueOrThrowArgs} args - Arguments to find a ROASMetrics
     * @example
     * // Get one ROASMetrics
     * const rOASMetrics = await prisma.rOASMetrics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ROASMetricsFindUniqueOrThrowArgs>(args: SelectSubset<T, ROASMetricsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ROASMetricsClient<$Result.GetResult<Prisma.$ROASMetricsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ROASMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ROASMetricsFindFirstArgs} args - Arguments to find a ROASMetrics
     * @example
     * // Get one ROASMetrics
     * const rOASMetrics = await prisma.rOASMetrics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ROASMetricsFindFirstArgs>(args?: SelectSubset<T, ROASMetricsFindFirstArgs<ExtArgs>>): Prisma__ROASMetricsClient<$Result.GetResult<Prisma.$ROASMetricsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ROASMetrics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ROASMetricsFindFirstOrThrowArgs} args - Arguments to find a ROASMetrics
     * @example
     * // Get one ROASMetrics
     * const rOASMetrics = await prisma.rOASMetrics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ROASMetricsFindFirstOrThrowArgs>(args?: SelectSubset<T, ROASMetricsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ROASMetricsClient<$Result.GetResult<Prisma.$ROASMetricsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ROASMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ROASMetricsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ROASMetrics
     * const rOASMetrics = await prisma.rOASMetrics.findMany()
     * 
     * // Get first 10 ROASMetrics
     * const rOASMetrics = await prisma.rOASMetrics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rOASMetricsWithIdOnly = await prisma.rOASMetrics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ROASMetricsFindManyArgs>(args?: SelectSubset<T, ROASMetricsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ROASMetricsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ROASMetrics.
     * @param {ROASMetricsCreateArgs} args - Arguments to create a ROASMetrics.
     * @example
     * // Create one ROASMetrics
     * const ROASMetrics = await prisma.rOASMetrics.create({
     *   data: {
     *     // ... data to create a ROASMetrics
     *   }
     * })
     * 
     */
    create<T extends ROASMetricsCreateArgs>(args: SelectSubset<T, ROASMetricsCreateArgs<ExtArgs>>): Prisma__ROASMetricsClient<$Result.GetResult<Prisma.$ROASMetricsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ROASMetrics.
     * @param {ROASMetricsCreateManyArgs} args - Arguments to create many ROASMetrics.
     * @example
     * // Create many ROASMetrics
     * const rOASMetrics = await prisma.rOASMetrics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ROASMetricsCreateManyArgs>(args?: SelectSubset<T, ROASMetricsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ROASMetrics and returns the data saved in the database.
     * @param {ROASMetricsCreateManyAndReturnArgs} args - Arguments to create many ROASMetrics.
     * @example
     * // Create many ROASMetrics
     * const rOASMetrics = await prisma.rOASMetrics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ROASMetrics and only return the `id`
     * const rOASMetricsWithIdOnly = await prisma.rOASMetrics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ROASMetricsCreateManyAndReturnArgs>(args?: SelectSubset<T, ROASMetricsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ROASMetricsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ROASMetrics.
     * @param {ROASMetricsDeleteArgs} args - Arguments to delete one ROASMetrics.
     * @example
     * // Delete one ROASMetrics
     * const ROASMetrics = await prisma.rOASMetrics.delete({
     *   where: {
     *     // ... filter to delete one ROASMetrics
     *   }
     * })
     * 
     */
    delete<T extends ROASMetricsDeleteArgs>(args: SelectSubset<T, ROASMetricsDeleteArgs<ExtArgs>>): Prisma__ROASMetricsClient<$Result.GetResult<Prisma.$ROASMetricsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ROASMetrics.
     * @param {ROASMetricsUpdateArgs} args - Arguments to update one ROASMetrics.
     * @example
     * // Update one ROASMetrics
     * const rOASMetrics = await prisma.rOASMetrics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ROASMetricsUpdateArgs>(args: SelectSubset<T, ROASMetricsUpdateArgs<ExtArgs>>): Prisma__ROASMetricsClient<$Result.GetResult<Prisma.$ROASMetricsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ROASMetrics.
     * @param {ROASMetricsDeleteManyArgs} args - Arguments to filter ROASMetrics to delete.
     * @example
     * // Delete a few ROASMetrics
     * const { count } = await prisma.rOASMetrics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ROASMetricsDeleteManyArgs>(args?: SelectSubset<T, ROASMetricsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ROASMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ROASMetricsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ROASMetrics
     * const rOASMetrics = await prisma.rOASMetrics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ROASMetricsUpdateManyArgs>(args: SelectSubset<T, ROASMetricsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ROASMetrics and returns the data updated in the database.
     * @param {ROASMetricsUpdateManyAndReturnArgs} args - Arguments to update many ROASMetrics.
     * @example
     * // Update many ROASMetrics
     * const rOASMetrics = await prisma.rOASMetrics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ROASMetrics and only return the `id`
     * const rOASMetricsWithIdOnly = await prisma.rOASMetrics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ROASMetricsUpdateManyAndReturnArgs>(args: SelectSubset<T, ROASMetricsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ROASMetricsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ROASMetrics.
     * @param {ROASMetricsUpsertArgs} args - Arguments to update or create a ROASMetrics.
     * @example
     * // Update or create a ROASMetrics
     * const rOASMetrics = await prisma.rOASMetrics.upsert({
     *   create: {
     *     // ... data to create a ROASMetrics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ROASMetrics we want to update
     *   }
     * })
     */
    upsert<T extends ROASMetricsUpsertArgs>(args: SelectSubset<T, ROASMetricsUpsertArgs<ExtArgs>>): Prisma__ROASMetricsClient<$Result.GetResult<Prisma.$ROASMetricsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ROASMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ROASMetricsCountArgs} args - Arguments to filter ROASMetrics to count.
     * @example
     * // Count the number of ROASMetrics
     * const count = await prisma.rOASMetrics.count({
     *   where: {
     *     // ... the filter for the ROASMetrics we want to count
     *   }
     * })
    **/
    count<T extends ROASMetricsCountArgs>(
      args?: Subset<T, ROASMetricsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ROASMetricsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ROASMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ROASMetricsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ROASMetricsAggregateArgs>(args: Subset<T, ROASMetricsAggregateArgs>): Prisma.PrismaPromise<GetROASMetricsAggregateType<T>>

    /**
     * Group by ROASMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ROASMetricsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ROASMetricsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ROASMetricsGroupByArgs['orderBy'] }
        : { orderBy?: ROASMetricsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ROASMetricsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetROASMetricsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ROASMetrics model
   */
  readonly fields: ROASMetricsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ROASMetrics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ROASMetricsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ROASMetrics model
   */
  interface ROASMetricsFieldRefs {
    readonly id: FieldRef<"ROASMetrics", 'String'>
    readonly date: FieldRef<"ROASMetrics", 'DateTime'>
    readonly adSpend: FieldRef<"ROASMetrics", 'Float'>
    readonly revenue: FieldRef<"ROASMetrics", 'Float'>
    readonly roasValue: FieldRef<"ROASMetrics", 'Float'>
    readonly createdAt: FieldRef<"ROASMetrics", 'DateTime'>
    readonly updatedAt: FieldRef<"ROASMetrics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ROASMetrics findUnique
   */
  export type ROASMetricsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ROASMetrics
     */
    select?: ROASMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ROASMetrics
     */
    omit?: ROASMetricsOmit<ExtArgs> | null
    /**
     * Filter, which ROASMetrics to fetch.
     */
    where: ROASMetricsWhereUniqueInput
  }

  /**
   * ROASMetrics findUniqueOrThrow
   */
  export type ROASMetricsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ROASMetrics
     */
    select?: ROASMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ROASMetrics
     */
    omit?: ROASMetricsOmit<ExtArgs> | null
    /**
     * Filter, which ROASMetrics to fetch.
     */
    where: ROASMetricsWhereUniqueInput
  }

  /**
   * ROASMetrics findFirst
   */
  export type ROASMetricsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ROASMetrics
     */
    select?: ROASMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ROASMetrics
     */
    omit?: ROASMetricsOmit<ExtArgs> | null
    /**
     * Filter, which ROASMetrics to fetch.
     */
    where?: ROASMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ROASMetrics to fetch.
     */
    orderBy?: ROASMetricsOrderByWithRelationInput | ROASMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ROASMetrics.
     */
    cursor?: ROASMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ROASMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ROASMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ROASMetrics.
     */
    distinct?: ROASMetricsScalarFieldEnum | ROASMetricsScalarFieldEnum[]
  }

  /**
   * ROASMetrics findFirstOrThrow
   */
  export type ROASMetricsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ROASMetrics
     */
    select?: ROASMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ROASMetrics
     */
    omit?: ROASMetricsOmit<ExtArgs> | null
    /**
     * Filter, which ROASMetrics to fetch.
     */
    where?: ROASMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ROASMetrics to fetch.
     */
    orderBy?: ROASMetricsOrderByWithRelationInput | ROASMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ROASMetrics.
     */
    cursor?: ROASMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ROASMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ROASMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ROASMetrics.
     */
    distinct?: ROASMetricsScalarFieldEnum | ROASMetricsScalarFieldEnum[]
  }

  /**
   * ROASMetrics findMany
   */
  export type ROASMetricsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ROASMetrics
     */
    select?: ROASMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ROASMetrics
     */
    omit?: ROASMetricsOmit<ExtArgs> | null
    /**
     * Filter, which ROASMetrics to fetch.
     */
    where?: ROASMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ROASMetrics to fetch.
     */
    orderBy?: ROASMetricsOrderByWithRelationInput | ROASMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ROASMetrics.
     */
    cursor?: ROASMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ROASMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ROASMetrics.
     */
    skip?: number
    distinct?: ROASMetricsScalarFieldEnum | ROASMetricsScalarFieldEnum[]
  }

  /**
   * ROASMetrics create
   */
  export type ROASMetricsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ROASMetrics
     */
    select?: ROASMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ROASMetrics
     */
    omit?: ROASMetricsOmit<ExtArgs> | null
    /**
     * The data needed to create a ROASMetrics.
     */
    data: XOR<ROASMetricsCreateInput, ROASMetricsUncheckedCreateInput>
  }

  /**
   * ROASMetrics createMany
   */
  export type ROASMetricsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ROASMetrics.
     */
    data: ROASMetricsCreateManyInput | ROASMetricsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ROASMetrics createManyAndReturn
   */
  export type ROASMetricsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ROASMetrics
     */
    select?: ROASMetricsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ROASMetrics
     */
    omit?: ROASMetricsOmit<ExtArgs> | null
    /**
     * The data used to create many ROASMetrics.
     */
    data: ROASMetricsCreateManyInput | ROASMetricsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ROASMetrics update
   */
  export type ROASMetricsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ROASMetrics
     */
    select?: ROASMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ROASMetrics
     */
    omit?: ROASMetricsOmit<ExtArgs> | null
    /**
     * The data needed to update a ROASMetrics.
     */
    data: XOR<ROASMetricsUpdateInput, ROASMetricsUncheckedUpdateInput>
    /**
     * Choose, which ROASMetrics to update.
     */
    where: ROASMetricsWhereUniqueInput
  }

  /**
   * ROASMetrics updateMany
   */
  export type ROASMetricsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ROASMetrics.
     */
    data: XOR<ROASMetricsUpdateManyMutationInput, ROASMetricsUncheckedUpdateManyInput>
    /**
     * Filter which ROASMetrics to update
     */
    where?: ROASMetricsWhereInput
    /**
     * Limit how many ROASMetrics to update.
     */
    limit?: number
  }

  /**
   * ROASMetrics updateManyAndReturn
   */
  export type ROASMetricsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ROASMetrics
     */
    select?: ROASMetricsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ROASMetrics
     */
    omit?: ROASMetricsOmit<ExtArgs> | null
    /**
     * The data used to update ROASMetrics.
     */
    data: XOR<ROASMetricsUpdateManyMutationInput, ROASMetricsUncheckedUpdateManyInput>
    /**
     * Filter which ROASMetrics to update
     */
    where?: ROASMetricsWhereInput
    /**
     * Limit how many ROASMetrics to update.
     */
    limit?: number
  }

  /**
   * ROASMetrics upsert
   */
  export type ROASMetricsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ROASMetrics
     */
    select?: ROASMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ROASMetrics
     */
    omit?: ROASMetricsOmit<ExtArgs> | null
    /**
     * The filter to search for the ROASMetrics to update in case it exists.
     */
    where: ROASMetricsWhereUniqueInput
    /**
     * In case the ROASMetrics found by the `where` argument doesn't exist, create a new ROASMetrics with this data.
     */
    create: XOR<ROASMetricsCreateInput, ROASMetricsUncheckedCreateInput>
    /**
     * In case the ROASMetrics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ROASMetricsUpdateInput, ROASMetricsUncheckedUpdateInput>
  }

  /**
   * ROASMetrics delete
   */
  export type ROASMetricsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ROASMetrics
     */
    select?: ROASMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ROASMetrics
     */
    omit?: ROASMetricsOmit<ExtArgs> | null
    /**
     * Filter which ROASMetrics to delete.
     */
    where: ROASMetricsWhereUniqueInput
  }

  /**
   * ROASMetrics deleteMany
   */
  export type ROASMetricsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ROASMetrics to delete
     */
    where?: ROASMetricsWhereInput
    /**
     * Limit how many ROASMetrics to delete.
     */
    limit?: number
  }

  /**
   * ROASMetrics without action
   */
  export type ROASMetricsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ROASMetrics
     */
    select?: ROASMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ROASMetrics
     */
    omit?: ROASMetricsOmit<ExtArgs> | null
  }


  /**
   * Model ConversionMetrics
   */

  export type AggregateConversionMetrics = {
    _count: ConversionMetricsCountAggregateOutputType | null
    _avg: ConversionMetricsAvgAggregateOutputType | null
    _sum: ConversionMetricsSumAggregateOutputType | null
    _min: ConversionMetricsMinAggregateOutputType | null
    _max: ConversionMetricsMaxAggregateOutputType | null
  }

  export type ConversionMetricsAvgAggregateOutputType = {
    pageViews: number | null
    uniqueVisitors: number | null
    conversions: number | null
    conversionValue: number | null
    conversionRate: number | null
  }

  export type ConversionMetricsSumAggregateOutputType = {
    pageViews: number | null
    uniqueVisitors: number | null
    conversions: number | null
    conversionValue: number | null
    conversionRate: number | null
  }

  export type ConversionMetricsMinAggregateOutputType = {
    id: string | null
    date: Date | null
    source: string | null
    medium: string | null
    campaign: string | null
    landingPage: string | null
    pageViews: number | null
    uniqueVisitors: number | null
    conversions: number | null
    conversionValue: number | null
    conversionRate: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversionMetricsMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    source: string | null
    medium: string | null
    campaign: string | null
    landingPage: string | null
    pageViews: number | null
    uniqueVisitors: number | null
    conversions: number | null
    conversionValue: number | null
    conversionRate: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversionMetricsCountAggregateOutputType = {
    id: number
    date: number
    source: number
    medium: number
    campaign: number
    landingPage: number
    pageViews: number
    uniqueVisitors: number
    conversions: number
    conversionValue: number
    conversionRate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConversionMetricsAvgAggregateInputType = {
    pageViews?: true
    uniqueVisitors?: true
    conversions?: true
    conversionValue?: true
    conversionRate?: true
  }

  export type ConversionMetricsSumAggregateInputType = {
    pageViews?: true
    uniqueVisitors?: true
    conversions?: true
    conversionValue?: true
    conversionRate?: true
  }

  export type ConversionMetricsMinAggregateInputType = {
    id?: true
    date?: true
    source?: true
    medium?: true
    campaign?: true
    landingPage?: true
    pageViews?: true
    uniqueVisitors?: true
    conversions?: true
    conversionValue?: true
    conversionRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversionMetricsMaxAggregateInputType = {
    id?: true
    date?: true
    source?: true
    medium?: true
    campaign?: true
    landingPage?: true
    pageViews?: true
    uniqueVisitors?: true
    conversions?: true
    conversionValue?: true
    conversionRate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversionMetricsCountAggregateInputType = {
    id?: true
    date?: true
    source?: true
    medium?: true
    campaign?: true
    landingPage?: true
    pageViews?: true
    uniqueVisitors?: true
    conversions?: true
    conversionValue?: true
    conversionRate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConversionMetricsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversionMetrics to aggregate.
     */
    where?: ConversionMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversionMetrics to fetch.
     */
    orderBy?: ConversionMetricsOrderByWithRelationInput | ConversionMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversionMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversionMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversionMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConversionMetrics
    **/
    _count?: true | ConversionMetricsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConversionMetricsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConversionMetricsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversionMetricsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversionMetricsMaxAggregateInputType
  }

  export type GetConversionMetricsAggregateType<T extends ConversionMetricsAggregateArgs> = {
        [P in keyof T & keyof AggregateConversionMetrics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversionMetrics[P]>
      : GetScalarType<T[P], AggregateConversionMetrics[P]>
  }




  export type ConversionMetricsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversionMetricsWhereInput
    orderBy?: ConversionMetricsOrderByWithAggregationInput | ConversionMetricsOrderByWithAggregationInput[]
    by: ConversionMetricsScalarFieldEnum[] | ConversionMetricsScalarFieldEnum
    having?: ConversionMetricsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversionMetricsCountAggregateInputType | true
    _avg?: ConversionMetricsAvgAggregateInputType
    _sum?: ConversionMetricsSumAggregateInputType
    _min?: ConversionMetricsMinAggregateInputType
    _max?: ConversionMetricsMaxAggregateInputType
  }

  export type ConversionMetricsGroupByOutputType = {
    id: string
    date: Date
    source: string | null
    medium: string | null
    campaign: string | null
    landingPage: string | null
    pageViews: number
    uniqueVisitors: number
    conversions: number
    conversionValue: number
    conversionRate: number | null
    createdAt: Date
    updatedAt: Date
    _count: ConversionMetricsCountAggregateOutputType | null
    _avg: ConversionMetricsAvgAggregateOutputType | null
    _sum: ConversionMetricsSumAggregateOutputType | null
    _min: ConversionMetricsMinAggregateOutputType | null
    _max: ConversionMetricsMaxAggregateOutputType | null
  }

  type GetConversionMetricsGroupByPayload<T extends ConversionMetricsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversionMetricsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversionMetricsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversionMetricsGroupByOutputType[P]>
            : GetScalarType<T[P], ConversionMetricsGroupByOutputType[P]>
        }
      >
    >


  export type ConversionMetricsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    source?: boolean
    medium?: boolean
    campaign?: boolean
    landingPage?: boolean
    pageViews?: boolean
    uniqueVisitors?: boolean
    conversions?: boolean
    conversionValue?: boolean
    conversionRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["conversionMetrics"]>

  export type ConversionMetricsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    source?: boolean
    medium?: boolean
    campaign?: boolean
    landingPage?: boolean
    pageViews?: boolean
    uniqueVisitors?: boolean
    conversions?: boolean
    conversionValue?: boolean
    conversionRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["conversionMetrics"]>

  export type ConversionMetricsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    source?: boolean
    medium?: boolean
    campaign?: boolean
    landingPage?: boolean
    pageViews?: boolean
    uniqueVisitors?: boolean
    conversions?: boolean
    conversionValue?: boolean
    conversionRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["conversionMetrics"]>

  export type ConversionMetricsSelectScalar = {
    id?: boolean
    date?: boolean
    source?: boolean
    medium?: boolean
    campaign?: boolean
    landingPage?: boolean
    pageViews?: boolean
    uniqueVisitors?: boolean
    conversions?: boolean
    conversionValue?: boolean
    conversionRate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConversionMetricsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "source" | "medium" | "campaign" | "landingPage" | "pageViews" | "uniqueVisitors" | "conversions" | "conversionValue" | "conversionRate" | "createdAt" | "updatedAt", ExtArgs["result"]["conversionMetrics"]>

  export type $ConversionMetricsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConversionMetrics"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      source: string | null
      medium: string | null
      campaign: string | null
      landingPage: string | null
      pageViews: number
      uniqueVisitors: number
      conversions: number
      conversionValue: number
      conversionRate: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conversionMetrics"]>
    composites: {}
  }

  type ConversionMetricsGetPayload<S extends boolean | null | undefined | ConversionMetricsDefaultArgs> = $Result.GetResult<Prisma.$ConversionMetricsPayload, S>

  type ConversionMetricsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversionMetricsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversionMetricsCountAggregateInputType | true
    }

  export interface ConversionMetricsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConversionMetrics'], meta: { name: 'ConversionMetrics' } }
    /**
     * Find zero or one ConversionMetrics that matches the filter.
     * @param {ConversionMetricsFindUniqueArgs} args - Arguments to find a ConversionMetrics
     * @example
     * // Get one ConversionMetrics
     * const conversionMetrics = await prisma.conversionMetrics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversionMetricsFindUniqueArgs>(args: SelectSubset<T, ConversionMetricsFindUniqueArgs<ExtArgs>>): Prisma__ConversionMetricsClient<$Result.GetResult<Prisma.$ConversionMetricsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConversionMetrics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversionMetricsFindUniqueOrThrowArgs} args - Arguments to find a ConversionMetrics
     * @example
     * // Get one ConversionMetrics
     * const conversionMetrics = await prisma.conversionMetrics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversionMetricsFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversionMetricsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversionMetricsClient<$Result.GetResult<Prisma.$ConversionMetricsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConversionMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversionMetricsFindFirstArgs} args - Arguments to find a ConversionMetrics
     * @example
     * // Get one ConversionMetrics
     * const conversionMetrics = await prisma.conversionMetrics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversionMetricsFindFirstArgs>(args?: SelectSubset<T, ConversionMetricsFindFirstArgs<ExtArgs>>): Prisma__ConversionMetricsClient<$Result.GetResult<Prisma.$ConversionMetricsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConversionMetrics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversionMetricsFindFirstOrThrowArgs} args - Arguments to find a ConversionMetrics
     * @example
     * // Get one ConversionMetrics
     * const conversionMetrics = await prisma.conversionMetrics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversionMetricsFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversionMetricsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversionMetricsClient<$Result.GetResult<Prisma.$ConversionMetricsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConversionMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversionMetricsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConversionMetrics
     * const conversionMetrics = await prisma.conversionMetrics.findMany()
     * 
     * // Get first 10 ConversionMetrics
     * const conversionMetrics = await prisma.conversionMetrics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversionMetricsWithIdOnly = await prisma.conversionMetrics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversionMetricsFindManyArgs>(args?: SelectSubset<T, ConversionMetricsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversionMetricsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConversionMetrics.
     * @param {ConversionMetricsCreateArgs} args - Arguments to create a ConversionMetrics.
     * @example
     * // Create one ConversionMetrics
     * const ConversionMetrics = await prisma.conversionMetrics.create({
     *   data: {
     *     // ... data to create a ConversionMetrics
     *   }
     * })
     * 
     */
    create<T extends ConversionMetricsCreateArgs>(args: SelectSubset<T, ConversionMetricsCreateArgs<ExtArgs>>): Prisma__ConversionMetricsClient<$Result.GetResult<Prisma.$ConversionMetricsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConversionMetrics.
     * @param {ConversionMetricsCreateManyArgs} args - Arguments to create many ConversionMetrics.
     * @example
     * // Create many ConversionMetrics
     * const conversionMetrics = await prisma.conversionMetrics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversionMetricsCreateManyArgs>(args?: SelectSubset<T, ConversionMetricsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConversionMetrics and returns the data saved in the database.
     * @param {ConversionMetricsCreateManyAndReturnArgs} args - Arguments to create many ConversionMetrics.
     * @example
     * // Create many ConversionMetrics
     * const conversionMetrics = await prisma.conversionMetrics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConversionMetrics and only return the `id`
     * const conversionMetricsWithIdOnly = await prisma.conversionMetrics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversionMetricsCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversionMetricsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversionMetricsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConversionMetrics.
     * @param {ConversionMetricsDeleteArgs} args - Arguments to delete one ConversionMetrics.
     * @example
     * // Delete one ConversionMetrics
     * const ConversionMetrics = await prisma.conversionMetrics.delete({
     *   where: {
     *     // ... filter to delete one ConversionMetrics
     *   }
     * })
     * 
     */
    delete<T extends ConversionMetricsDeleteArgs>(args: SelectSubset<T, ConversionMetricsDeleteArgs<ExtArgs>>): Prisma__ConversionMetricsClient<$Result.GetResult<Prisma.$ConversionMetricsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConversionMetrics.
     * @param {ConversionMetricsUpdateArgs} args - Arguments to update one ConversionMetrics.
     * @example
     * // Update one ConversionMetrics
     * const conversionMetrics = await prisma.conversionMetrics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversionMetricsUpdateArgs>(args: SelectSubset<T, ConversionMetricsUpdateArgs<ExtArgs>>): Prisma__ConversionMetricsClient<$Result.GetResult<Prisma.$ConversionMetricsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConversionMetrics.
     * @param {ConversionMetricsDeleteManyArgs} args - Arguments to filter ConversionMetrics to delete.
     * @example
     * // Delete a few ConversionMetrics
     * const { count } = await prisma.conversionMetrics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversionMetricsDeleteManyArgs>(args?: SelectSubset<T, ConversionMetricsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversionMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversionMetricsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConversionMetrics
     * const conversionMetrics = await prisma.conversionMetrics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversionMetricsUpdateManyArgs>(args: SelectSubset<T, ConversionMetricsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversionMetrics and returns the data updated in the database.
     * @param {ConversionMetricsUpdateManyAndReturnArgs} args - Arguments to update many ConversionMetrics.
     * @example
     * // Update many ConversionMetrics
     * const conversionMetrics = await prisma.conversionMetrics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConversionMetrics and only return the `id`
     * const conversionMetricsWithIdOnly = await prisma.conversionMetrics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConversionMetricsUpdateManyAndReturnArgs>(args: SelectSubset<T, ConversionMetricsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversionMetricsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConversionMetrics.
     * @param {ConversionMetricsUpsertArgs} args - Arguments to update or create a ConversionMetrics.
     * @example
     * // Update or create a ConversionMetrics
     * const conversionMetrics = await prisma.conversionMetrics.upsert({
     *   create: {
     *     // ... data to create a ConversionMetrics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConversionMetrics we want to update
     *   }
     * })
     */
    upsert<T extends ConversionMetricsUpsertArgs>(args: SelectSubset<T, ConversionMetricsUpsertArgs<ExtArgs>>): Prisma__ConversionMetricsClient<$Result.GetResult<Prisma.$ConversionMetricsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConversionMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversionMetricsCountArgs} args - Arguments to filter ConversionMetrics to count.
     * @example
     * // Count the number of ConversionMetrics
     * const count = await prisma.conversionMetrics.count({
     *   where: {
     *     // ... the filter for the ConversionMetrics we want to count
     *   }
     * })
    **/
    count<T extends ConversionMetricsCountArgs>(
      args?: Subset<T, ConversionMetricsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversionMetricsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConversionMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversionMetricsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversionMetricsAggregateArgs>(args: Subset<T, ConversionMetricsAggregateArgs>): Prisma.PrismaPromise<GetConversionMetricsAggregateType<T>>

    /**
     * Group by ConversionMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversionMetricsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversionMetricsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversionMetricsGroupByArgs['orderBy'] }
        : { orderBy?: ConversionMetricsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversionMetricsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversionMetricsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConversionMetrics model
   */
  readonly fields: ConversionMetricsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConversionMetrics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversionMetricsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConversionMetrics model
   */
  interface ConversionMetricsFieldRefs {
    readonly id: FieldRef<"ConversionMetrics", 'String'>
    readonly date: FieldRef<"ConversionMetrics", 'DateTime'>
    readonly source: FieldRef<"ConversionMetrics", 'String'>
    readonly medium: FieldRef<"ConversionMetrics", 'String'>
    readonly campaign: FieldRef<"ConversionMetrics", 'String'>
    readonly landingPage: FieldRef<"ConversionMetrics", 'String'>
    readonly pageViews: FieldRef<"ConversionMetrics", 'Int'>
    readonly uniqueVisitors: FieldRef<"ConversionMetrics", 'Int'>
    readonly conversions: FieldRef<"ConversionMetrics", 'Int'>
    readonly conversionValue: FieldRef<"ConversionMetrics", 'Float'>
    readonly conversionRate: FieldRef<"ConversionMetrics", 'Float'>
    readonly createdAt: FieldRef<"ConversionMetrics", 'DateTime'>
    readonly updatedAt: FieldRef<"ConversionMetrics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConversionMetrics findUnique
   */
  export type ConversionMetricsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversionMetrics
     */
    select?: ConversionMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversionMetrics
     */
    omit?: ConversionMetricsOmit<ExtArgs> | null
    /**
     * Filter, which ConversionMetrics to fetch.
     */
    where: ConversionMetricsWhereUniqueInput
  }

  /**
   * ConversionMetrics findUniqueOrThrow
   */
  export type ConversionMetricsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversionMetrics
     */
    select?: ConversionMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversionMetrics
     */
    omit?: ConversionMetricsOmit<ExtArgs> | null
    /**
     * Filter, which ConversionMetrics to fetch.
     */
    where: ConversionMetricsWhereUniqueInput
  }

  /**
   * ConversionMetrics findFirst
   */
  export type ConversionMetricsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversionMetrics
     */
    select?: ConversionMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversionMetrics
     */
    omit?: ConversionMetricsOmit<ExtArgs> | null
    /**
     * Filter, which ConversionMetrics to fetch.
     */
    where?: ConversionMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversionMetrics to fetch.
     */
    orderBy?: ConversionMetricsOrderByWithRelationInput | ConversionMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversionMetrics.
     */
    cursor?: ConversionMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversionMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversionMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversionMetrics.
     */
    distinct?: ConversionMetricsScalarFieldEnum | ConversionMetricsScalarFieldEnum[]
  }

  /**
   * ConversionMetrics findFirstOrThrow
   */
  export type ConversionMetricsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversionMetrics
     */
    select?: ConversionMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversionMetrics
     */
    omit?: ConversionMetricsOmit<ExtArgs> | null
    /**
     * Filter, which ConversionMetrics to fetch.
     */
    where?: ConversionMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversionMetrics to fetch.
     */
    orderBy?: ConversionMetricsOrderByWithRelationInput | ConversionMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversionMetrics.
     */
    cursor?: ConversionMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversionMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversionMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversionMetrics.
     */
    distinct?: ConversionMetricsScalarFieldEnum | ConversionMetricsScalarFieldEnum[]
  }

  /**
   * ConversionMetrics findMany
   */
  export type ConversionMetricsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversionMetrics
     */
    select?: ConversionMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversionMetrics
     */
    omit?: ConversionMetricsOmit<ExtArgs> | null
    /**
     * Filter, which ConversionMetrics to fetch.
     */
    where?: ConversionMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversionMetrics to fetch.
     */
    orderBy?: ConversionMetricsOrderByWithRelationInput | ConversionMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConversionMetrics.
     */
    cursor?: ConversionMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversionMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversionMetrics.
     */
    skip?: number
    distinct?: ConversionMetricsScalarFieldEnum | ConversionMetricsScalarFieldEnum[]
  }

  /**
   * ConversionMetrics create
   */
  export type ConversionMetricsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversionMetrics
     */
    select?: ConversionMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversionMetrics
     */
    omit?: ConversionMetricsOmit<ExtArgs> | null
    /**
     * The data needed to create a ConversionMetrics.
     */
    data: XOR<ConversionMetricsCreateInput, ConversionMetricsUncheckedCreateInput>
  }

  /**
   * ConversionMetrics createMany
   */
  export type ConversionMetricsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConversionMetrics.
     */
    data: ConversionMetricsCreateManyInput | ConversionMetricsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConversionMetrics createManyAndReturn
   */
  export type ConversionMetricsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversionMetrics
     */
    select?: ConversionMetricsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConversionMetrics
     */
    omit?: ConversionMetricsOmit<ExtArgs> | null
    /**
     * The data used to create many ConversionMetrics.
     */
    data: ConversionMetricsCreateManyInput | ConversionMetricsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConversionMetrics update
   */
  export type ConversionMetricsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversionMetrics
     */
    select?: ConversionMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversionMetrics
     */
    omit?: ConversionMetricsOmit<ExtArgs> | null
    /**
     * The data needed to update a ConversionMetrics.
     */
    data: XOR<ConversionMetricsUpdateInput, ConversionMetricsUncheckedUpdateInput>
    /**
     * Choose, which ConversionMetrics to update.
     */
    where: ConversionMetricsWhereUniqueInput
  }

  /**
   * ConversionMetrics updateMany
   */
  export type ConversionMetricsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConversionMetrics.
     */
    data: XOR<ConversionMetricsUpdateManyMutationInput, ConversionMetricsUncheckedUpdateManyInput>
    /**
     * Filter which ConversionMetrics to update
     */
    where?: ConversionMetricsWhereInput
    /**
     * Limit how many ConversionMetrics to update.
     */
    limit?: number
  }

  /**
   * ConversionMetrics updateManyAndReturn
   */
  export type ConversionMetricsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversionMetrics
     */
    select?: ConversionMetricsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConversionMetrics
     */
    omit?: ConversionMetricsOmit<ExtArgs> | null
    /**
     * The data used to update ConversionMetrics.
     */
    data: XOR<ConversionMetricsUpdateManyMutationInput, ConversionMetricsUncheckedUpdateManyInput>
    /**
     * Filter which ConversionMetrics to update
     */
    where?: ConversionMetricsWhereInput
    /**
     * Limit how many ConversionMetrics to update.
     */
    limit?: number
  }

  /**
   * ConversionMetrics upsert
   */
  export type ConversionMetricsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversionMetrics
     */
    select?: ConversionMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversionMetrics
     */
    omit?: ConversionMetricsOmit<ExtArgs> | null
    /**
     * The filter to search for the ConversionMetrics to update in case it exists.
     */
    where: ConversionMetricsWhereUniqueInput
    /**
     * In case the ConversionMetrics found by the `where` argument doesn't exist, create a new ConversionMetrics with this data.
     */
    create: XOR<ConversionMetricsCreateInput, ConversionMetricsUncheckedCreateInput>
    /**
     * In case the ConversionMetrics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversionMetricsUpdateInput, ConversionMetricsUncheckedUpdateInput>
  }

  /**
   * ConversionMetrics delete
   */
  export type ConversionMetricsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversionMetrics
     */
    select?: ConversionMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversionMetrics
     */
    omit?: ConversionMetricsOmit<ExtArgs> | null
    /**
     * Filter which ConversionMetrics to delete.
     */
    where: ConversionMetricsWhereUniqueInput
  }

  /**
   * ConversionMetrics deleteMany
   */
  export type ConversionMetricsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversionMetrics to delete
     */
    where?: ConversionMetricsWhereInput
    /**
     * Limit how many ConversionMetrics to delete.
     */
    limit?: number
  }

  /**
   * ConversionMetrics without action
   */
  export type ConversionMetricsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversionMetrics
     */
    select?: ConversionMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversionMetrics
     */
    omit?: ConversionMetricsOmit<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    name: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    color: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    color?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    name: string
    color: string | null
    createdAt: Date
    updatedAt: Date
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    campaigns?: boolean | Tag$campaignsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    name?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "color" | "createdAt" | "updatedAt", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    campaigns?: boolean | Tag$campaignsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      campaigns: Prisma.$TagsOnCampaignsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      color: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    campaigns<T extends Tag$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagsOnCampaignsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly color: FieldRef<"Tag", 'String'>
    readonly createdAt: FieldRef<"Tag", 'DateTime'>
    readonly updatedAt: FieldRef<"Tag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.campaigns
   */
  export type Tag$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagsOnCampaigns
     */
    select?: TagsOnCampaignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagsOnCampaigns
     */
    omit?: TagsOnCampaignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsOnCampaignsInclude<ExtArgs> | null
    where?: TagsOnCampaignsWhereInput
    orderBy?: TagsOnCampaignsOrderByWithRelationInput | TagsOnCampaignsOrderByWithRelationInput[]
    cursor?: TagsOnCampaignsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagsOnCampaignsScalarFieldEnum | TagsOnCampaignsScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model TagsOnCampaigns
   */

  export type AggregateTagsOnCampaigns = {
    _count: TagsOnCampaignsCountAggregateOutputType | null
    _min: TagsOnCampaignsMinAggregateOutputType | null
    _max: TagsOnCampaignsMaxAggregateOutputType | null
  }

  export type TagsOnCampaignsMinAggregateOutputType = {
    tagId: string | null
    campaignId: string | null
    assignedAt: Date | null
  }

  export type TagsOnCampaignsMaxAggregateOutputType = {
    tagId: string | null
    campaignId: string | null
    assignedAt: Date | null
  }

  export type TagsOnCampaignsCountAggregateOutputType = {
    tagId: number
    campaignId: number
    assignedAt: number
    _all: number
  }


  export type TagsOnCampaignsMinAggregateInputType = {
    tagId?: true
    campaignId?: true
    assignedAt?: true
  }

  export type TagsOnCampaignsMaxAggregateInputType = {
    tagId?: true
    campaignId?: true
    assignedAt?: true
  }

  export type TagsOnCampaignsCountAggregateInputType = {
    tagId?: true
    campaignId?: true
    assignedAt?: true
    _all?: true
  }

  export type TagsOnCampaignsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TagsOnCampaigns to aggregate.
     */
    where?: TagsOnCampaignsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagsOnCampaigns to fetch.
     */
    orderBy?: TagsOnCampaignsOrderByWithRelationInput | TagsOnCampaignsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagsOnCampaignsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagsOnCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagsOnCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TagsOnCampaigns
    **/
    _count?: true | TagsOnCampaignsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagsOnCampaignsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagsOnCampaignsMaxAggregateInputType
  }

  export type GetTagsOnCampaignsAggregateType<T extends TagsOnCampaignsAggregateArgs> = {
        [P in keyof T & keyof AggregateTagsOnCampaigns]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTagsOnCampaigns[P]>
      : GetScalarType<T[P], AggregateTagsOnCampaigns[P]>
  }




  export type TagsOnCampaignsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagsOnCampaignsWhereInput
    orderBy?: TagsOnCampaignsOrderByWithAggregationInput | TagsOnCampaignsOrderByWithAggregationInput[]
    by: TagsOnCampaignsScalarFieldEnum[] | TagsOnCampaignsScalarFieldEnum
    having?: TagsOnCampaignsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagsOnCampaignsCountAggregateInputType | true
    _min?: TagsOnCampaignsMinAggregateInputType
    _max?: TagsOnCampaignsMaxAggregateInputType
  }

  export type TagsOnCampaignsGroupByOutputType = {
    tagId: string
    campaignId: string
    assignedAt: Date
    _count: TagsOnCampaignsCountAggregateOutputType | null
    _min: TagsOnCampaignsMinAggregateOutputType | null
    _max: TagsOnCampaignsMaxAggregateOutputType | null
  }

  type GetTagsOnCampaignsGroupByPayload<T extends TagsOnCampaignsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagsOnCampaignsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagsOnCampaignsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagsOnCampaignsGroupByOutputType[P]>
            : GetScalarType<T[P], TagsOnCampaignsGroupByOutputType[P]>
        }
      >
    >


  export type TagsOnCampaignsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tagId?: boolean
    campaignId?: boolean
    assignedAt?: boolean
    tag?: boolean | TagDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tagsOnCampaigns"]>

  export type TagsOnCampaignsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tagId?: boolean
    campaignId?: boolean
    assignedAt?: boolean
    tag?: boolean | TagDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tagsOnCampaigns"]>

  export type TagsOnCampaignsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tagId?: boolean
    campaignId?: boolean
    assignedAt?: boolean
    tag?: boolean | TagDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tagsOnCampaigns"]>

  export type TagsOnCampaignsSelectScalar = {
    tagId?: boolean
    campaignId?: boolean
    assignedAt?: boolean
  }

  export type TagsOnCampaignsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"tagId" | "campaignId" | "assignedAt", ExtArgs["result"]["tagsOnCampaigns"]>
  export type TagsOnCampaignsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tag?: boolean | TagDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type TagsOnCampaignsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tag?: boolean | TagDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }
  export type TagsOnCampaignsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tag?: boolean | TagDefaultArgs<ExtArgs>
    campaign?: boolean | CampaignDefaultArgs<ExtArgs>
  }

  export type $TagsOnCampaignsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TagsOnCampaigns"
    objects: {
      tag: Prisma.$TagPayload<ExtArgs>
      campaign: Prisma.$CampaignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      tagId: string
      campaignId: string
      assignedAt: Date
    }, ExtArgs["result"]["tagsOnCampaigns"]>
    composites: {}
  }

  type TagsOnCampaignsGetPayload<S extends boolean | null | undefined | TagsOnCampaignsDefaultArgs> = $Result.GetResult<Prisma.$TagsOnCampaignsPayload, S>

  type TagsOnCampaignsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagsOnCampaignsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagsOnCampaignsCountAggregateInputType | true
    }

  export interface TagsOnCampaignsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TagsOnCampaigns'], meta: { name: 'TagsOnCampaigns' } }
    /**
     * Find zero or one TagsOnCampaigns that matches the filter.
     * @param {TagsOnCampaignsFindUniqueArgs} args - Arguments to find a TagsOnCampaigns
     * @example
     * // Get one TagsOnCampaigns
     * const tagsOnCampaigns = await prisma.tagsOnCampaigns.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagsOnCampaignsFindUniqueArgs>(args: SelectSubset<T, TagsOnCampaignsFindUniqueArgs<ExtArgs>>): Prisma__TagsOnCampaignsClient<$Result.GetResult<Prisma.$TagsOnCampaignsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TagsOnCampaigns that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagsOnCampaignsFindUniqueOrThrowArgs} args - Arguments to find a TagsOnCampaigns
     * @example
     * // Get one TagsOnCampaigns
     * const tagsOnCampaigns = await prisma.tagsOnCampaigns.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagsOnCampaignsFindUniqueOrThrowArgs>(args: SelectSubset<T, TagsOnCampaignsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagsOnCampaignsClient<$Result.GetResult<Prisma.$TagsOnCampaignsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TagsOnCampaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsOnCampaignsFindFirstArgs} args - Arguments to find a TagsOnCampaigns
     * @example
     * // Get one TagsOnCampaigns
     * const tagsOnCampaigns = await prisma.tagsOnCampaigns.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagsOnCampaignsFindFirstArgs>(args?: SelectSubset<T, TagsOnCampaignsFindFirstArgs<ExtArgs>>): Prisma__TagsOnCampaignsClient<$Result.GetResult<Prisma.$TagsOnCampaignsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TagsOnCampaigns that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsOnCampaignsFindFirstOrThrowArgs} args - Arguments to find a TagsOnCampaigns
     * @example
     * // Get one TagsOnCampaigns
     * const tagsOnCampaigns = await prisma.tagsOnCampaigns.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagsOnCampaignsFindFirstOrThrowArgs>(args?: SelectSubset<T, TagsOnCampaignsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagsOnCampaignsClient<$Result.GetResult<Prisma.$TagsOnCampaignsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TagsOnCampaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsOnCampaignsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TagsOnCampaigns
     * const tagsOnCampaigns = await prisma.tagsOnCampaigns.findMany()
     * 
     * // Get first 10 TagsOnCampaigns
     * const tagsOnCampaigns = await prisma.tagsOnCampaigns.findMany({ take: 10 })
     * 
     * // Only select the `tagId`
     * const tagsOnCampaignsWithTagIdOnly = await prisma.tagsOnCampaigns.findMany({ select: { tagId: true } })
     * 
     */
    findMany<T extends TagsOnCampaignsFindManyArgs>(args?: SelectSubset<T, TagsOnCampaignsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagsOnCampaignsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TagsOnCampaigns.
     * @param {TagsOnCampaignsCreateArgs} args - Arguments to create a TagsOnCampaigns.
     * @example
     * // Create one TagsOnCampaigns
     * const TagsOnCampaigns = await prisma.tagsOnCampaigns.create({
     *   data: {
     *     // ... data to create a TagsOnCampaigns
     *   }
     * })
     * 
     */
    create<T extends TagsOnCampaignsCreateArgs>(args: SelectSubset<T, TagsOnCampaignsCreateArgs<ExtArgs>>): Prisma__TagsOnCampaignsClient<$Result.GetResult<Prisma.$TagsOnCampaignsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TagsOnCampaigns.
     * @param {TagsOnCampaignsCreateManyArgs} args - Arguments to create many TagsOnCampaigns.
     * @example
     * // Create many TagsOnCampaigns
     * const tagsOnCampaigns = await prisma.tagsOnCampaigns.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagsOnCampaignsCreateManyArgs>(args?: SelectSubset<T, TagsOnCampaignsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TagsOnCampaigns and returns the data saved in the database.
     * @param {TagsOnCampaignsCreateManyAndReturnArgs} args - Arguments to create many TagsOnCampaigns.
     * @example
     * // Create many TagsOnCampaigns
     * const tagsOnCampaigns = await prisma.tagsOnCampaigns.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TagsOnCampaigns and only return the `tagId`
     * const tagsOnCampaignsWithTagIdOnly = await prisma.tagsOnCampaigns.createManyAndReturn({
     *   select: { tagId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagsOnCampaignsCreateManyAndReturnArgs>(args?: SelectSubset<T, TagsOnCampaignsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagsOnCampaignsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TagsOnCampaigns.
     * @param {TagsOnCampaignsDeleteArgs} args - Arguments to delete one TagsOnCampaigns.
     * @example
     * // Delete one TagsOnCampaigns
     * const TagsOnCampaigns = await prisma.tagsOnCampaigns.delete({
     *   where: {
     *     // ... filter to delete one TagsOnCampaigns
     *   }
     * })
     * 
     */
    delete<T extends TagsOnCampaignsDeleteArgs>(args: SelectSubset<T, TagsOnCampaignsDeleteArgs<ExtArgs>>): Prisma__TagsOnCampaignsClient<$Result.GetResult<Prisma.$TagsOnCampaignsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TagsOnCampaigns.
     * @param {TagsOnCampaignsUpdateArgs} args - Arguments to update one TagsOnCampaigns.
     * @example
     * // Update one TagsOnCampaigns
     * const tagsOnCampaigns = await prisma.tagsOnCampaigns.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagsOnCampaignsUpdateArgs>(args: SelectSubset<T, TagsOnCampaignsUpdateArgs<ExtArgs>>): Prisma__TagsOnCampaignsClient<$Result.GetResult<Prisma.$TagsOnCampaignsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TagsOnCampaigns.
     * @param {TagsOnCampaignsDeleteManyArgs} args - Arguments to filter TagsOnCampaigns to delete.
     * @example
     * // Delete a few TagsOnCampaigns
     * const { count } = await prisma.tagsOnCampaigns.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagsOnCampaignsDeleteManyArgs>(args?: SelectSubset<T, TagsOnCampaignsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TagsOnCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsOnCampaignsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TagsOnCampaigns
     * const tagsOnCampaigns = await prisma.tagsOnCampaigns.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagsOnCampaignsUpdateManyArgs>(args: SelectSubset<T, TagsOnCampaignsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TagsOnCampaigns and returns the data updated in the database.
     * @param {TagsOnCampaignsUpdateManyAndReturnArgs} args - Arguments to update many TagsOnCampaigns.
     * @example
     * // Update many TagsOnCampaigns
     * const tagsOnCampaigns = await prisma.tagsOnCampaigns.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TagsOnCampaigns and only return the `tagId`
     * const tagsOnCampaignsWithTagIdOnly = await prisma.tagsOnCampaigns.updateManyAndReturn({
     *   select: { tagId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagsOnCampaignsUpdateManyAndReturnArgs>(args: SelectSubset<T, TagsOnCampaignsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagsOnCampaignsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TagsOnCampaigns.
     * @param {TagsOnCampaignsUpsertArgs} args - Arguments to update or create a TagsOnCampaigns.
     * @example
     * // Update or create a TagsOnCampaigns
     * const tagsOnCampaigns = await prisma.tagsOnCampaigns.upsert({
     *   create: {
     *     // ... data to create a TagsOnCampaigns
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TagsOnCampaigns we want to update
     *   }
     * })
     */
    upsert<T extends TagsOnCampaignsUpsertArgs>(args: SelectSubset<T, TagsOnCampaignsUpsertArgs<ExtArgs>>): Prisma__TagsOnCampaignsClient<$Result.GetResult<Prisma.$TagsOnCampaignsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TagsOnCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsOnCampaignsCountArgs} args - Arguments to filter TagsOnCampaigns to count.
     * @example
     * // Count the number of TagsOnCampaigns
     * const count = await prisma.tagsOnCampaigns.count({
     *   where: {
     *     // ... the filter for the TagsOnCampaigns we want to count
     *   }
     * })
    **/
    count<T extends TagsOnCampaignsCountArgs>(
      args?: Subset<T, TagsOnCampaignsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagsOnCampaignsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TagsOnCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsOnCampaignsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagsOnCampaignsAggregateArgs>(args: Subset<T, TagsOnCampaignsAggregateArgs>): Prisma.PrismaPromise<GetTagsOnCampaignsAggregateType<T>>

    /**
     * Group by TagsOnCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsOnCampaignsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagsOnCampaignsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagsOnCampaignsGroupByArgs['orderBy'] }
        : { orderBy?: TagsOnCampaignsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagsOnCampaignsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagsOnCampaignsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TagsOnCampaigns model
   */
  readonly fields: TagsOnCampaignsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TagsOnCampaigns.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagsOnCampaignsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    campaign<T extends CampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CampaignDefaultArgs<ExtArgs>>): Prisma__CampaignClient<$Result.GetResult<Prisma.$CampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TagsOnCampaigns model
   */
  interface TagsOnCampaignsFieldRefs {
    readonly tagId: FieldRef<"TagsOnCampaigns", 'String'>
    readonly campaignId: FieldRef<"TagsOnCampaigns", 'String'>
    readonly assignedAt: FieldRef<"TagsOnCampaigns", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TagsOnCampaigns findUnique
   */
  export type TagsOnCampaignsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagsOnCampaigns
     */
    select?: TagsOnCampaignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagsOnCampaigns
     */
    omit?: TagsOnCampaignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsOnCampaignsInclude<ExtArgs> | null
    /**
     * Filter, which TagsOnCampaigns to fetch.
     */
    where: TagsOnCampaignsWhereUniqueInput
  }

  /**
   * TagsOnCampaigns findUniqueOrThrow
   */
  export type TagsOnCampaignsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagsOnCampaigns
     */
    select?: TagsOnCampaignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagsOnCampaigns
     */
    omit?: TagsOnCampaignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsOnCampaignsInclude<ExtArgs> | null
    /**
     * Filter, which TagsOnCampaigns to fetch.
     */
    where: TagsOnCampaignsWhereUniqueInput
  }

  /**
   * TagsOnCampaigns findFirst
   */
  export type TagsOnCampaignsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagsOnCampaigns
     */
    select?: TagsOnCampaignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagsOnCampaigns
     */
    omit?: TagsOnCampaignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsOnCampaignsInclude<ExtArgs> | null
    /**
     * Filter, which TagsOnCampaigns to fetch.
     */
    where?: TagsOnCampaignsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagsOnCampaigns to fetch.
     */
    orderBy?: TagsOnCampaignsOrderByWithRelationInput | TagsOnCampaignsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TagsOnCampaigns.
     */
    cursor?: TagsOnCampaignsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagsOnCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagsOnCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TagsOnCampaigns.
     */
    distinct?: TagsOnCampaignsScalarFieldEnum | TagsOnCampaignsScalarFieldEnum[]
  }

  /**
   * TagsOnCampaigns findFirstOrThrow
   */
  export type TagsOnCampaignsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagsOnCampaigns
     */
    select?: TagsOnCampaignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagsOnCampaigns
     */
    omit?: TagsOnCampaignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsOnCampaignsInclude<ExtArgs> | null
    /**
     * Filter, which TagsOnCampaigns to fetch.
     */
    where?: TagsOnCampaignsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagsOnCampaigns to fetch.
     */
    orderBy?: TagsOnCampaignsOrderByWithRelationInput | TagsOnCampaignsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TagsOnCampaigns.
     */
    cursor?: TagsOnCampaignsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagsOnCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagsOnCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TagsOnCampaigns.
     */
    distinct?: TagsOnCampaignsScalarFieldEnum | TagsOnCampaignsScalarFieldEnum[]
  }

  /**
   * TagsOnCampaigns findMany
   */
  export type TagsOnCampaignsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagsOnCampaigns
     */
    select?: TagsOnCampaignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagsOnCampaigns
     */
    omit?: TagsOnCampaignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsOnCampaignsInclude<ExtArgs> | null
    /**
     * Filter, which TagsOnCampaigns to fetch.
     */
    where?: TagsOnCampaignsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagsOnCampaigns to fetch.
     */
    orderBy?: TagsOnCampaignsOrderByWithRelationInput | TagsOnCampaignsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TagsOnCampaigns.
     */
    cursor?: TagsOnCampaignsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagsOnCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagsOnCampaigns.
     */
    skip?: number
    distinct?: TagsOnCampaignsScalarFieldEnum | TagsOnCampaignsScalarFieldEnum[]
  }

  /**
   * TagsOnCampaigns create
   */
  export type TagsOnCampaignsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagsOnCampaigns
     */
    select?: TagsOnCampaignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagsOnCampaigns
     */
    omit?: TagsOnCampaignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsOnCampaignsInclude<ExtArgs> | null
    /**
     * The data needed to create a TagsOnCampaigns.
     */
    data: XOR<TagsOnCampaignsCreateInput, TagsOnCampaignsUncheckedCreateInput>
  }

  /**
   * TagsOnCampaigns createMany
   */
  export type TagsOnCampaignsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TagsOnCampaigns.
     */
    data: TagsOnCampaignsCreateManyInput | TagsOnCampaignsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TagsOnCampaigns createManyAndReturn
   */
  export type TagsOnCampaignsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagsOnCampaigns
     */
    select?: TagsOnCampaignsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TagsOnCampaigns
     */
    omit?: TagsOnCampaignsOmit<ExtArgs> | null
    /**
     * The data used to create many TagsOnCampaigns.
     */
    data: TagsOnCampaignsCreateManyInput | TagsOnCampaignsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsOnCampaignsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TagsOnCampaigns update
   */
  export type TagsOnCampaignsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagsOnCampaigns
     */
    select?: TagsOnCampaignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagsOnCampaigns
     */
    omit?: TagsOnCampaignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsOnCampaignsInclude<ExtArgs> | null
    /**
     * The data needed to update a TagsOnCampaigns.
     */
    data: XOR<TagsOnCampaignsUpdateInput, TagsOnCampaignsUncheckedUpdateInput>
    /**
     * Choose, which TagsOnCampaigns to update.
     */
    where: TagsOnCampaignsWhereUniqueInput
  }

  /**
   * TagsOnCampaigns updateMany
   */
  export type TagsOnCampaignsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TagsOnCampaigns.
     */
    data: XOR<TagsOnCampaignsUpdateManyMutationInput, TagsOnCampaignsUncheckedUpdateManyInput>
    /**
     * Filter which TagsOnCampaigns to update
     */
    where?: TagsOnCampaignsWhereInput
    /**
     * Limit how many TagsOnCampaigns to update.
     */
    limit?: number
  }

  /**
   * TagsOnCampaigns updateManyAndReturn
   */
  export type TagsOnCampaignsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagsOnCampaigns
     */
    select?: TagsOnCampaignsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TagsOnCampaigns
     */
    omit?: TagsOnCampaignsOmit<ExtArgs> | null
    /**
     * The data used to update TagsOnCampaigns.
     */
    data: XOR<TagsOnCampaignsUpdateManyMutationInput, TagsOnCampaignsUncheckedUpdateManyInput>
    /**
     * Filter which TagsOnCampaigns to update
     */
    where?: TagsOnCampaignsWhereInput
    /**
     * Limit how many TagsOnCampaigns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsOnCampaignsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TagsOnCampaigns upsert
   */
  export type TagsOnCampaignsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagsOnCampaigns
     */
    select?: TagsOnCampaignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagsOnCampaigns
     */
    omit?: TagsOnCampaignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsOnCampaignsInclude<ExtArgs> | null
    /**
     * The filter to search for the TagsOnCampaigns to update in case it exists.
     */
    where: TagsOnCampaignsWhereUniqueInput
    /**
     * In case the TagsOnCampaigns found by the `where` argument doesn't exist, create a new TagsOnCampaigns with this data.
     */
    create: XOR<TagsOnCampaignsCreateInput, TagsOnCampaignsUncheckedCreateInput>
    /**
     * In case the TagsOnCampaigns was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagsOnCampaignsUpdateInput, TagsOnCampaignsUncheckedUpdateInput>
  }

  /**
   * TagsOnCampaigns delete
   */
  export type TagsOnCampaignsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagsOnCampaigns
     */
    select?: TagsOnCampaignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagsOnCampaigns
     */
    omit?: TagsOnCampaignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsOnCampaignsInclude<ExtArgs> | null
    /**
     * Filter which TagsOnCampaigns to delete.
     */
    where: TagsOnCampaignsWhereUniqueInput
  }

  /**
   * TagsOnCampaigns deleteMany
   */
  export type TagsOnCampaignsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TagsOnCampaigns to delete
     */
    where?: TagsOnCampaignsWhereInput
    /**
     * Limit how many TagsOnCampaigns to delete.
     */
    limit?: number
  }

  /**
   * TagsOnCampaigns without action
   */
  export type TagsOnCampaignsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagsOnCampaigns
     */
    select?: TagsOnCampaignsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagsOnCampaigns
     */
    omit?: TagsOnCampaignsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsOnCampaignsInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    type: $Enums.NotificationType | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    type: $Enums.NotificationType | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    message: number
    type: number
    isRead: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    title: string
    message: string
    type: $Enums.NotificationType
    isRead: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "message" | "type" | "isRead" | "createdAt" | "updatedAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      message: string
      type: $Enums.NotificationType
      isRead: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Setting
   */

  export type AggregateSetting = {
    _count: SettingCountAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  export type SettingMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettingMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettingCountAggregateOutputType = {
    id: number
    key: number
    value: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SettingMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettingMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettingCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Setting to aggregate.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingMaxAggregateInputType
  }

  export type GetSettingAggregateType<T extends SettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSetting[P]>
      : GetScalarType<T[P], AggregateSetting[P]>
  }




  export type SettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingWhereInput
    orderBy?: SettingOrderByWithAggregationInput | SettingOrderByWithAggregationInput[]
    by: SettingScalarFieldEnum[] | SettingScalarFieldEnum
    having?: SettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingCountAggregateInputType | true
    _min?: SettingMinAggregateInputType
    _max?: SettingMaxAggregateInputType
  }

  export type SettingGroupByOutputType = {
    id: string
    key: string
    value: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: SettingCountAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  type GetSettingGroupByPayload<T extends SettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingGroupByOutputType[P]>
            : GetScalarType<T[P], SettingGroupByOutputType[P]>
        }
      >
    >


  export type SettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["setting"]>

  export type SettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["setting"]>

  export type SettingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["setting"]>

  export type SettingSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["setting"]>

  export type $SettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Setting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["setting"]>
    composites: {}
  }

  type SettingGetPayload<S extends boolean | null | undefined | SettingDefaultArgs> = $Result.GetResult<Prisma.$SettingPayload, S>

  type SettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingCountAggregateInputType | true
    }

  export interface SettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Setting'], meta: { name: 'Setting' } }
    /**
     * Find zero or one Setting that matches the filter.
     * @param {SettingFindUniqueArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingFindUniqueArgs>(args: SelectSubset<T, SettingFindUniqueArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Setting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettingFindUniqueOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Setting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingFindFirstArgs>(args?: SelectSubset<T, SettingFindFirstArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Setting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.setting.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.setting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingWithIdOnly = await prisma.setting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingFindManyArgs>(args?: SelectSubset<T, SettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Setting.
     * @param {SettingCreateArgs} args - Arguments to create a Setting.
     * @example
     * // Create one Setting
     * const Setting = await prisma.setting.create({
     *   data: {
     *     // ... data to create a Setting
     *   }
     * })
     * 
     */
    create<T extends SettingCreateArgs>(args: SelectSubset<T, SettingCreateArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Settings.
     * @param {SettingCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const setting = await prisma.setting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingCreateManyArgs>(args?: SelectSubset<T, SettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Settings and returns the data saved in the database.
     * @param {SettingCreateManyAndReturnArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const setting = await prisma.setting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Settings and only return the `id`
     * const settingWithIdOnly = await prisma.setting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SettingCreateManyAndReturnArgs>(args?: SelectSubset<T, SettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Setting.
     * @param {SettingDeleteArgs} args - Arguments to delete one Setting.
     * @example
     * // Delete one Setting
     * const Setting = await prisma.setting.delete({
     *   where: {
     *     // ... filter to delete one Setting
     *   }
     * })
     * 
     */
    delete<T extends SettingDeleteArgs>(args: SelectSubset<T, SettingDeleteArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Setting.
     * @param {SettingUpdateArgs} args - Arguments to update one Setting.
     * @example
     * // Update one Setting
     * const setting = await prisma.setting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingUpdateArgs>(args: SelectSubset<T, SettingUpdateArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Settings.
     * @param {SettingDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.setting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingDeleteManyArgs>(args?: SelectSubset<T, SettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const setting = await prisma.setting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingUpdateManyArgs>(args: SelectSubset<T, SettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings and returns the data updated in the database.
     * @param {SettingUpdateManyAndReturnArgs} args - Arguments to update many Settings.
     * @example
     * // Update many Settings
     * const setting = await prisma.setting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Settings and only return the `id`
     * const settingWithIdOnly = await prisma.setting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SettingUpdateManyAndReturnArgs>(args: SelectSubset<T, SettingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Setting.
     * @param {SettingUpsertArgs} args - Arguments to update or create a Setting.
     * @example
     * // Update or create a Setting
     * const setting = await prisma.setting.upsert({
     *   create: {
     *     // ... data to create a Setting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Setting we want to update
     *   }
     * })
     */
    upsert<T extends SettingUpsertArgs>(args: SelectSubset<T, SettingUpsertArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.setting.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingCountArgs>(
      args?: Subset<T, SettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingAggregateArgs>(args: Subset<T, SettingAggregateArgs>): Prisma.PrismaPromise<GetSettingAggregateType<T>>

    /**
     * Group by Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingGroupByArgs['orderBy'] }
        : { orderBy?: SettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Setting model
   */
  readonly fields: SettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Setting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Setting model
   */
  interface SettingFieldRefs {
    readonly id: FieldRef<"Setting", 'String'>
    readonly key: FieldRef<"Setting", 'String'>
    readonly value: FieldRef<"Setting", 'String'>
    readonly description: FieldRef<"Setting", 'String'>
    readonly createdAt: FieldRef<"Setting", 'DateTime'>
    readonly updatedAt: FieldRef<"Setting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Setting findUnique
   */
  export type SettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting findUniqueOrThrow
   */
  export type SettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting findFirst
   */
  export type SettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting findFirstOrThrow
   */
  export type SettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting findMany
   */
  export type SettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting create
   */
  export type SettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data needed to create a Setting.
     */
    data: XOR<SettingCreateInput, SettingUncheckedCreateInput>
  }

  /**
   * Setting createMany
   */
  export type SettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settings.
     */
    data: SettingCreateManyInput | SettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Setting createManyAndReturn
   */
  export type SettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data used to create many Settings.
     */
    data: SettingCreateManyInput | SettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Setting update
   */
  export type SettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data needed to update a Setting.
     */
    data: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
    /**
     * Choose, which Setting to update.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting updateMany
   */
  export type SettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingUpdateManyMutationInput, SettingUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Setting updateManyAndReturn
   */
  export type SettingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingUpdateManyMutationInput, SettingUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Setting upsert
   */
  export type SettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The filter to search for the Setting to update in case it exists.
     */
    where: SettingWhereUniqueInput
    /**
     * In case the Setting found by the `where` argument doesn't exist, create a new Setting with this data.
     */
    create: XOR<SettingCreateInput, SettingUncheckedCreateInput>
    /**
     * In case the Setting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
  }

  /**
   * Setting delete
   */
  export type SettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter which Setting to delete.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting deleteMany
   */
  export type SettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingWhereInput
    /**
     * Limit how many Settings to delete.
     */
    limit?: number
  }

  /**
   * Setting without action
   */
  export type SettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const MetaAccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    metaAccountId: 'metaAccountId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    tokenExpiresAt: 'tokenExpiresAt',
    businessName: 'businessName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MetaAccountScalarFieldEnum = (typeof MetaAccountScalarFieldEnum)[keyof typeof MetaAccountScalarFieldEnum]


  export const AdAccountScalarFieldEnum: {
    id: 'id',
    metaAccountId: 'metaAccountId',
    adAccountId: 'adAccountId',
    name: 'name',
    currency: 'currency',
    timezone: 'timezone',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdAccountScalarFieldEnum = (typeof AdAccountScalarFieldEnum)[keyof typeof AdAccountScalarFieldEnum]


  export const CampaignScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    metaAccountId: 'metaAccountId',
    adAccountId: 'adAccountId',
    campaignId: 'campaignId',
    name: 'name',
    objective: 'objective',
    status: 'status',
    budget: 'budget',
    budgetType: 'budgetType',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    clinicId: 'clinicId',
    productId: 'productId'
  };

  export type CampaignScalarFieldEnum = (typeof CampaignScalarFieldEnum)[keyof typeof CampaignScalarFieldEnum]


  export const CampaignMetricsScalarFieldEnum: {
    id: 'id',
    campaignId: 'campaignId',
    date: 'date',
    impressions: 'impressions',
    clicks: 'clicks',
    reach: 'reach',
    spend: 'spend',
    conversions: 'conversions',
    costPerResult: 'costPerResult',
    ctr: 'ctr',
    cpc: 'cpc',
    cpm: 'cpm',
    frequency: 'frequency'
  };

  export type CampaignMetricsScalarFieldEnum = (typeof CampaignMetricsScalarFieldEnum)[keyof typeof CampaignMetricsScalarFieldEnum]


  export const AdSetScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    campaignId: 'campaignId',
    metaAccountId: 'metaAccountId',
    adSetId: 'adSetId',
    name: 'name',
    status: 'status',
    budget: 'budget',
    budgetType: 'budgetType',
    bidStrategy: 'bidStrategy',
    bidAmount: 'bidAmount',
    startDate: 'startDate',
    endDate: 'endDate',
    targeting: 'targeting',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdSetScalarFieldEnum = (typeof AdSetScalarFieldEnum)[keyof typeof AdSetScalarFieldEnum]


  export const AdSetMetricsScalarFieldEnum: {
    id: 'id',
    adSetId: 'adSetId',
    date: 'date',
    impressions: 'impressions',
    clicks: 'clicks',
    reach: 'reach',
    spend: 'spend',
    conversions: 'conversions',
    costPerResult: 'costPerResult',
    ctr: 'ctr',
    cpc: 'cpc',
    cpm: 'cpm',
    frequency: 'frequency'
  };

  export type AdSetMetricsScalarFieldEnum = (typeof AdSetMetricsScalarFieldEnum)[keyof typeof AdSetMetricsScalarFieldEnum]


  export const AdScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    adSetId: 'adSetId',
    metaAccountId: 'metaAccountId',
    adId: 'adId',
    name: 'name',
    status: 'status',
    headline: 'headline',
    description: 'description',
    creativeType: 'creativeType',
    imageUrl: 'imageUrl',
    videoUrl: 'videoUrl',
    destinationUrl: 'destinationUrl',
    callToAction: 'callToAction',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdScalarFieldEnum = (typeof AdScalarFieldEnum)[keyof typeof AdScalarFieldEnum]


  export const AdMetricsScalarFieldEnum: {
    id: 'id',
    adId: 'adId',
    date: 'date',
    impressions: 'impressions',
    clicks: 'clicks',
    reach: 'reach',
    spend: 'spend',
    conversions: 'conversions',
    costPerResult: 'costPerResult',
    ctr: 'ctr',
    cpc: 'cpc',
    cpm: 'cpm',
    frequency: 'frequency',
    engagements: 'engagements',
    shares: 'shares',
    comments: 'comments',
    saves: 'saves'
  };

  export type AdMetricsScalarFieldEnum = (typeof AdMetricsScalarFieldEnum)[keyof typeof AdMetricsScalarFieldEnum]


  export const ScheduleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    adId: 'adId',
    title: 'title',
    startDate: 'startDate',
    endDate: 'endDate',
    status: 'status',
    priority: 'priority',
    category: 'category',
    clinicId: 'clinicId',
    productId: 'productId',
    recurrence: 'recurrence',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScheduleScalarFieldEnum = (typeof ScheduleScalarFieldEnum)[keyof typeof ScheduleScalarFieldEnum]


  export const AdsPlannerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    objective: 'objective',
    budgetType: 'budgetType',
    budgetAmount: 'budgetAmount',
    whatsappNumber: 'whatsappNumber',
    startDate: 'startDate',
    endDate: 'endDate',
    location: 'location',
    minAge: 'minAge',
    maxAge: 'maxAge',
    gender: 'gender',
    detailTargeting: 'detailTargeting',
    videoUrl: 'videoUrl',
    websiteUrl: 'websiteUrl',
    primaryText: 'primaryText',
    headline: 'headline',
    ctaName: 'ctaName',
    ctaText: 'ctaText',
    preFilledMessage: 'preFilledMessage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdsPlannerScalarFieldEnum = (typeof AdsPlannerScalarFieldEnum)[keyof typeof AdsPlannerScalarFieldEnum]


  export const PlannerItemScalarFieldEnum: {
    id: 'id',
    plannerId: 'plannerId',
    title: 'title',
    description: 'description',
    platform: 'platform',
    format: 'format',
    budget: 'budget',
    startDate: 'startDate',
    endDate: 'endDate',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlannerItemScalarFieldEnum = (typeof PlannerItemScalarFieldEnum)[keyof typeof PlannerItemScalarFieldEnum]


  export const SocialMediaAccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    platform: 'platform',
    accountName: 'accountName',
    accountId: 'accountId',
    followers: 'followers',
    accessToken: 'accessToken',
    tokenExpiresAt: 'tokenExpiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SocialMediaAccountScalarFieldEnum = (typeof SocialMediaAccountScalarFieldEnum)[keyof typeof SocialMediaAccountScalarFieldEnum]


  export const PlatformMetricsScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    date: 'date',
    followers: 'followers',
    following: 'following',
    posts: 'posts',
    impressions: 'impressions',
    reach: 'reach',
    profileViews: 'profileViews',
    websiteClicks: 'websiteClicks',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlatformMetricsScalarFieldEnum = (typeof PlatformMetricsScalarFieldEnum)[keyof typeof PlatformMetricsScalarFieldEnum]


  export const EngagementMetricsScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    date: 'date',
    likes: 'likes',
    comments: 'comments',
    shares: 'shares',
    saves: 'saves',
    clicks: 'clicks',
    engagementRate: 'engagementRate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EngagementMetricsScalarFieldEnum = (typeof EngagementMetricsScalarFieldEnum)[keyof typeof EngagementMetricsScalarFieldEnum]


  export const InfluencerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    accountId: 'accountId',
    name: 'name',
    contactInfo: 'contactInfo',
    reach: 'reach',
    engagementRate: 'engagementRate',
    niche: 'niche',
    cost: 'cost',
    status: 'status',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InfluencerScalarFieldEnum = (typeof InfluencerScalarFieldEnum)[keyof typeof InfluencerScalarFieldEnum]


  export const InfluencerCampaignsScalarFieldEnum: {
    id: 'id',
    influencerId: 'influencerId',
    name: 'name',
    startDate: 'startDate',
    endDate: 'endDate',
    budget: 'budget',
    results: 'results',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InfluencerCampaignsScalarFieldEnum = (typeof InfluencerCampaignsScalarFieldEnum)[keyof typeof InfluencerCampaignsScalarFieldEnum]


  export const ClinicScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    address: 'address',
    city: 'city',
    phone: 'phone',
    email: 'email',
    website: 'website',
    description: 'description',
    featured: 'featured',
    logoUrl: 'logoUrl',
    rating: 'rating',
    reviewCount: 'reviewCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClinicScalarFieldEnum = (typeof ClinicScalarFieldEnum)[keyof typeof ClinicScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    description: 'description',
    price: 'price',
    sku: 'sku',
    imageUrl: 'imageUrl',
    featured: 'featured',
    category: 'category',
    stock: 'stock',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const IncomeScalarFieldEnum: {
    id: 'id',
    source: 'source',
    amount: 'amount',
    description: 'description',
    date: 'date',
    category: 'category',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IncomeScalarFieldEnum = (typeof IncomeScalarFieldEnum)[keyof typeof IncomeScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    method: 'method',
    description: 'description',
    transactionId: 'transactionId',
    receiptUrl: 'receiptUrl',
    invoiceId: 'invoiceId',
    date: 'date',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    invoiceNumber: 'invoiceNumber',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    dueDate: 'dueDate',
    issueDate: 'issueDate',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const ROASMetricsScalarFieldEnum: {
    id: 'id',
    date: 'date',
    adSpend: 'adSpend',
    revenue: 'revenue',
    roasValue: 'roasValue',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ROASMetricsScalarFieldEnum = (typeof ROASMetricsScalarFieldEnum)[keyof typeof ROASMetricsScalarFieldEnum]


  export const ConversionMetricsScalarFieldEnum: {
    id: 'id',
    date: 'date',
    source: 'source',
    medium: 'medium',
    campaign: 'campaign',
    landingPage: 'landingPage',
    pageViews: 'pageViews',
    uniqueVisitors: 'uniqueVisitors',
    conversions: 'conversions',
    conversionValue: 'conversionValue',
    conversionRate: 'conversionRate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConversionMetricsScalarFieldEnum = (typeof ConversionMetricsScalarFieldEnum)[keyof typeof ConversionMetricsScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    color: 'color',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const TagsOnCampaignsScalarFieldEnum: {
    tagId: 'tagId',
    campaignId: 'campaignId',
    assignedAt: 'assignedAt'
  };

  export type TagsOnCampaignsScalarFieldEnum = (typeof TagsOnCampaignsScalarFieldEnum)[keyof typeof TagsOnCampaignsScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    message: 'message',
    type: 'type',
    isRead: 'isRead',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SettingScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SettingScalarFieldEnum = (typeof SettingScalarFieldEnum)[keyof typeof SettingScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'CampaignStatus'
   */
  export type EnumCampaignStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignStatus'>
    


  /**
   * Reference to a field of type 'CampaignStatus[]'
   */
  export type ListEnumCampaignStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'BudgetType'
   */
  export type EnumBudgetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BudgetType'>
    


  /**
   * Reference to a field of type 'BudgetType[]'
   */
  export type ListEnumBudgetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BudgetType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'AdSetStatus'
   */
  export type EnumAdSetStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdSetStatus'>
    


  /**
   * Reference to a field of type 'AdSetStatus[]'
   */
  export type ListEnumAdSetStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdSetStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'AdStatus'
   */
  export type EnumAdStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdStatus'>
    


  /**
   * Reference to a field of type 'AdStatus[]'
   */
  export type ListEnumAdStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdStatus[]'>
    


  /**
   * Reference to a field of type 'CreativeType'
   */
  export type EnumCreativeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CreativeType'>
    


  /**
   * Reference to a field of type 'CreativeType[]'
   */
  export type ListEnumCreativeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CreativeType[]'>
    


  /**
   * Reference to a field of type 'ScheduleStatus'
   */
  export type EnumScheduleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScheduleStatus'>
    


  /**
   * Reference to a field of type 'ScheduleStatus[]'
   */
  export type ListEnumScheduleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScheduleStatus[]'>
    


  /**
   * Reference to a field of type 'SchedulePriority'
   */
  export type EnumSchedulePriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SchedulePriority'>
    


  /**
   * Reference to a field of type 'SchedulePriority[]'
   */
  export type ListEnumSchedulePriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SchedulePriority[]'>
    


  /**
   * Reference to a field of type 'ScheduleCategory'
   */
  export type EnumScheduleCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScheduleCategory'>
    


  /**
   * Reference to a field of type 'ScheduleCategory[]'
   */
  export type ListEnumScheduleCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScheduleCategory[]'>
    


  /**
   * Reference to a field of type 'RecurrencePattern'
   */
  export type EnumRecurrencePatternFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecurrencePattern'>
    


  /**
   * Reference to a field of type 'RecurrencePattern[]'
   */
  export type ListEnumRecurrencePatternFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecurrencePattern[]'>
    


  /**
   * Reference to a field of type 'CampaignObjective'
   */
  export type EnumCampaignObjectiveFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignObjective'>
    


  /**
   * Reference to a field of type 'CampaignObjective[]'
   */
  export type ListEnumCampaignObjectiveFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CampaignObjective[]'>
    


  /**
   * Reference to a field of type 'GenderTarget'
   */
  export type EnumGenderTargetFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GenderTarget'>
    


  /**
   * Reference to a field of type 'GenderTarget[]'
   */
  export type ListEnumGenderTargetFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GenderTarget[]'>
    


  /**
   * Reference to a field of type 'PlatformType'
   */
  export type EnumPlatformTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlatformType'>
    


  /**
   * Reference to a field of type 'PlatformType[]'
   */
  export type ListEnumPlatformTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlatformType[]'>
    


  /**
   * Reference to a field of type 'PlannerItemStatus'
   */
  export type EnumPlannerItemStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlannerItemStatus'>
    


  /**
   * Reference to a field of type 'PlannerItemStatus[]'
   */
  export type ListEnumPlannerItemStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlannerItemStatus[]'>
    


  /**
   * Reference to a field of type 'InfluencerStatus'
   */
  export type EnumInfluencerStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InfluencerStatus'>
    


  /**
   * Reference to a field of type 'InfluencerStatus[]'
   */
  export type ListEnumInfluencerStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InfluencerStatus[]'>
    


  /**
   * Reference to a field of type 'InfluencerCampaignStatus'
   */
  export type EnumInfluencerCampaignStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InfluencerCampaignStatus'>
    


  /**
   * Reference to a field of type 'InfluencerCampaignStatus[]'
   */
  export type ListEnumInfluencerCampaignStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InfluencerCampaignStatus[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'IncomeCategory'
   */
  export type EnumIncomeCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncomeCategory'>
    


  /**
   * Reference to a field of type 'IncomeCategory[]'
   */
  export type ListEnumIncomeCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IncomeCategory[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'InvoiceStatus'
   */
  export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus'>
    


  /**
   * Reference to a field of type 'InvoiceStatus[]'
   */
  export type ListEnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    metaAccounts?: MetaAccountListRelationFilter
    socialAccounts?: SocialMediaAccountListRelationFilter
    campaigns?: CampaignListRelationFilter
    adsets?: AdSetListRelationFilter
    ads?: AdListRelationFilter
    schedules?: ScheduleListRelationFilter
    payments?: PaymentListRelationFilter
    invoices?: InvoiceListRelationFilter
    notifications?: NotificationListRelationFilter
    influencers?: InfluencerListRelationFilter
    clinics?: ClinicListRelationFilter
    products?: ProductListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metaAccounts?: MetaAccountOrderByRelationAggregateInput
    socialAccounts?: SocialMediaAccountOrderByRelationAggregateInput
    campaigns?: CampaignOrderByRelationAggregateInput
    adsets?: AdSetOrderByRelationAggregateInput
    ads?: AdOrderByRelationAggregateInput
    schedules?: ScheduleOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    influencers?: InfluencerOrderByRelationAggregateInput
    clinics?: ClinicOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    metaAccounts?: MetaAccountListRelationFilter
    socialAccounts?: SocialMediaAccountListRelationFilter
    campaigns?: CampaignListRelationFilter
    adsets?: AdSetListRelationFilter
    ads?: AdListRelationFilter
    schedules?: ScheduleListRelationFilter
    payments?: PaymentListRelationFilter
    invoices?: InvoiceListRelationFilter
    notifications?: NotificationListRelationFilter
    influencers?: InfluencerListRelationFilter
    clinics?: ClinicListRelationFilter
    products?: ProductListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type MetaAccountWhereInput = {
    AND?: MetaAccountWhereInput | MetaAccountWhereInput[]
    OR?: MetaAccountWhereInput[]
    NOT?: MetaAccountWhereInput | MetaAccountWhereInput[]
    id?: StringFilter<"MetaAccount"> | string
    userId?: StringFilter<"MetaAccount"> | string
    metaAccountId?: StringFilter<"MetaAccount"> | string
    accessToken?: StringFilter<"MetaAccount"> | string
    refreshToken?: StringNullableFilter<"MetaAccount"> | string | null
    tokenExpiresAt?: DateTimeNullableFilter<"MetaAccount"> | Date | string | null
    businessName?: StringNullableFilter<"MetaAccount"> | string | null
    createdAt?: DateTimeFilter<"MetaAccount"> | Date | string
    updatedAt?: DateTimeFilter<"MetaAccount"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    campaigns?: CampaignListRelationFilter
    adSets?: AdSetListRelationFilter
    ads?: AdListRelationFilter
    adAccounts?: AdAccountListRelationFilter
  }

  export type MetaAccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    metaAccountId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    tokenExpiresAt?: SortOrderInput | SortOrder
    businessName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    campaigns?: CampaignOrderByRelationAggregateInput
    adSets?: AdSetOrderByRelationAggregateInput
    ads?: AdOrderByRelationAggregateInput
    adAccounts?: AdAccountOrderByRelationAggregateInput
  }

  export type MetaAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    metaAccountId?: string
    AND?: MetaAccountWhereInput | MetaAccountWhereInput[]
    OR?: MetaAccountWhereInput[]
    NOT?: MetaAccountWhereInput | MetaAccountWhereInput[]
    userId?: StringFilter<"MetaAccount"> | string
    accessToken?: StringFilter<"MetaAccount"> | string
    refreshToken?: StringNullableFilter<"MetaAccount"> | string | null
    tokenExpiresAt?: DateTimeNullableFilter<"MetaAccount"> | Date | string | null
    businessName?: StringNullableFilter<"MetaAccount"> | string | null
    createdAt?: DateTimeFilter<"MetaAccount"> | Date | string
    updatedAt?: DateTimeFilter<"MetaAccount"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    campaigns?: CampaignListRelationFilter
    adSets?: AdSetListRelationFilter
    ads?: AdListRelationFilter
    adAccounts?: AdAccountListRelationFilter
  }, "id" | "metaAccountId">

  export type MetaAccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    metaAccountId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrderInput | SortOrder
    tokenExpiresAt?: SortOrderInput | SortOrder
    businessName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MetaAccountCountOrderByAggregateInput
    _max?: MetaAccountMaxOrderByAggregateInput
    _min?: MetaAccountMinOrderByAggregateInput
  }

  export type MetaAccountScalarWhereWithAggregatesInput = {
    AND?: MetaAccountScalarWhereWithAggregatesInput | MetaAccountScalarWhereWithAggregatesInput[]
    OR?: MetaAccountScalarWhereWithAggregatesInput[]
    NOT?: MetaAccountScalarWhereWithAggregatesInput | MetaAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MetaAccount"> | string
    userId?: StringWithAggregatesFilter<"MetaAccount"> | string
    metaAccountId?: StringWithAggregatesFilter<"MetaAccount"> | string
    accessToken?: StringWithAggregatesFilter<"MetaAccount"> | string
    refreshToken?: StringNullableWithAggregatesFilter<"MetaAccount"> | string | null
    tokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"MetaAccount"> | Date | string | null
    businessName?: StringNullableWithAggregatesFilter<"MetaAccount"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MetaAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MetaAccount"> | Date | string
  }

  export type AdAccountWhereInput = {
    AND?: AdAccountWhereInput | AdAccountWhereInput[]
    OR?: AdAccountWhereInput[]
    NOT?: AdAccountWhereInput | AdAccountWhereInput[]
    id?: StringFilter<"AdAccount"> | string
    metaAccountId?: StringFilter<"AdAccount"> | string
    adAccountId?: StringFilter<"AdAccount"> | string
    name?: StringFilter<"AdAccount"> | string
    currency?: StringFilter<"AdAccount"> | string
    timezone?: StringFilter<"AdAccount"> | string
    status?: StringFilter<"AdAccount"> | string
    createdAt?: DateTimeFilter<"AdAccount"> | Date | string
    updatedAt?: DateTimeFilter<"AdAccount"> | Date | string
    metaAccount?: XOR<MetaAccountScalarRelationFilter, MetaAccountWhereInput>
    campaigns?: CampaignListRelationFilter
  }

  export type AdAccountOrderByWithRelationInput = {
    id?: SortOrder
    metaAccountId?: SortOrder
    adAccountId?: SortOrder
    name?: SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metaAccount?: MetaAccountOrderByWithRelationInput
    campaigns?: CampaignOrderByRelationAggregateInput
  }

  export type AdAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    adAccountId?: string
    AND?: AdAccountWhereInput | AdAccountWhereInput[]
    OR?: AdAccountWhereInput[]
    NOT?: AdAccountWhereInput | AdAccountWhereInput[]
    metaAccountId?: StringFilter<"AdAccount"> | string
    name?: StringFilter<"AdAccount"> | string
    currency?: StringFilter<"AdAccount"> | string
    timezone?: StringFilter<"AdAccount"> | string
    status?: StringFilter<"AdAccount"> | string
    createdAt?: DateTimeFilter<"AdAccount"> | Date | string
    updatedAt?: DateTimeFilter<"AdAccount"> | Date | string
    metaAccount?: XOR<MetaAccountScalarRelationFilter, MetaAccountWhereInput>
    campaigns?: CampaignListRelationFilter
  }, "id" | "adAccountId">

  export type AdAccountOrderByWithAggregationInput = {
    id?: SortOrder
    metaAccountId?: SortOrder
    adAccountId?: SortOrder
    name?: SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdAccountCountOrderByAggregateInput
    _max?: AdAccountMaxOrderByAggregateInput
    _min?: AdAccountMinOrderByAggregateInput
  }

  export type AdAccountScalarWhereWithAggregatesInput = {
    AND?: AdAccountScalarWhereWithAggregatesInput | AdAccountScalarWhereWithAggregatesInput[]
    OR?: AdAccountScalarWhereWithAggregatesInput[]
    NOT?: AdAccountScalarWhereWithAggregatesInput | AdAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdAccount"> | string
    metaAccountId?: StringWithAggregatesFilter<"AdAccount"> | string
    adAccountId?: StringWithAggregatesFilter<"AdAccount"> | string
    name?: StringWithAggregatesFilter<"AdAccount"> | string
    currency?: StringWithAggregatesFilter<"AdAccount"> | string
    timezone?: StringWithAggregatesFilter<"AdAccount"> | string
    status?: StringWithAggregatesFilter<"AdAccount"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AdAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdAccount"> | Date | string
  }

  export type CampaignWhereInput = {
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    id?: StringFilter<"Campaign"> | string
    userId?: StringFilter<"Campaign"> | string
    metaAccountId?: StringNullableFilter<"Campaign"> | string | null
    adAccountId?: StringNullableFilter<"Campaign"> | string | null
    campaignId?: StringNullableFilter<"Campaign"> | string | null
    name?: StringFilter<"Campaign"> | string
    objective?: StringFilter<"Campaign"> | string
    status?: EnumCampaignStatusFilter<"Campaign"> | $Enums.CampaignStatus
    budget?: FloatNullableFilter<"Campaign"> | number | null
    budgetType?: EnumBudgetTypeNullableFilter<"Campaign"> | $Enums.BudgetType | null
    startDate?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    clinicId?: StringNullableFilter<"Campaign"> | string | null
    productId?: StringNullableFilter<"Campaign"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    metaAccount?: XOR<MetaAccountNullableScalarRelationFilter, MetaAccountWhereInput> | null
    adAccount?: XOR<AdAccountNullableScalarRelationFilter, AdAccountWhereInput> | null
    adSets?: AdSetListRelationFilter
    tags?: TagsOnCampaignsListRelationFilter
    metrics?: CampaignMetricsListRelationFilter
    clinic?: XOR<ClinicNullableScalarRelationFilter, ClinicWhereInput> | null
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
  }

  export type CampaignOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    metaAccountId?: SortOrderInput | SortOrder
    adAccountId?: SortOrderInput | SortOrder
    campaignId?: SortOrderInput | SortOrder
    name?: SortOrder
    objective?: SortOrder
    status?: SortOrder
    budget?: SortOrderInput | SortOrder
    budgetType?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clinicId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    metaAccount?: MetaAccountOrderByWithRelationInput
    adAccount?: AdAccountOrderByWithRelationInput
    adSets?: AdSetOrderByRelationAggregateInput
    tags?: TagsOnCampaignsOrderByRelationAggregateInput
    metrics?: CampaignMetricsOrderByRelationAggregateInput
    clinic?: ClinicOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type CampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignWhereInput | CampaignWhereInput[]
    OR?: CampaignWhereInput[]
    NOT?: CampaignWhereInput | CampaignWhereInput[]
    userId?: StringFilter<"Campaign"> | string
    metaAccountId?: StringNullableFilter<"Campaign"> | string | null
    adAccountId?: StringNullableFilter<"Campaign"> | string | null
    campaignId?: StringNullableFilter<"Campaign"> | string | null
    name?: StringFilter<"Campaign"> | string
    objective?: StringFilter<"Campaign"> | string
    status?: EnumCampaignStatusFilter<"Campaign"> | $Enums.CampaignStatus
    budget?: FloatNullableFilter<"Campaign"> | number | null
    budgetType?: EnumBudgetTypeNullableFilter<"Campaign"> | $Enums.BudgetType | null
    startDate?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    clinicId?: StringNullableFilter<"Campaign"> | string | null
    productId?: StringNullableFilter<"Campaign"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    metaAccount?: XOR<MetaAccountNullableScalarRelationFilter, MetaAccountWhereInput> | null
    adAccount?: XOR<AdAccountNullableScalarRelationFilter, AdAccountWhereInput> | null
    adSets?: AdSetListRelationFilter
    tags?: TagsOnCampaignsListRelationFilter
    metrics?: CampaignMetricsListRelationFilter
    clinic?: XOR<ClinicNullableScalarRelationFilter, ClinicWhereInput> | null
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
  }, "id">

  export type CampaignOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    metaAccountId?: SortOrderInput | SortOrder
    adAccountId?: SortOrderInput | SortOrder
    campaignId?: SortOrderInput | SortOrder
    name?: SortOrder
    objective?: SortOrder
    status?: SortOrder
    budget?: SortOrderInput | SortOrder
    budgetType?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clinicId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    _count?: CampaignCountOrderByAggregateInput
    _avg?: CampaignAvgOrderByAggregateInput
    _max?: CampaignMaxOrderByAggregateInput
    _min?: CampaignMinOrderByAggregateInput
    _sum?: CampaignSumOrderByAggregateInput
  }

  export type CampaignScalarWhereWithAggregatesInput = {
    AND?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    OR?: CampaignScalarWhereWithAggregatesInput[]
    NOT?: CampaignScalarWhereWithAggregatesInput | CampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Campaign"> | string
    userId?: StringWithAggregatesFilter<"Campaign"> | string
    metaAccountId?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    adAccountId?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    campaignId?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    name?: StringWithAggregatesFilter<"Campaign"> | string
    objective?: StringWithAggregatesFilter<"Campaign"> | string
    status?: EnumCampaignStatusWithAggregatesFilter<"Campaign"> | $Enums.CampaignStatus
    budget?: FloatNullableWithAggregatesFilter<"Campaign"> | number | null
    budgetType?: EnumBudgetTypeNullableWithAggregatesFilter<"Campaign"> | $Enums.BudgetType | null
    startDate?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Campaign"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Campaign"> | Date | string
    clinicId?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
    productId?: StringNullableWithAggregatesFilter<"Campaign"> | string | null
  }

  export type CampaignMetricsWhereInput = {
    AND?: CampaignMetricsWhereInput | CampaignMetricsWhereInput[]
    OR?: CampaignMetricsWhereInput[]
    NOT?: CampaignMetricsWhereInput | CampaignMetricsWhereInput[]
    id?: StringFilter<"CampaignMetrics"> | string
    campaignId?: StringFilter<"CampaignMetrics"> | string
    date?: DateTimeFilter<"CampaignMetrics"> | Date | string
    impressions?: IntFilter<"CampaignMetrics"> | number
    clicks?: IntFilter<"CampaignMetrics"> | number
    reach?: IntFilter<"CampaignMetrics"> | number
    spend?: FloatFilter<"CampaignMetrics"> | number
    conversions?: IntFilter<"CampaignMetrics"> | number
    costPerResult?: FloatNullableFilter<"CampaignMetrics"> | number | null
    ctr?: FloatNullableFilter<"CampaignMetrics"> | number | null
    cpc?: FloatNullableFilter<"CampaignMetrics"> | number | null
    cpm?: FloatNullableFilter<"CampaignMetrics"> | number | null
    frequency?: FloatNullableFilter<"CampaignMetrics"> | number | null
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }

  export type CampaignMetricsOrderByWithRelationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    date?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    reach?: SortOrder
    spend?: SortOrder
    conversions?: SortOrder
    costPerResult?: SortOrderInput | SortOrder
    ctr?: SortOrderInput | SortOrder
    cpc?: SortOrderInput | SortOrder
    cpm?: SortOrderInput | SortOrder
    frequency?: SortOrderInput | SortOrder
    campaign?: CampaignOrderByWithRelationInput
  }

  export type CampaignMetricsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    campaignId_date?: CampaignMetricsCampaignIdDateCompoundUniqueInput
    AND?: CampaignMetricsWhereInput | CampaignMetricsWhereInput[]
    OR?: CampaignMetricsWhereInput[]
    NOT?: CampaignMetricsWhereInput | CampaignMetricsWhereInput[]
    campaignId?: StringFilter<"CampaignMetrics"> | string
    date?: DateTimeFilter<"CampaignMetrics"> | Date | string
    impressions?: IntFilter<"CampaignMetrics"> | number
    clicks?: IntFilter<"CampaignMetrics"> | number
    reach?: IntFilter<"CampaignMetrics"> | number
    spend?: FloatFilter<"CampaignMetrics"> | number
    conversions?: IntFilter<"CampaignMetrics"> | number
    costPerResult?: FloatNullableFilter<"CampaignMetrics"> | number | null
    ctr?: FloatNullableFilter<"CampaignMetrics"> | number | null
    cpc?: FloatNullableFilter<"CampaignMetrics"> | number | null
    cpm?: FloatNullableFilter<"CampaignMetrics"> | number | null
    frequency?: FloatNullableFilter<"CampaignMetrics"> | number | null
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }, "id" | "campaignId_date">

  export type CampaignMetricsOrderByWithAggregationInput = {
    id?: SortOrder
    campaignId?: SortOrder
    date?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    reach?: SortOrder
    spend?: SortOrder
    conversions?: SortOrder
    costPerResult?: SortOrderInput | SortOrder
    ctr?: SortOrderInput | SortOrder
    cpc?: SortOrderInput | SortOrder
    cpm?: SortOrderInput | SortOrder
    frequency?: SortOrderInput | SortOrder
    _count?: CampaignMetricsCountOrderByAggregateInput
    _avg?: CampaignMetricsAvgOrderByAggregateInput
    _max?: CampaignMetricsMaxOrderByAggregateInput
    _min?: CampaignMetricsMinOrderByAggregateInput
    _sum?: CampaignMetricsSumOrderByAggregateInput
  }

  export type CampaignMetricsScalarWhereWithAggregatesInput = {
    AND?: CampaignMetricsScalarWhereWithAggregatesInput | CampaignMetricsScalarWhereWithAggregatesInput[]
    OR?: CampaignMetricsScalarWhereWithAggregatesInput[]
    NOT?: CampaignMetricsScalarWhereWithAggregatesInput | CampaignMetricsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignMetrics"> | string
    campaignId?: StringWithAggregatesFilter<"CampaignMetrics"> | string
    date?: DateTimeWithAggregatesFilter<"CampaignMetrics"> | Date | string
    impressions?: IntWithAggregatesFilter<"CampaignMetrics"> | number
    clicks?: IntWithAggregatesFilter<"CampaignMetrics"> | number
    reach?: IntWithAggregatesFilter<"CampaignMetrics"> | number
    spend?: FloatWithAggregatesFilter<"CampaignMetrics"> | number
    conversions?: IntWithAggregatesFilter<"CampaignMetrics"> | number
    costPerResult?: FloatNullableWithAggregatesFilter<"CampaignMetrics"> | number | null
    ctr?: FloatNullableWithAggregatesFilter<"CampaignMetrics"> | number | null
    cpc?: FloatNullableWithAggregatesFilter<"CampaignMetrics"> | number | null
    cpm?: FloatNullableWithAggregatesFilter<"CampaignMetrics"> | number | null
    frequency?: FloatNullableWithAggregatesFilter<"CampaignMetrics"> | number | null
  }

  export type AdSetWhereInput = {
    AND?: AdSetWhereInput | AdSetWhereInput[]
    OR?: AdSetWhereInput[]
    NOT?: AdSetWhereInput | AdSetWhereInput[]
    id?: StringFilter<"AdSet"> | string
    userId?: StringFilter<"AdSet"> | string
    campaignId?: StringFilter<"AdSet"> | string
    metaAccountId?: StringNullableFilter<"AdSet"> | string | null
    adSetId?: StringNullableFilter<"AdSet"> | string | null
    name?: StringFilter<"AdSet"> | string
    status?: EnumAdSetStatusFilter<"AdSet"> | $Enums.AdSetStatus
    budget?: FloatNullableFilter<"AdSet"> | number | null
    budgetType?: EnumBudgetTypeNullableFilter<"AdSet"> | $Enums.BudgetType | null
    bidStrategy?: StringNullableFilter<"AdSet"> | string | null
    bidAmount?: FloatNullableFilter<"AdSet"> | number | null
    startDate?: DateTimeNullableFilter<"AdSet"> | Date | string | null
    endDate?: DateTimeNullableFilter<"AdSet"> | Date | string | null
    targeting?: JsonNullableFilter<"AdSet">
    createdAt?: DateTimeFilter<"AdSet"> | Date | string
    updatedAt?: DateTimeFilter<"AdSet"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    metaAccount?: XOR<MetaAccountNullableScalarRelationFilter, MetaAccountWhereInput> | null
    ads?: AdListRelationFilter
    metrics?: AdSetMetricsListRelationFilter
  }

  export type AdSetOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrder
    metaAccountId?: SortOrderInput | SortOrder
    adSetId?: SortOrderInput | SortOrder
    name?: SortOrder
    status?: SortOrder
    budget?: SortOrderInput | SortOrder
    budgetType?: SortOrderInput | SortOrder
    bidStrategy?: SortOrderInput | SortOrder
    bidAmount?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    targeting?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    campaign?: CampaignOrderByWithRelationInput
    metaAccount?: MetaAccountOrderByWithRelationInput
    ads?: AdOrderByRelationAggregateInput
    metrics?: AdSetMetricsOrderByRelationAggregateInput
  }

  export type AdSetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdSetWhereInput | AdSetWhereInput[]
    OR?: AdSetWhereInput[]
    NOT?: AdSetWhereInput | AdSetWhereInput[]
    userId?: StringFilter<"AdSet"> | string
    campaignId?: StringFilter<"AdSet"> | string
    metaAccountId?: StringNullableFilter<"AdSet"> | string | null
    adSetId?: StringNullableFilter<"AdSet"> | string | null
    name?: StringFilter<"AdSet"> | string
    status?: EnumAdSetStatusFilter<"AdSet"> | $Enums.AdSetStatus
    budget?: FloatNullableFilter<"AdSet"> | number | null
    budgetType?: EnumBudgetTypeNullableFilter<"AdSet"> | $Enums.BudgetType | null
    bidStrategy?: StringNullableFilter<"AdSet"> | string | null
    bidAmount?: FloatNullableFilter<"AdSet"> | number | null
    startDate?: DateTimeNullableFilter<"AdSet"> | Date | string | null
    endDate?: DateTimeNullableFilter<"AdSet"> | Date | string | null
    targeting?: JsonNullableFilter<"AdSet">
    createdAt?: DateTimeFilter<"AdSet"> | Date | string
    updatedAt?: DateTimeFilter<"AdSet"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
    metaAccount?: XOR<MetaAccountNullableScalarRelationFilter, MetaAccountWhereInput> | null
    ads?: AdListRelationFilter
    metrics?: AdSetMetricsListRelationFilter
  }, "id">

  export type AdSetOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrder
    metaAccountId?: SortOrderInput | SortOrder
    adSetId?: SortOrderInput | SortOrder
    name?: SortOrder
    status?: SortOrder
    budget?: SortOrderInput | SortOrder
    budgetType?: SortOrderInput | SortOrder
    bidStrategy?: SortOrderInput | SortOrder
    bidAmount?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    targeting?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdSetCountOrderByAggregateInput
    _avg?: AdSetAvgOrderByAggregateInput
    _max?: AdSetMaxOrderByAggregateInput
    _min?: AdSetMinOrderByAggregateInput
    _sum?: AdSetSumOrderByAggregateInput
  }

  export type AdSetScalarWhereWithAggregatesInput = {
    AND?: AdSetScalarWhereWithAggregatesInput | AdSetScalarWhereWithAggregatesInput[]
    OR?: AdSetScalarWhereWithAggregatesInput[]
    NOT?: AdSetScalarWhereWithAggregatesInput | AdSetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdSet"> | string
    userId?: StringWithAggregatesFilter<"AdSet"> | string
    campaignId?: StringWithAggregatesFilter<"AdSet"> | string
    metaAccountId?: StringNullableWithAggregatesFilter<"AdSet"> | string | null
    adSetId?: StringNullableWithAggregatesFilter<"AdSet"> | string | null
    name?: StringWithAggregatesFilter<"AdSet"> | string
    status?: EnumAdSetStatusWithAggregatesFilter<"AdSet"> | $Enums.AdSetStatus
    budget?: FloatNullableWithAggregatesFilter<"AdSet"> | number | null
    budgetType?: EnumBudgetTypeNullableWithAggregatesFilter<"AdSet"> | $Enums.BudgetType | null
    bidStrategy?: StringNullableWithAggregatesFilter<"AdSet"> | string | null
    bidAmount?: FloatNullableWithAggregatesFilter<"AdSet"> | number | null
    startDate?: DateTimeNullableWithAggregatesFilter<"AdSet"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"AdSet"> | Date | string | null
    targeting?: JsonNullableWithAggregatesFilter<"AdSet">
    createdAt?: DateTimeWithAggregatesFilter<"AdSet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdSet"> | Date | string
  }

  export type AdSetMetricsWhereInput = {
    AND?: AdSetMetricsWhereInput | AdSetMetricsWhereInput[]
    OR?: AdSetMetricsWhereInput[]
    NOT?: AdSetMetricsWhereInput | AdSetMetricsWhereInput[]
    id?: StringFilter<"AdSetMetrics"> | string
    adSetId?: StringFilter<"AdSetMetrics"> | string
    date?: DateTimeFilter<"AdSetMetrics"> | Date | string
    impressions?: IntFilter<"AdSetMetrics"> | number
    clicks?: IntFilter<"AdSetMetrics"> | number
    reach?: IntFilter<"AdSetMetrics"> | number
    spend?: FloatFilter<"AdSetMetrics"> | number
    conversions?: IntFilter<"AdSetMetrics"> | number
    costPerResult?: FloatNullableFilter<"AdSetMetrics"> | number | null
    ctr?: FloatNullableFilter<"AdSetMetrics"> | number | null
    cpc?: FloatNullableFilter<"AdSetMetrics"> | number | null
    cpm?: FloatNullableFilter<"AdSetMetrics"> | number | null
    frequency?: FloatNullableFilter<"AdSetMetrics"> | number | null
    adSet?: XOR<AdSetScalarRelationFilter, AdSetWhereInput>
  }

  export type AdSetMetricsOrderByWithRelationInput = {
    id?: SortOrder
    adSetId?: SortOrder
    date?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    reach?: SortOrder
    spend?: SortOrder
    conversions?: SortOrder
    costPerResult?: SortOrderInput | SortOrder
    ctr?: SortOrderInput | SortOrder
    cpc?: SortOrderInput | SortOrder
    cpm?: SortOrderInput | SortOrder
    frequency?: SortOrderInput | SortOrder
    adSet?: AdSetOrderByWithRelationInput
  }

  export type AdSetMetricsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    adSetId_date?: AdSetMetricsAdSetIdDateCompoundUniqueInput
    AND?: AdSetMetricsWhereInput | AdSetMetricsWhereInput[]
    OR?: AdSetMetricsWhereInput[]
    NOT?: AdSetMetricsWhereInput | AdSetMetricsWhereInput[]
    adSetId?: StringFilter<"AdSetMetrics"> | string
    date?: DateTimeFilter<"AdSetMetrics"> | Date | string
    impressions?: IntFilter<"AdSetMetrics"> | number
    clicks?: IntFilter<"AdSetMetrics"> | number
    reach?: IntFilter<"AdSetMetrics"> | number
    spend?: FloatFilter<"AdSetMetrics"> | number
    conversions?: IntFilter<"AdSetMetrics"> | number
    costPerResult?: FloatNullableFilter<"AdSetMetrics"> | number | null
    ctr?: FloatNullableFilter<"AdSetMetrics"> | number | null
    cpc?: FloatNullableFilter<"AdSetMetrics"> | number | null
    cpm?: FloatNullableFilter<"AdSetMetrics"> | number | null
    frequency?: FloatNullableFilter<"AdSetMetrics"> | number | null
    adSet?: XOR<AdSetScalarRelationFilter, AdSetWhereInput>
  }, "id" | "adSetId_date">

  export type AdSetMetricsOrderByWithAggregationInput = {
    id?: SortOrder
    adSetId?: SortOrder
    date?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    reach?: SortOrder
    spend?: SortOrder
    conversions?: SortOrder
    costPerResult?: SortOrderInput | SortOrder
    ctr?: SortOrderInput | SortOrder
    cpc?: SortOrderInput | SortOrder
    cpm?: SortOrderInput | SortOrder
    frequency?: SortOrderInput | SortOrder
    _count?: AdSetMetricsCountOrderByAggregateInput
    _avg?: AdSetMetricsAvgOrderByAggregateInput
    _max?: AdSetMetricsMaxOrderByAggregateInput
    _min?: AdSetMetricsMinOrderByAggregateInput
    _sum?: AdSetMetricsSumOrderByAggregateInput
  }

  export type AdSetMetricsScalarWhereWithAggregatesInput = {
    AND?: AdSetMetricsScalarWhereWithAggregatesInput | AdSetMetricsScalarWhereWithAggregatesInput[]
    OR?: AdSetMetricsScalarWhereWithAggregatesInput[]
    NOT?: AdSetMetricsScalarWhereWithAggregatesInput | AdSetMetricsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdSetMetrics"> | string
    adSetId?: StringWithAggregatesFilter<"AdSetMetrics"> | string
    date?: DateTimeWithAggregatesFilter<"AdSetMetrics"> | Date | string
    impressions?: IntWithAggregatesFilter<"AdSetMetrics"> | number
    clicks?: IntWithAggregatesFilter<"AdSetMetrics"> | number
    reach?: IntWithAggregatesFilter<"AdSetMetrics"> | number
    spend?: FloatWithAggregatesFilter<"AdSetMetrics"> | number
    conversions?: IntWithAggregatesFilter<"AdSetMetrics"> | number
    costPerResult?: FloatNullableWithAggregatesFilter<"AdSetMetrics"> | number | null
    ctr?: FloatNullableWithAggregatesFilter<"AdSetMetrics"> | number | null
    cpc?: FloatNullableWithAggregatesFilter<"AdSetMetrics"> | number | null
    cpm?: FloatNullableWithAggregatesFilter<"AdSetMetrics"> | number | null
    frequency?: FloatNullableWithAggregatesFilter<"AdSetMetrics"> | number | null
  }

  export type AdWhereInput = {
    AND?: AdWhereInput | AdWhereInput[]
    OR?: AdWhereInput[]
    NOT?: AdWhereInput | AdWhereInput[]
    id?: StringFilter<"Ad"> | string
    userId?: StringFilter<"Ad"> | string
    adSetId?: StringFilter<"Ad"> | string
    metaAccountId?: StringNullableFilter<"Ad"> | string | null
    adId?: StringNullableFilter<"Ad"> | string | null
    name?: StringFilter<"Ad"> | string
    status?: EnumAdStatusFilter<"Ad"> | $Enums.AdStatus
    headline?: StringNullableFilter<"Ad"> | string | null
    description?: StringNullableFilter<"Ad"> | string | null
    creativeType?: EnumCreativeTypeNullableFilter<"Ad"> | $Enums.CreativeType | null
    imageUrl?: StringNullableFilter<"Ad"> | string | null
    videoUrl?: StringNullableFilter<"Ad"> | string | null
    destinationUrl?: StringNullableFilter<"Ad"> | string | null
    callToAction?: StringNullableFilter<"Ad"> | string | null
    createdAt?: DateTimeFilter<"Ad"> | Date | string
    updatedAt?: DateTimeFilter<"Ad"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    adSet?: XOR<AdSetScalarRelationFilter, AdSetWhereInput>
    metaAccount?: XOR<MetaAccountNullableScalarRelationFilter, MetaAccountWhereInput> | null
    metrics?: AdMetricsListRelationFilter
    schedules?: ScheduleListRelationFilter
  }

  export type AdOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    adSetId?: SortOrder
    metaAccountId?: SortOrderInput | SortOrder
    adId?: SortOrderInput | SortOrder
    name?: SortOrder
    status?: SortOrder
    headline?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    creativeType?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    destinationUrl?: SortOrderInput | SortOrder
    callToAction?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    adSet?: AdSetOrderByWithRelationInput
    metaAccount?: MetaAccountOrderByWithRelationInput
    metrics?: AdMetricsOrderByRelationAggregateInput
    schedules?: ScheduleOrderByRelationAggregateInput
  }

  export type AdWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdWhereInput | AdWhereInput[]
    OR?: AdWhereInput[]
    NOT?: AdWhereInput | AdWhereInput[]
    userId?: StringFilter<"Ad"> | string
    adSetId?: StringFilter<"Ad"> | string
    metaAccountId?: StringNullableFilter<"Ad"> | string | null
    adId?: StringNullableFilter<"Ad"> | string | null
    name?: StringFilter<"Ad"> | string
    status?: EnumAdStatusFilter<"Ad"> | $Enums.AdStatus
    headline?: StringNullableFilter<"Ad"> | string | null
    description?: StringNullableFilter<"Ad"> | string | null
    creativeType?: EnumCreativeTypeNullableFilter<"Ad"> | $Enums.CreativeType | null
    imageUrl?: StringNullableFilter<"Ad"> | string | null
    videoUrl?: StringNullableFilter<"Ad"> | string | null
    destinationUrl?: StringNullableFilter<"Ad"> | string | null
    callToAction?: StringNullableFilter<"Ad"> | string | null
    createdAt?: DateTimeFilter<"Ad"> | Date | string
    updatedAt?: DateTimeFilter<"Ad"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    adSet?: XOR<AdSetScalarRelationFilter, AdSetWhereInput>
    metaAccount?: XOR<MetaAccountNullableScalarRelationFilter, MetaAccountWhereInput> | null
    metrics?: AdMetricsListRelationFilter
    schedules?: ScheduleListRelationFilter
  }, "id">

  export type AdOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    adSetId?: SortOrder
    metaAccountId?: SortOrderInput | SortOrder
    adId?: SortOrderInput | SortOrder
    name?: SortOrder
    status?: SortOrder
    headline?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    creativeType?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    destinationUrl?: SortOrderInput | SortOrder
    callToAction?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdCountOrderByAggregateInput
    _max?: AdMaxOrderByAggregateInput
    _min?: AdMinOrderByAggregateInput
  }

  export type AdScalarWhereWithAggregatesInput = {
    AND?: AdScalarWhereWithAggregatesInput | AdScalarWhereWithAggregatesInput[]
    OR?: AdScalarWhereWithAggregatesInput[]
    NOT?: AdScalarWhereWithAggregatesInput | AdScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ad"> | string
    userId?: StringWithAggregatesFilter<"Ad"> | string
    adSetId?: StringWithAggregatesFilter<"Ad"> | string
    metaAccountId?: StringNullableWithAggregatesFilter<"Ad"> | string | null
    adId?: StringNullableWithAggregatesFilter<"Ad"> | string | null
    name?: StringWithAggregatesFilter<"Ad"> | string
    status?: EnumAdStatusWithAggregatesFilter<"Ad"> | $Enums.AdStatus
    headline?: StringNullableWithAggregatesFilter<"Ad"> | string | null
    description?: StringNullableWithAggregatesFilter<"Ad"> | string | null
    creativeType?: EnumCreativeTypeNullableWithAggregatesFilter<"Ad"> | $Enums.CreativeType | null
    imageUrl?: StringNullableWithAggregatesFilter<"Ad"> | string | null
    videoUrl?: StringNullableWithAggregatesFilter<"Ad"> | string | null
    destinationUrl?: StringNullableWithAggregatesFilter<"Ad"> | string | null
    callToAction?: StringNullableWithAggregatesFilter<"Ad"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Ad"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Ad"> | Date | string
  }

  export type AdMetricsWhereInput = {
    AND?: AdMetricsWhereInput | AdMetricsWhereInput[]
    OR?: AdMetricsWhereInput[]
    NOT?: AdMetricsWhereInput | AdMetricsWhereInput[]
    id?: StringFilter<"AdMetrics"> | string
    adId?: StringFilter<"AdMetrics"> | string
    date?: DateTimeFilter<"AdMetrics"> | Date | string
    impressions?: IntFilter<"AdMetrics"> | number
    clicks?: IntFilter<"AdMetrics"> | number
    reach?: IntFilter<"AdMetrics"> | number
    spend?: FloatFilter<"AdMetrics"> | number
    conversions?: IntFilter<"AdMetrics"> | number
    costPerResult?: FloatNullableFilter<"AdMetrics"> | number | null
    ctr?: FloatNullableFilter<"AdMetrics"> | number | null
    cpc?: FloatNullableFilter<"AdMetrics"> | number | null
    cpm?: FloatNullableFilter<"AdMetrics"> | number | null
    frequency?: FloatNullableFilter<"AdMetrics"> | number | null
    engagements?: IntFilter<"AdMetrics"> | number
    shares?: IntFilter<"AdMetrics"> | number
    comments?: IntFilter<"AdMetrics"> | number
    saves?: IntFilter<"AdMetrics"> | number
    ad?: XOR<AdScalarRelationFilter, AdWhereInput>
  }

  export type AdMetricsOrderByWithRelationInput = {
    id?: SortOrder
    adId?: SortOrder
    date?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    reach?: SortOrder
    spend?: SortOrder
    conversions?: SortOrder
    costPerResult?: SortOrderInput | SortOrder
    ctr?: SortOrderInput | SortOrder
    cpc?: SortOrderInput | SortOrder
    cpm?: SortOrderInput | SortOrder
    frequency?: SortOrderInput | SortOrder
    engagements?: SortOrder
    shares?: SortOrder
    comments?: SortOrder
    saves?: SortOrder
    ad?: AdOrderByWithRelationInput
  }

  export type AdMetricsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    adId_date?: AdMetricsAdIdDateCompoundUniqueInput
    AND?: AdMetricsWhereInput | AdMetricsWhereInput[]
    OR?: AdMetricsWhereInput[]
    NOT?: AdMetricsWhereInput | AdMetricsWhereInput[]
    adId?: StringFilter<"AdMetrics"> | string
    date?: DateTimeFilter<"AdMetrics"> | Date | string
    impressions?: IntFilter<"AdMetrics"> | number
    clicks?: IntFilter<"AdMetrics"> | number
    reach?: IntFilter<"AdMetrics"> | number
    spend?: FloatFilter<"AdMetrics"> | number
    conversions?: IntFilter<"AdMetrics"> | number
    costPerResult?: FloatNullableFilter<"AdMetrics"> | number | null
    ctr?: FloatNullableFilter<"AdMetrics"> | number | null
    cpc?: FloatNullableFilter<"AdMetrics"> | number | null
    cpm?: FloatNullableFilter<"AdMetrics"> | number | null
    frequency?: FloatNullableFilter<"AdMetrics"> | number | null
    engagements?: IntFilter<"AdMetrics"> | number
    shares?: IntFilter<"AdMetrics"> | number
    comments?: IntFilter<"AdMetrics"> | number
    saves?: IntFilter<"AdMetrics"> | number
    ad?: XOR<AdScalarRelationFilter, AdWhereInput>
  }, "id" | "adId_date">

  export type AdMetricsOrderByWithAggregationInput = {
    id?: SortOrder
    adId?: SortOrder
    date?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    reach?: SortOrder
    spend?: SortOrder
    conversions?: SortOrder
    costPerResult?: SortOrderInput | SortOrder
    ctr?: SortOrderInput | SortOrder
    cpc?: SortOrderInput | SortOrder
    cpm?: SortOrderInput | SortOrder
    frequency?: SortOrderInput | SortOrder
    engagements?: SortOrder
    shares?: SortOrder
    comments?: SortOrder
    saves?: SortOrder
    _count?: AdMetricsCountOrderByAggregateInput
    _avg?: AdMetricsAvgOrderByAggregateInput
    _max?: AdMetricsMaxOrderByAggregateInput
    _min?: AdMetricsMinOrderByAggregateInput
    _sum?: AdMetricsSumOrderByAggregateInput
  }

  export type AdMetricsScalarWhereWithAggregatesInput = {
    AND?: AdMetricsScalarWhereWithAggregatesInput | AdMetricsScalarWhereWithAggregatesInput[]
    OR?: AdMetricsScalarWhereWithAggregatesInput[]
    NOT?: AdMetricsScalarWhereWithAggregatesInput | AdMetricsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdMetrics"> | string
    adId?: StringWithAggregatesFilter<"AdMetrics"> | string
    date?: DateTimeWithAggregatesFilter<"AdMetrics"> | Date | string
    impressions?: IntWithAggregatesFilter<"AdMetrics"> | number
    clicks?: IntWithAggregatesFilter<"AdMetrics"> | number
    reach?: IntWithAggregatesFilter<"AdMetrics"> | number
    spend?: FloatWithAggregatesFilter<"AdMetrics"> | number
    conversions?: IntWithAggregatesFilter<"AdMetrics"> | number
    costPerResult?: FloatNullableWithAggregatesFilter<"AdMetrics"> | number | null
    ctr?: FloatNullableWithAggregatesFilter<"AdMetrics"> | number | null
    cpc?: FloatNullableWithAggregatesFilter<"AdMetrics"> | number | null
    cpm?: FloatNullableWithAggregatesFilter<"AdMetrics"> | number | null
    frequency?: FloatNullableWithAggregatesFilter<"AdMetrics"> | number | null
    engagements?: IntWithAggregatesFilter<"AdMetrics"> | number
    shares?: IntWithAggregatesFilter<"AdMetrics"> | number
    comments?: IntWithAggregatesFilter<"AdMetrics"> | number
    saves?: IntWithAggregatesFilter<"AdMetrics"> | number
  }

  export type ScheduleWhereInput = {
    AND?: ScheduleWhereInput | ScheduleWhereInput[]
    OR?: ScheduleWhereInput[]
    NOT?: ScheduleWhereInput | ScheduleWhereInput[]
    id?: StringFilter<"Schedule"> | string
    userId?: StringFilter<"Schedule"> | string
    adId?: StringNullableFilter<"Schedule"> | string | null
    title?: StringFilter<"Schedule"> | string
    startDate?: DateTimeFilter<"Schedule"> | Date | string
    endDate?: DateTimeFilter<"Schedule"> | Date | string
    status?: EnumScheduleStatusFilter<"Schedule"> | $Enums.ScheduleStatus
    priority?: EnumSchedulePriorityFilter<"Schedule"> | $Enums.SchedulePriority
    category?: EnumScheduleCategoryNullableFilter<"Schedule"> | $Enums.ScheduleCategory | null
    clinicId?: StringNullableFilter<"Schedule"> | string | null
    productId?: StringNullableFilter<"Schedule"> | string | null
    recurrence?: EnumRecurrencePatternNullableFilter<"Schedule"> | $Enums.RecurrencePattern | null
    notes?: StringNullableFilter<"Schedule"> | string | null
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    ad?: XOR<AdNullableScalarRelationFilter, AdWhereInput> | null
    clinic?: XOR<ClinicNullableScalarRelationFilter, ClinicWhereInput> | null
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
  }

  export type ScheduleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    adId?: SortOrderInput | SortOrder
    title?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    category?: SortOrderInput | SortOrder
    clinicId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    recurrence?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    ad?: AdOrderByWithRelationInput
    clinic?: ClinicOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type ScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScheduleWhereInput | ScheduleWhereInput[]
    OR?: ScheduleWhereInput[]
    NOT?: ScheduleWhereInput | ScheduleWhereInput[]
    userId?: StringFilter<"Schedule"> | string
    adId?: StringNullableFilter<"Schedule"> | string | null
    title?: StringFilter<"Schedule"> | string
    startDate?: DateTimeFilter<"Schedule"> | Date | string
    endDate?: DateTimeFilter<"Schedule"> | Date | string
    status?: EnumScheduleStatusFilter<"Schedule"> | $Enums.ScheduleStatus
    priority?: EnumSchedulePriorityFilter<"Schedule"> | $Enums.SchedulePriority
    category?: EnumScheduleCategoryNullableFilter<"Schedule"> | $Enums.ScheduleCategory | null
    clinicId?: StringNullableFilter<"Schedule"> | string | null
    productId?: StringNullableFilter<"Schedule"> | string | null
    recurrence?: EnumRecurrencePatternNullableFilter<"Schedule"> | $Enums.RecurrencePattern | null
    notes?: StringNullableFilter<"Schedule"> | string | null
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    ad?: XOR<AdNullableScalarRelationFilter, AdWhereInput> | null
    clinic?: XOR<ClinicNullableScalarRelationFilter, ClinicWhereInput> | null
    product?: XOR<ProductNullableScalarRelationFilter, ProductWhereInput> | null
  }, "id">

  export type ScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    adId?: SortOrderInput | SortOrder
    title?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    category?: SortOrderInput | SortOrder
    clinicId?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    recurrence?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ScheduleCountOrderByAggregateInput
    _max?: ScheduleMaxOrderByAggregateInput
    _min?: ScheduleMinOrderByAggregateInput
  }

  export type ScheduleScalarWhereWithAggregatesInput = {
    AND?: ScheduleScalarWhereWithAggregatesInput | ScheduleScalarWhereWithAggregatesInput[]
    OR?: ScheduleScalarWhereWithAggregatesInput[]
    NOT?: ScheduleScalarWhereWithAggregatesInput | ScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Schedule"> | string
    userId?: StringWithAggregatesFilter<"Schedule"> | string
    adId?: StringNullableWithAggregatesFilter<"Schedule"> | string | null
    title?: StringWithAggregatesFilter<"Schedule"> | string
    startDate?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
    status?: EnumScheduleStatusWithAggregatesFilter<"Schedule"> | $Enums.ScheduleStatus
    priority?: EnumSchedulePriorityWithAggregatesFilter<"Schedule"> | $Enums.SchedulePriority
    category?: EnumScheduleCategoryNullableWithAggregatesFilter<"Schedule"> | $Enums.ScheduleCategory | null
    clinicId?: StringNullableWithAggregatesFilter<"Schedule"> | string | null
    productId?: StringNullableWithAggregatesFilter<"Schedule"> | string | null
    recurrence?: EnumRecurrencePatternNullableWithAggregatesFilter<"Schedule"> | $Enums.RecurrencePattern | null
    notes?: StringNullableWithAggregatesFilter<"Schedule"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
  }

  export type AdsPlannerWhereInput = {
    AND?: AdsPlannerWhereInput | AdsPlannerWhereInput[]
    OR?: AdsPlannerWhereInput[]
    NOT?: AdsPlannerWhereInput | AdsPlannerWhereInput[]
    id?: StringFilter<"AdsPlanner"> | string
    name?: StringFilter<"AdsPlanner"> | string
    description?: StringNullableFilter<"AdsPlanner"> | string | null
    objective?: EnumCampaignObjectiveFilter<"AdsPlanner"> | $Enums.CampaignObjective
    budgetType?: EnumBudgetTypeFilter<"AdsPlanner"> | $Enums.BudgetType
    budgetAmount?: FloatFilter<"AdsPlanner"> | number
    whatsappNumber?: StringNullableFilter<"AdsPlanner"> | string | null
    startDate?: DateTimeFilter<"AdsPlanner"> | Date | string
    endDate?: DateTimeFilter<"AdsPlanner"> | Date | string
    location?: StringNullableFilter<"AdsPlanner"> | string | null
    minAge?: IntNullableFilter<"AdsPlanner"> | number | null
    maxAge?: IntNullableFilter<"AdsPlanner"> | number | null
    gender?: EnumGenderTargetNullableFilter<"AdsPlanner"> | $Enums.GenderTarget | null
    detailTargeting?: StringNullableFilter<"AdsPlanner"> | string | null
    videoUrl?: StringNullableFilter<"AdsPlanner"> | string | null
    websiteUrl?: StringNullableFilter<"AdsPlanner"> | string | null
    primaryText?: StringNullableFilter<"AdsPlanner"> | string | null
    headline?: StringNullableFilter<"AdsPlanner"> | string | null
    ctaName?: StringNullableFilter<"AdsPlanner"> | string | null
    ctaText?: StringNullableFilter<"AdsPlanner"> | string | null
    preFilledMessage?: StringNullableFilter<"AdsPlanner"> | string | null
    createdAt?: DateTimeFilter<"AdsPlanner"> | Date | string
    updatedAt?: DateTimeFilter<"AdsPlanner"> | Date | string
    planItems?: PlannerItemListRelationFilter
  }

  export type AdsPlannerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    objective?: SortOrder
    budgetType?: SortOrder
    budgetAmount?: SortOrder
    whatsappNumber?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrderInput | SortOrder
    minAge?: SortOrderInput | SortOrder
    maxAge?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    detailTargeting?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    websiteUrl?: SortOrderInput | SortOrder
    primaryText?: SortOrderInput | SortOrder
    headline?: SortOrderInput | SortOrder
    ctaName?: SortOrderInput | SortOrder
    ctaText?: SortOrderInput | SortOrder
    preFilledMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    planItems?: PlannerItemOrderByRelationAggregateInput
  }

  export type AdsPlannerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdsPlannerWhereInput | AdsPlannerWhereInput[]
    OR?: AdsPlannerWhereInput[]
    NOT?: AdsPlannerWhereInput | AdsPlannerWhereInput[]
    name?: StringFilter<"AdsPlanner"> | string
    description?: StringNullableFilter<"AdsPlanner"> | string | null
    objective?: EnumCampaignObjectiveFilter<"AdsPlanner"> | $Enums.CampaignObjective
    budgetType?: EnumBudgetTypeFilter<"AdsPlanner"> | $Enums.BudgetType
    budgetAmount?: FloatFilter<"AdsPlanner"> | number
    whatsappNumber?: StringNullableFilter<"AdsPlanner"> | string | null
    startDate?: DateTimeFilter<"AdsPlanner"> | Date | string
    endDate?: DateTimeFilter<"AdsPlanner"> | Date | string
    location?: StringNullableFilter<"AdsPlanner"> | string | null
    minAge?: IntNullableFilter<"AdsPlanner"> | number | null
    maxAge?: IntNullableFilter<"AdsPlanner"> | number | null
    gender?: EnumGenderTargetNullableFilter<"AdsPlanner"> | $Enums.GenderTarget | null
    detailTargeting?: StringNullableFilter<"AdsPlanner"> | string | null
    videoUrl?: StringNullableFilter<"AdsPlanner"> | string | null
    websiteUrl?: StringNullableFilter<"AdsPlanner"> | string | null
    primaryText?: StringNullableFilter<"AdsPlanner"> | string | null
    headline?: StringNullableFilter<"AdsPlanner"> | string | null
    ctaName?: StringNullableFilter<"AdsPlanner"> | string | null
    ctaText?: StringNullableFilter<"AdsPlanner"> | string | null
    preFilledMessage?: StringNullableFilter<"AdsPlanner"> | string | null
    createdAt?: DateTimeFilter<"AdsPlanner"> | Date | string
    updatedAt?: DateTimeFilter<"AdsPlanner"> | Date | string
    planItems?: PlannerItemListRelationFilter
  }, "id">

  export type AdsPlannerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    objective?: SortOrder
    budgetType?: SortOrder
    budgetAmount?: SortOrder
    whatsappNumber?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrderInput | SortOrder
    minAge?: SortOrderInput | SortOrder
    maxAge?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    detailTargeting?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    websiteUrl?: SortOrderInput | SortOrder
    primaryText?: SortOrderInput | SortOrder
    headline?: SortOrderInput | SortOrder
    ctaName?: SortOrderInput | SortOrder
    ctaText?: SortOrderInput | SortOrder
    preFilledMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdsPlannerCountOrderByAggregateInput
    _avg?: AdsPlannerAvgOrderByAggregateInput
    _max?: AdsPlannerMaxOrderByAggregateInput
    _min?: AdsPlannerMinOrderByAggregateInput
    _sum?: AdsPlannerSumOrderByAggregateInput
  }

  export type AdsPlannerScalarWhereWithAggregatesInput = {
    AND?: AdsPlannerScalarWhereWithAggregatesInput | AdsPlannerScalarWhereWithAggregatesInput[]
    OR?: AdsPlannerScalarWhereWithAggregatesInput[]
    NOT?: AdsPlannerScalarWhereWithAggregatesInput | AdsPlannerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdsPlanner"> | string
    name?: StringWithAggregatesFilter<"AdsPlanner"> | string
    description?: StringNullableWithAggregatesFilter<"AdsPlanner"> | string | null
    objective?: EnumCampaignObjectiveWithAggregatesFilter<"AdsPlanner"> | $Enums.CampaignObjective
    budgetType?: EnumBudgetTypeWithAggregatesFilter<"AdsPlanner"> | $Enums.BudgetType
    budgetAmount?: FloatWithAggregatesFilter<"AdsPlanner"> | number
    whatsappNumber?: StringNullableWithAggregatesFilter<"AdsPlanner"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"AdsPlanner"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"AdsPlanner"> | Date | string
    location?: StringNullableWithAggregatesFilter<"AdsPlanner"> | string | null
    minAge?: IntNullableWithAggregatesFilter<"AdsPlanner"> | number | null
    maxAge?: IntNullableWithAggregatesFilter<"AdsPlanner"> | number | null
    gender?: EnumGenderTargetNullableWithAggregatesFilter<"AdsPlanner"> | $Enums.GenderTarget | null
    detailTargeting?: StringNullableWithAggregatesFilter<"AdsPlanner"> | string | null
    videoUrl?: StringNullableWithAggregatesFilter<"AdsPlanner"> | string | null
    websiteUrl?: StringNullableWithAggregatesFilter<"AdsPlanner"> | string | null
    primaryText?: StringNullableWithAggregatesFilter<"AdsPlanner"> | string | null
    headline?: StringNullableWithAggregatesFilter<"AdsPlanner"> | string | null
    ctaName?: StringNullableWithAggregatesFilter<"AdsPlanner"> | string | null
    ctaText?: StringNullableWithAggregatesFilter<"AdsPlanner"> | string | null
    preFilledMessage?: StringNullableWithAggregatesFilter<"AdsPlanner"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AdsPlanner"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdsPlanner"> | Date | string
  }

  export type PlannerItemWhereInput = {
    AND?: PlannerItemWhereInput | PlannerItemWhereInput[]
    OR?: PlannerItemWhereInput[]
    NOT?: PlannerItemWhereInput | PlannerItemWhereInput[]
    id?: StringFilter<"PlannerItem"> | string
    plannerId?: StringFilter<"PlannerItem"> | string
    title?: StringFilter<"PlannerItem"> | string
    description?: StringNullableFilter<"PlannerItem"> | string | null
    platform?: EnumPlatformTypeFilter<"PlannerItem"> | $Enums.PlatformType
    format?: StringNullableFilter<"PlannerItem"> | string | null
    budget?: FloatNullableFilter<"PlannerItem"> | number | null
    startDate?: DateTimeNullableFilter<"PlannerItem"> | Date | string | null
    endDate?: DateTimeNullableFilter<"PlannerItem"> | Date | string | null
    status?: EnumPlannerItemStatusFilter<"PlannerItem"> | $Enums.PlannerItemStatus
    createdAt?: DateTimeFilter<"PlannerItem"> | Date | string
    updatedAt?: DateTimeFilter<"PlannerItem"> | Date | string
    planner?: XOR<AdsPlannerScalarRelationFilter, AdsPlannerWhereInput>
  }

  export type PlannerItemOrderByWithRelationInput = {
    id?: SortOrder
    plannerId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    platform?: SortOrder
    format?: SortOrderInput | SortOrder
    budget?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    planner?: AdsPlannerOrderByWithRelationInput
  }

  export type PlannerItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlannerItemWhereInput | PlannerItemWhereInput[]
    OR?: PlannerItemWhereInput[]
    NOT?: PlannerItemWhereInput | PlannerItemWhereInput[]
    plannerId?: StringFilter<"PlannerItem"> | string
    title?: StringFilter<"PlannerItem"> | string
    description?: StringNullableFilter<"PlannerItem"> | string | null
    platform?: EnumPlatformTypeFilter<"PlannerItem"> | $Enums.PlatformType
    format?: StringNullableFilter<"PlannerItem"> | string | null
    budget?: FloatNullableFilter<"PlannerItem"> | number | null
    startDate?: DateTimeNullableFilter<"PlannerItem"> | Date | string | null
    endDate?: DateTimeNullableFilter<"PlannerItem"> | Date | string | null
    status?: EnumPlannerItemStatusFilter<"PlannerItem"> | $Enums.PlannerItemStatus
    createdAt?: DateTimeFilter<"PlannerItem"> | Date | string
    updatedAt?: DateTimeFilter<"PlannerItem"> | Date | string
    planner?: XOR<AdsPlannerScalarRelationFilter, AdsPlannerWhereInput>
  }, "id">

  export type PlannerItemOrderByWithAggregationInput = {
    id?: SortOrder
    plannerId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    platform?: SortOrder
    format?: SortOrderInput | SortOrder
    budget?: SortOrderInput | SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlannerItemCountOrderByAggregateInput
    _avg?: PlannerItemAvgOrderByAggregateInput
    _max?: PlannerItemMaxOrderByAggregateInput
    _min?: PlannerItemMinOrderByAggregateInput
    _sum?: PlannerItemSumOrderByAggregateInput
  }

  export type PlannerItemScalarWhereWithAggregatesInput = {
    AND?: PlannerItemScalarWhereWithAggregatesInput | PlannerItemScalarWhereWithAggregatesInput[]
    OR?: PlannerItemScalarWhereWithAggregatesInput[]
    NOT?: PlannerItemScalarWhereWithAggregatesInput | PlannerItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlannerItem"> | string
    plannerId?: StringWithAggregatesFilter<"PlannerItem"> | string
    title?: StringWithAggregatesFilter<"PlannerItem"> | string
    description?: StringNullableWithAggregatesFilter<"PlannerItem"> | string | null
    platform?: EnumPlatformTypeWithAggregatesFilter<"PlannerItem"> | $Enums.PlatformType
    format?: StringNullableWithAggregatesFilter<"PlannerItem"> | string | null
    budget?: FloatNullableWithAggregatesFilter<"PlannerItem"> | number | null
    startDate?: DateTimeNullableWithAggregatesFilter<"PlannerItem"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"PlannerItem"> | Date | string | null
    status?: EnumPlannerItemStatusWithAggregatesFilter<"PlannerItem"> | $Enums.PlannerItemStatus
    createdAt?: DateTimeWithAggregatesFilter<"PlannerItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlannerItem"> | Date | string
  }

  export type SocialMediaAccountWhereInput = {
    AND?: SocialMediaAccountWhereInput | SocialMediaAccountWhereInput[]
    OR?: SocialMediaAccountWhereInput[]
    NOT?: SocialMediaAccountWhereInput | SocialMediaAccountWhereInput[]
    id?: StringFilter<"SocialMediaAccount"> | string
    userId?: StringFilter<"SocialMediaAccount"> | string
    platform?: EnumPlatformTypeFilter<"SocialMediaAccount"> | $Enums.PlatformType
    accountName?: StringFilter<"SocialMediaAccount"> | string
    accountId?: StringNullableFilter<"SocialMediaAccount"> | string | null
    followers?: IntFilter<"SocialMediaAccount"> | number
    accessToken?: StringNullableFilter<"SocialMediaAccount"> | string | null
    tokenExpiresAt?: DateTimeNullableFilter<"SocialMediaAccount"> | Date | string | null
    createdAt?: DateTimeFilter<"SocialMediaAccount"> | Date | string
    updatedAt?: DateTimeFilter<"SocialMediaAccount"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    platformMetrics?: PlatformMetricsListRelationFilter
    engagementMetrics?: EngagementMetricsListRelationFilter
    influencers?: InfluencerListRelationFilter
  }

  export type SocialMediaAccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    platform?: SortOrder
    accountName?: SortOrder
    accountId?: SortOrderInput | SortOrder
    followers?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    tokenExpiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    platformMetrics?: PlatformMetricsOrderByRelationAggregateInput
    engagementMetrics?: EngagementMetricsOrderByRelationAggregateInput
    influencers?: InfluencerOrderByRelationAggregateInput
  }

  export type SocialMediaAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_platform_accountName?: SocialMediaAccountUserIdPlatformAccountNameCompoundUniqueInput
    AND?: SocialMediaAccountWhereInput | SocialMediaAccountWhereInput[]
    OR?: SocialMediaAccountWhereInput[]
    NOT?: SocialMediaAccountWhereInput | SocialMediaAccountWhereInput[]
    userId?: StringFilter<"SocialMediaAccount"> | string
    platform?: EnumPlatformTypeFilter<"SocialMediaAccount"> | $Enums.PlatformType
    accountName?: StringFilter<"SocialMediaAccount"> | string
    accountId?: StringNullableFilter<"SocialMediaAccount"> | string | null
    followers?: IntFilter<"SocialMediaAccount"> | number
    accessToken?: StringNullableFilter<"SocialMediaAccount"> | string | null
    tokenExpiresAt?: DateTimeNullableFilter<"SocialMediaAccount"> | Date | string | null
    createdAt?: DateTimeFilter<"SocialMediaAccount"> | Date | string
    updatedAt?: DateTimeFilter<"SocialMediaAccount"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    platformMetrics?: PlatformMetricsListRelationFilter
    engagementMetrics?: EngagementMetricsListRelationFilter
    influencers?: InfluencerListRelationFilter
  }, "id" | "userId_platform_accountName">

  export type SocialMediaAccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    platform?: SortOrder
    accountName?: SortOrder
    accountId?: SortOrderInput | SortOrder
    followers?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    tokenExpiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SocialMediaAccountCountOrderByAggregateInput
    _avg?: SocialMediaAccountAvgOrderByAggregateInput
    _max?: SocialMediaAccountMaxOrderByAggregateInput
    _min?: SocialMediaAccountMinOrderByAggregateInput
    _sum?: SocialMediaAccountSumOrderByAggregateInput
  }

  export type SocialMediaAccountScalarWhereWithAggregatesInput = {
    AND?: SocialMediaAccountScalarWhereWithAggregatesInput | SocialMediaAccountScalarWhereWithAggregatesInput[]
    OR?: SocialMediaAccountScalarWhereWithAggregatesInput[]
    NOT?: SocialMediaAccountScalarWhereWithAggregatesInput | SocialMediaAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SocialMediaAccount"> | string
    userId?: StringWithAggregatesFilter<"SocialMediaAccount"> | string
    platform?: EnumPlatformTypeWithAggregatesFilter<"SocialMediaAccount"> | $Enums.PlatformType
    accountName?: StringWithAggregatesFilter<"SocialMediaAccount"> | string
    accountId?: StringNullableWithAggregatesFilter<"SocialMediaAccount"> | string | null
    followers?: IntWithAggregatesFilter<"SocialMediaAccount"> | number
    accessToken?: StringNullableWithAggregatesFilter<"SocialMediaAccount"> | string | null
    tokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"SocialMediaAccount"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SocialMediaAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SocialMediaAccount"> | Date | string
  }

  export type PlatformMetricsWhereInput = {
    AND?: PlatformMetricsWhereInput | PlatformMetricsWhereInput[]
    OR?: PlatformMetricsWhereInput[]
    NOT?: PlatformMetricsWhereInput | PlatformMetricsWhereInput[]
    id?: StringFilter<"PlatformMetrics"> | string
    accountId?: StringFilter<"PlatformMetrics"> | string
    date?: DateTimeFilter<"PlatformMetrics"> | Date | string
    followers?: IntFilter<"PlatformMetrics"> | number
    following?: IntFilter<"PlatformMetrics"> | number
    posts?: IntFilter<"PlatformMetrics"> | number
    impressions?: IntFilter<"PlatformMetrics"> | number
    reach?: IntFilter<"PlatformMetrics"> | number
    profileViews?: IntFilter<"PlatformMetrics"> | number
    websiteClicks?: IntFilter<"PlatformMetrics"> | number
    createdAt?: DateTimeFilter<"PlatformMetrics"> | Date | string
    updatedAt?: DateTimeFilter<"PlatformMetrics"> | Date | string
    account?: XOR<SocialMediaAccountScalarRelationFilter, SocialMediaAccountWhereInput>
  }

  export type PlatformMetricsOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    date?: SortOrder
    followers?: SortOrder
    following?: SortOrder
    posts?: SortOrder
    impressions?: SortOrder
    reach?: SortOrder
    profileViews?: SortOrder
    websiteClicks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account?: SocialMediaAccountOrderByWithRelationInput
  }

  export type PlatformMetricsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    accountId_date?: PlatformMetricsAccountIdDateCompoundUniqueInput
    AND?: PlatformMetricsWhereInput | PlatformMetricsWhereInput[]
    OR?: PlatformMetricsWhereInput[]
    NOT?: PlatformMetricsWhereInput | PlatformMetricsWhereInput[]
    accountId?: StringFilter<"PlatformMetrics"> | string
    date?: DateTimeFilter<"PlatformMetrics"> | Date | string
    followers?: IntFilter<"PlatformMetrics"> | number
    following?: IntFilter<"PlatformMetrics"> | number
    posts?: IntFilter<"PlatformMetrics"> | number
    impressions?: IntFilter<"PlatformMetrics"> | number
    reach?: IntFilter<"PlatformMetrics"> | number
    profileViews?: IntFilter<"PlatformMetrics"> | number
    websiteClicks?: IntFilter<"PlatformMetrics"> | number
    createdAt?: DateTimeFilter<"PlatformMetrics"> | Date | string
    updatedAt?: DateTimeFilter<"PlatformMetrics"> | Date | string
    account?: XOR<SocialMediaAccountScalarRelationFilter, SocialMediaAccountWhereInput>
  }, "id" | "accountId_date">

  export type PlatformMetricsOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    date?: SortOrder
    followers?: SortOrder
    following?: SortOrder
    posts?: SortOrder
    impressions?: SortOrder
    reach?: SortOrder
    profileViews?: SortOrder
    websiteClicks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlatformMetricsCountOrderByAggregateInput
    _avg?: PlatformMetricsAvgOrderByAggregateInput
    _max?: PlatformMetricsMaxOrderByAggregateInput
    _min?: PlatformMetricsMinOrderByAggregateInput
    _sum?: PlatformMetricsSumOrderByAggregateInput
  }

  export type PlatformMetricsScalarWhereWithAggregatesInput = {
    AND?: PlatformMetricsScalarWhereWithAggregatesInput | PlatformMetricsScalarWhereWithAggregatesInput[]
    OR?: PlatformMetricsScalarWhereWithAggregatesInput[]
    NOT?: PlatformMetricsScalarWhereWithAggregatesInput | PlatformMetricsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlatformMetrics"> | string
    accountId?: StringWithAggregatesFilter<"PlatformMetrics"> | string
    date?: DateTimeWithAggregatesFilter<"PlatformMetrics"> | Date | string
    followers?: IntWithAggregatesFilter<"PlatformMetrics"> | number
    following?: IntWithAggregatesFilter<"PlatformMetrics"> | number
    posts?: IntWithAggregatesFilter<"PlatformMetrics"> | number
    impressions?: IntWithAggregatesFilter<"PlatformMetrics"> | number
    reach?: IntWithAggregatesFilter<"PlatformMetrics"> | number
    profileViews?: IntWithAggregatesFilter<"PlatformMetrics"> | number
    websiteClicks?: IntWithAggregatesFilter<"PlatformMetrics"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PlatformMetrics"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlatformMetrics"> | Date | string
  }

  export type EngagementMetricsWhereInput = {
    AND?: EngagementMetricsWhereInput | EngagementMetricsWhereInput[]
    OR?: EngagementMetricsWhereInput[]
    NOT?: EngagementMetricsWhereInput | EngagementMetricsWhereInput[]
    id?: StringFilter<"EngagementMetrics"> | string
    accountId?: StringFilter<"EngagementMetrics"> | string
    date?: DateTimeFilter<"EngagementMetrics"> | Date | string
    likes?: IntFilter<"EngagementMetrics"> | number
    comments?: IntFilter<"EngagementMetrics"> | number
    shares?: IntFilter<"EngagementMetrics"> | number
    saves?: IntFilter<"EngagementMetrics"> | number
    clicks?: IntFilter<"EngagementMetrics"> | number
    engagementRate?: FloatNullableFilter<"EngagementMetrics"> | number | null
    createdAt?: DateTimeFilter<"EngagementMetrics"> | Date | string
    updatedAt?: DateTimeFilter<"EngagementMetrics"> | Date | string
    account?: XOR<SocialMediaAccountScalarRelationFilter, SocialMediaAccountWhereInput>
  }

  export type EngagementMetricsOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    date?: SortOrder
    likes?: SortOrder
    comments?: SortOrder
    shares?: SortOrder
    saves?: SortOrder
    clicks?: SortOrder
    engagementRate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account?: SocialMediaAccountOrderByWithRelationInput
  }

  export type EngagementMetricsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    accountId_date?: EngagementMetricsAccountIdDateCompoundUniqueInput
    AND?: EngagementMetricsWhereInput | EngagementMetricsWhereInput[]
    OR?: EngagementMetricsWhereInput[]
    NOT?: EngagementMetricsWhereInput | EngagementMetricsWhereInput[]
    accountId?: StringFilter<"EngagementMetrics"> | string
    date?: DateTimeFilter<"EngagementMetrics"> | Date | string
    likes?: IntFilter<"EngagementMetrics"> | number
    comments?: IntFilter<"EngagementMetrics"> | number
    shares?: IntFilter<"EngagementMetrics"> | number
    saves?: IntFilter<"EngagementMetrics"> | number
    clicks?: IntFilter<"EngagementMetrics"> | number
    engagementRate?: FloatNullableFilter<"EngagementMetrics"> | number | null
    createdAt?: DateTimeFilter<"EngagementMetrics"> | Date | string
    updatedAt?: DateTimeFilter<"EngagementMetrics"> | Date | string
    account?: XOR<SocialMediaAccountScalarRelationFilter, SocialMediaAccountWhereInput>
  }, "id" | "accountId_date">

  export type EngagementMetricsOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    date?: SortOrder
    likes?: SortOrder
    comments?: SortOrder
    shares?: SortOrder
    saves?: SortOrder
    clicks?: SortOrder
    engagementRate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EngagementMetricsCountOrderByAggregateInput
    _avg?: EngagementMetricsAvgOrderByAggregateInput
    _max?: EngagementMetricsMaxOrderByAggregateInput
    _min?: EngagementMetricsMinOrderByAggregateInput
    _sum?: EngagementMetricsSumOrderByAggregateInput
  }

  export type EngagementMetricsScalarWhereWithAggregatesInput = {
    AND?: EngagementMetricsScalarWhereWithAggregatesInput | EngagementMetricsScalarWhereWithAggregatesInput[]
    OR?: EngagementMetricsScalarWhereWithAggregatesInput[]
    NOT?: EngagementMetricsScalarWhereWithAggregatesInput | EngagementMetricsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EngagementMetrics"> | string
    accountId?: StringWithAggregatesFilter<"EngagementMetrics"> | string
    date?: DateTimeWithAggregatesFilter<"EngagementMetrics"> | Date | string
    likes?: IntWithAggregatesFilter<"EngagementMetrics"> | number
    comments?: IntWithAggregatesFilter<"EngagementMetrics"> | number
    shares?: IntWithAggregatesFilter<"EngagementMetrics"> | number
    saves?: IntWithAggregatesFilter<"EngagementMetrics"> | number
    clicks?: IntWithAggregatesFilter<"EngagementMetrics"> | number
    engagementRate?: FloatNullableWithAggregatesFilter<"EngagementMetrics"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"EngagementMetrics"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EngagementMetrics"> | Date | string
  }

  export type InfluencerWhereInput = {
    AND?: InfluencerWhereInput | InfluencerWhereInput[]
    OR?: InfluencerWhereInput[]
    NOT?: InfluencerWhereInput | InfluencerWhereInput[]
    id?: StringFilter<"Influencer"> | string
    userId?: StringFilter<"Influencer"> | string
    accountId?: StringFilter<"Influencer"> | string
    name?: StringFilter<"Influencer"> | string
    contactInfo?: StringNullableFilter<"Influencer"> | string | null
    reach?: IntFilter<"Influencer"> | number
    engagementRate?: FloatNullableFilter<"Influencer"> | number | null
    niche?: StringNullableFilter<"Influencer"> | string | null
    cost?: FloatNullableFilter<"Influencer"> | number | null
    status?: EnumInfluencerStatusFilter<"Influencer"> | $Enums.InfluencerStatus
    notes?: StringNullableFilter<"Influencer"> | string | null
    createdAt?: DateTimeFilter<"Influencer"> | Date | string
    updatedAt?: DateTimeFilter<"Influencer"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    account?: XOR<SocialMediaAccountScalarRelationFilter, SocialMediaAccountWhereInput>
    campaigns?: InfluencerCampaignsListRelationFilter
  }

  export type InfluencerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    name?: SortOrder
    contactInfo?: SortOrderInput | SortOrder
    reach?: SortOrder
    engagementRate?: SortOrderInput | SortOrder
    niche?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    account?: SocialMediaAccountOrderByWithRelationInput
    campaigns?: InfluencerCampaignsOrderByRelationAggregateInput
  }

  export type InfluencerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InfluencerWhereInput | InfluencerWhereInput[]
    OR?: InfluencerWhereInput[]
    NOT?: InfluencerWhereInput | InfluencerWhereInput[]
    userId?: StringFilter<"Influencer"> | string
    accountId?: StringFilter<"Influencer"> | string
    name?: StringFilter<"Influencer"> | string
    contactInfo?: StringNullableFilter<"Influencer"> | string | null
    reach?: IntFilter<"Influencer"> | number
    engagementRate?: FloatNullableFilter<"Influencer"> | number | null
    niche?: StringNullableFilter<"Influencer"> | string | null
    cost?: FloatNullableFilter<"Influencer"> | number | null
    status?: EnumInfluencerStatusFilter<"Influencer"> | $Enums.InfluencerStatus
    notes?: StringNullableFilter<"Influencer"> | string | null
    createdAt?: DateTimeFilter<"Influencer"> | Date | string
    updatedAt?: DateTimeFilter<"Influencer"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    account?: XOR<SocialMediaAccountScalarRelationFilter, SocialMediaAccountWhereInput>
    campaigns?: InfluencerCampaignsListRelationFilter
  }, "id">

  export type InfluencerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    name?: SortOrder
    contactInfo?: SortOrderInput | SortOrder
    reach?: SortOrder
    engagementRate?: SortOrderInput | SortOrder
    niche?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InfluencerCountOrderByAggregateInput
    _avg?: InfluencerAvgOrderByAggregateInput
    _max?: InfluencerMaxOrderByAggregateInput
    _min?: InfluencerMinOrderByAggregateInput
    _sum?: InfluencerSumOrderByAggregateInput
  }

  export type InfluencerScalarWhereWithAggregatesInput = {
    AND?: InfluencerScalarWhereWithAggregatesInput | InfluencerScalarWhereWithAggregatesInput[]
    OR?: InfluencerScalarWhereWithAggregatesInput[]
    NOT?: InfluencerScalarWhereWithAggregatesInput | InfluencerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Influencer"> | string
    userId?: StringWithAggregatesFilter<"Influencer"> | string
    accountId?: StringWithAggregatesFilter<"Influencer"> | string
    name?: StringWithAggregatesFilter<"Influencer"> | string
    contactInfo?: StringNullableWithAggregatesFilter<"Influencer"> | string | null
    reach?: IntWithAggregatesFilter<"Influencer"> | number
    engagementRate?: FloatNullableWithAggregatesFilter<"Influencer"> | number | null
    niche?: StringNullableWithAggregatesFilter<"Influencer"> | string | null
    cost?: FloatNullableWithAggregatesFilter<"Influencer"> | number | null
    status?: EnumInfluencerStatusWithAggregatesFilter<"Influencer"> | $Enums.InfluencerStatus
    notes?: StringNullableWithAggregatesFilter<"Influencer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Influencer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Influencer"> | Date | string
  }

  export type InfluencerCampaignsWhereInput = {
    AND?: InfluencerCampaignsWhereInput | InfluencerCampaignsWhereInput[]
    OR?: InfluencerCampaignsWhereInput[]
    NOT?: InfluencerCampaignsWhereInput | InfluencerCampaignsWhereInput[]
    id?: StringFilter<"InfluencerCampaigns"> | string
    influencerId?: StringFilter<"InfluencerCampaigns"> | string
    name?: StringFilter<"InfluencerCampaigns"> | string
    startDate?: DateTimeFilter<"InfluencerCampaigns"> | Date | string
    endDate?: DateTimeNullableFilter<"InfluencerCampaigns"> | Date | string | null
    budget?: FloatFilter<"InfluencerCampaigns"> | number
    results?: JsonNullableFilter<"InfluencerCampaigns">
    status?: EnumInfluencerCampaignStatusFilter<"InfluencerCampaigns"> | $Enums.InfluencerCampaignStatus
    createdAt?: DateTimeFilter<"InfluencerCampaigns"> | Date | string
    updatedAt?: DateTimeFilter<"InfluencerCampaigns"> | Date | string
    influencer?: XOR<InfluencerScalarRelationFilter, InfluencerWhereInput>
  }

  export type InfluencerCampaignsOrderByWithRelationInput = {
    id?: SortOrder
    influencerId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    budget?: SortOrder
    results?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    influencer?: InfluencerOrderByWithRelationInput
  }

  export type InfluencerCampaignsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InfluencerCampaignsWhereInput | InfluencerCampaignsWhereInput[]
    OR?: InfluencerCampaignsWhereInput[]
    NOT?: InfluencerCampaignsWhereInput | InfluencerCampaignsWhereInput[]
    influencerId?: StringFilter<"InfluencerCampaigns"> | string
    name?: StringFilter<"InfluencerCampaigns"> | string
    startDate?: DateTimeFilter<"InfluencerCampaigns"> | Date | string
    endDate?: DateTimeNullableFilter<"InfluencerCampaigns"> | Date | string | null
    budget?: FloatFilter<"InfluencerCampaigns"> | number
    results?: JsonNullableFilter<"InfluencerCampaigns">
    status?: EnumInfluencerCampaignStatusFilter<"InfluencerCampaigns"> | $Enums.InfluencerCampaignStatus
    createdAt?: DateTimeFilter<"InfluencerCampaigns"> | Date | string
    updatedAt?: DateTimeFilter<"InfluencerCampaigns"> | Date | string
    influencer?: XOR<InfluencerScalarRelationFilter, InfluencerWhereInput>
  }, "id">

  export type InfluencerCampaignsOrderByWithAggregationInput = {
    id?: SortOrder
    influencerId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    budget?: SortOrder
    results?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InfluencerCampaignsCountOrderByAggregateInput
    _avg?: InfluencerCampaignsAvgOrderByAggregateInput
    _max?: InfluencerCampaignsMaxOrderByAggregateInput
    _min?: InfluencerCampaignsMinOrderByAggregateInput
    _sum?: InfluencerCampaignsSumOrderByAggregateInput
  }

  export type InfluencerCampaignsScalarWhereWithAggregatesInput = {
    AND?: InfluencerCampaignsScalarWhereWithAggregatesInput | InfluencerCampaignsScalarWhereWithAggregatesInput[]
    OR?: InfluencerCampaignsScalarWhereWithAggregatesInput[]
    NOT?: InfluencerCampaignsScalarWhereWithAggregatesInput | InfluencerCampaignsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InfluencerCampaigns"> | string
    influencerId?: StringWithAggregatesFilter<"InfluencerCampaigns"> | string
    name?: StringWithAggregatesFilter<"InfluencerCampaigns"> | string
    startDate?: DateTimeWithAggregatesFilter<"InfluencerCampaigns"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"InfluencerCampaigns"> | Date | string | null
    budget?: FloatWithAggregatesFilter<"InfluencerCampaigns"> | number
    results?: JsonNullableWithAggregatesFilter<"InfluencerCampaigns">
    status?: EnumInfluencerCampaignStatusWithAggregatesFilter<"InfluencerCampaigns"> | $Enums.InfluencerCampaignStatus
    createdAt?: DateTimeWithAggregatesFilter<"InfluencerCampaigns"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InfluencerCampaigns"> | Date | string
  }

  export type ClinicWhereInput = {
    AND?: ClinicWhereInput | ClinicWhereInput[]
    OR?: ClinicWhereInput[]
    NOT?: ClinicWhereInput | ClinicWhereInput[]
    id?: StringFilter<"Clinic"> | string
    userId?: StringFilter<"Clinic"> | string
    name?: StringFilter<"Clinic"> | string
    address?: StringNullableFilter<"Clinic"> | string | null
    city?: StringNullableFilter<"Clinic"> | string | null
    phone?: StringNullableFilter<"Clinic"> | string | null
    email?: StringNullableFilter<"Clinic"> | string | null
    website?: StringNullableFilter<"Clinic"> | string | null
    description?: StringNullableFilter<"Clinic"> | string | null
    featured?: BoolFilter<"Clinic"> | boolean
    logoUrl?: StringNullableFilter<"Clinic"> | string | null
    rating?: FloatNullableFilter<"Clinic"> | number | null
    reviewCount?: IntFilter<"Clinic"> | number
    createdAt?: DateTimeFilter<"Clinic"> | Date | string
    updatedAt?: DateTimeFilter<"Clinic"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    schedules?: ScheduleListRelationFilter
    campaigns?: CampaignListRelationFilter
  }

  export type ClinicOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    featured?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    reviewCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    schedules?: ScheduleOrderByRelationAggregateInput
    campaigns?: CampaignOrderByRelationAggregateInput
  }

  export type ClinicWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClinicWhereInput | ClinicWhereInput[]
    OR?: ClinicWhereInput[]
    NOT?: ClinicWhereInput | ClinicWhereInput[]
    userId?: StringFilter<"Clinic"> | string
    name?: StringFilter<"Clinic"> | string
    address?: StringNullableFilter<"Clinic"> | string | null
    city?: StringNullableFilter<"Clinic"> | string | null
    phone?: StringNullableFilter<"Clinic"> | string | null
    email?: StringNullableFilter<"Clinic"> | string | null
    website?: StringNullableFilter<"Clinic"> | string | null
    description?: StringNullableFilter<"Clinic"> | string | null
    featured?: BoolFilter<"Clinic"> | boolean
    logoUrl?: StringNullableFilter<"Clinic"> | string | null
    rating?: FloatNullableFilter<"Clinic"> | number | null
    reviewCount?: IntFilter<"Clinic"> | number
    createdAt?: DateTimeFilter<"Clinic"> | Date | string
    updatedAt?: DateTimeFilter<"Clinic"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    schedules?: ScheduleListRelationFilter
    campaigns?: CampaignListRelationFilter
  }, "id">

  export type ClinicOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    featured?: SortOrder
    logoUrl?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    reviewCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClinicCountOrderByAggregateInput
    _avg?: ClinicAvgOrderByAggregateInput
    _max?: ClinicMaxOrderByAggregateInput
    _min?: ClinicMinOrderByAggregateInput
    _sum?: ClinicSumOrderByAggregateInput
  }

  export type ClinicScalarWhereWithAggregatesInput = {
    AND?: ClinicScalarWhereWithAggregatesInput | ClinicScalarWhereWithAggregatesInput[]
    OR?: ClinicScalarWhereWithAggregatesInput[]
    NOT?: ClinicScalarWhereWithAggregatesInput | ClinicScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Clinic"> | string
    userId?: StringWithAggregatesFilter<"Clinic"> | string
    name?: StringWithAggregatesFilter<"Clinic"> | string
    address?: StringNullableWithAggregatesFilter<"Clinic"> | string | null
    city?: StringNullableWithAggregatesFilter<"Clinic"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Clinic"> | string | null
    email?: StringNullableWithAggregatesFilter<"Clinic"> | string | null
    website?: StringNullableWithAggregatesFilter<"Clinic"> | string | null
    description?: StringNullableWithAggregatesFilter<"Clinic"> | string | null
    featured?: BoolWithAggregatesFilter<"Clinic"> | boolean
    logoUrl?: StringNullableWithAggregatesFilter<"Clinic"> | string | null
    rating?: FloatNullableWithAggregatesFilter<"Clinic"> | number | null
    reviewCount?: IntWithAggregatesFilter<"Clinic"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Clinic"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Clinic"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    userId?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    price?: FloatNullableFilter<"Product"> | number | null
    sku?: StringNullableFilter<"Product"> | string | null
    imageUrl?: StringNullableFilter<"Product"> | string | null
    featured?: BoolFilter<"Product"> | boolean
    category?: StringNullableFilter<"Product"> | string | null
    stock?: IntNullableFilter<"Product"> | number | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    schedules?: ScheduleListRelationFilter
    campaigns?: CampaignListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    sku?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    featured?: SortOrder
    category?: SortOrderInput | SortOrder
    stock?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    schedules?: ScheduleOrderByRelationAggregateInput
    campaigns?: CampaignOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    userId?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    price?: FloatNullableFilter<"Product"> | number | null
    sku?: StringNullableFilter<"Product"> | string | null
    imageUrl?: StringNullableFilter<"Product"> | string | null
    featured?: BoolFilter<"Product"> | boolean
    category?: StringNullableFilter<"Product"> | string | null
    stock?: IntNullableFilter<"Product"> | number | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    schedules?: ScheduleListRelationFilter
    campaigns?: CampaignListRelationFilter
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    sku?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    featured?: SortOrder
    category?: SortOrderInput | SortOrder
    stock?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    userId?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    price?: FloatNullableWithAggregatesFilter<"Product"> | number | null
    sku?: StringNullableWithAggregatesFilter<"Product"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Product"> | string | null
    featured?: BoolWithAggregatesFilter<"Product"> | boolean
    category?: StringNullableWithAggregatesFilter<"Product"> | string | null
    stock?: IntNullableWithAggregatesFilter<"Product"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type IncomeWhereInput = {
    AND?: IncomeWhereInput | IncomeWhereInput[]
    OR?: IncomeWhereInput[]
    NOT?: IncomeWhereInput | IncomeWhereInput[]
    id?: StringFilter<"Income"> | string
    source?: StringFilter<"Income"> | string
    amount?: FloatFilter<"Income"> | number
    description?: StringNullableFilter<"Income"> | string | null
    date?: DateTimeFilter<"Income"> | Date | string
    category?: EnumIncomeCategoryFilter<"Income"> | $Enums.IncomeCategory
    createdAt?: DateTimeFilter<"Income"> | Date | string
    updatedAt?: DateTimeFilter<"Income"> | Date | string
  }

  export type IncomeOrderByWithRelationInput = {
    id?: SortOrder
    source?: SortOrder
    amount?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IncomeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IncomeWhereInput | IncomeWhereInput[]
    OR?: IncomeWhereInput[]
    NOT?: IncomeWhereInput | IncomeWhereInput[]
    source?: StringFilter<"Income"> | string
    amount?: FloatFilter<"Income"> | number
    description?: StringNullableFilter<"Income"> | string | null
    date?: DateTimeFilter<"Income"> | Date | string
    category?: EnumIncomeCategoryFilter<"Income"> | $Enums.IncomeCategory
    createdAt?: DateTimeFilter<"Income"> | Date | string
    updatedAt?: DateTimeFilter<"Income"> | Date | string
  }, "id">

  export type IncomeOrderByWithAggregationInput = {
    id?: SortOrder
    source?: SortOrder
    amount?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IncomeCountOrderByAggregateInput
    _avg?: IncomeAvgOrderByAggregateInput
    _max?: IncomeMaxOrderByAggregateInput
    _min?: IncomeMinOrderByAggregateInput
    _sum?: IncomeSumOrderByAggregateInput
  }

  export type IncomeScalarWhereWithAggregatesInput = {
    AND?: IncomeScalarWhereWithAggregatesInput | IncomeScalarWhereWithAggregatesInput[]
    OR?: IncomeScalarWhereWithAggregatesInput[]
    NOT?: IncomeScalarWhereWithAggregatesInput | IncomeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Income"> | string
    source?: StringWithAggregatesFilter<"Income"> | string
    amount?: FloatWithAggregatesFilter<"Income"> | number
    description?: StringNullableWithAggregatesFilter<"Income"> | string | null
    date?: DateTimeWithAggregatesFilter<"Income"> | Date | string
    category?: EnumIncomeCategoryWithAggregatesFilter<"Income"> | $Enums.IncomeCategory
    createdAt?: DateTimeWithAggregatesFilter<"Income"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Income"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    description?: StringNullableFilter<"Payment"> | string | null
    transactionId?: StringNullableFilter<"Payment"> | string | null
    receiptUrl?: StringNullableFilter<"Payment"> | string | null
    invoiceId?: StringNullableFilter<"Payment"> | string | null
    date?: DateTimeFilter<"Payment"> | Date | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    method?: SortOrder
    description?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    receiptUrl?: SortOrderInput | SortOrder
    invoiceId?: SortOrderInput | SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    userId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    description?: StringNullableFilter<"Payment"> | string | null
    transactionId?: StringNullableFilter<"Payment"> | string | null
    receiptUrl?: StringNullableFilter<"Payment"> | string | null
    invoiceId?: StringNullableFilter<"Payment"> | string | null
    date?: DateTimeFilter<"Payment"> | Date | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    method?: SortOrder
    description?: SortOrderInput | SortOrder
    transactionId?: SortOrderInput | SortOrder
    receiptUrl?: SortOrderInput | SortOrder
    invoiceId?: SortOrderInput | SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    userId?: StringWithAggregatesFilter<"Payment"> | string
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    currency?: StringWithAggregatesFilter<"Payment"> | string
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    method?: EnumPaymentMethodWithAggregatesFilter<"Payment"> | $Enums.PaymentMethod
    description?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    transactionId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    receiptUrl?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    invoiceId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    date?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    userId?: StringFilter<"Invoice"> | string
    invoiceNumber?: StringFilter<"Invoice"> | string
    amount?: FloatFilter<"Invoice"> | number
    currency?: StringFilter<"Invoice"> | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    issueDate?: DateTimeFilter<"Invoice"> | Date | string
    description?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    payments?: PaymentListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    invoiceNumber?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    issueDate?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoiceNumber?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    userId?: StringFilter<"Invoice"> | string
    amount?: FloatFilter<"Invoice"> | number
    currency?: StringFilter<"Invoice"> | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    issueDate?: DateTimeFilter<"Invoice"> | Date | string
    description?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    payments?: PaymentListRelationFilter
  }, "id" | "invoiceNumber">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    invoiceNumber?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    issueDate?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    userId?: StringWithAggregatesFilter<"Invoice"> | string
    invoiceNumber?: StringWithAggregatesFilter<"Invoice"> | string
    amount?: FloatWithAggregatesFilter<"Invoice"> | number
    currency?: StringWithAggregatesFilter<"Invoice"> | string
    status?: EnumInvoiceStatusWithAggregatesFilter<"Invoice"> | $Enums.InvoiceStatus
    dueDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    issueDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    description?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type ROASMetricsWhereInput = {
    AND?: ROASMetricsWhereInput | ROASMetricsWhereInput[]
    OR?: ROASMetricsWhereInput[]
    NOT?: ROASMetricsWhereInput | ROASMetricsWhereInput[]
    id?: StringFilter<"ROASMetrics"> | string
    date?: DateTimeFilter<"ROASMetrics"> | Date | string
    adSpend?: FloatFilter<"ROASMetrics"> | number
    revenue?: FloatFilter<"ROASMetrics"> | number
    roasValue?: FloatNullableFilter<"ROASMetrics"> | number | null
    createdAt?: DateTimeFilter<"ROASMetrics"> | Date | string
    updatedAt?: DateTimeFilter<"ROASMetrics"> | Date | string
  }

  export type ROASMetricsOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    adSpend?: SortOrder
    revenue?: SortOrder
    roasValue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ROASMetricsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ROASMetricsWhereInput | ROASMetricsWhereInput[]
    OR?: ROASMetricsWhereInput[]
    NOT?: ROASMetricsWhereInput | ROASMetricsWhereInput[]
    date?: DateTimeFilter<"ROASMetrics"> | Date | string
    adSpend?: FloatFilter<"ROASMetrics"> | number
    revenue?: FloatFilter<"ROASMetrics"> | number
    roasValue?: FloatNullableFilter<"ROASMetrics"> | number | null
    createdAt?: DateTimeFilter<"ROASMetrics"> | Date | string
    updatedAt?: DateTimeFilter<"ROASMetrics"> | Date | string
  }, "id">

  export type ROASMetricsOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    adSpend?: SortOrder
    revenue?: SortOrder
    roasValue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ROASMetricsCountOrderByAggregateInput
    _avg?: ROASMetricsAvgOrderByAggregateInput
    _max?: ROASMetricsMaxOrderByAggregateInput
    _min?: ROASMetricsMinOrderByAggregateInput
    _sum?: ROASMetricsSumOrderByAggregateInput
  }

  export type ROASMetricsScalarWhereWithAggregatesInput = {
    AND?: ROASMetricsScalarWhereWithAggregatesInput | ROASMetricsScalarWhereWithAggregatesInput[]
    OR?: ROASMetricsScalarWhereWithAggregatesInput[]
    NOT?: ROASMetricsScalarWhereWithAggregatesInput | ROASMetricsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ROASMetrics"> | string
    date?: DateTimeWithAggregatesFilter<"ROASMetrics"> | Date | string
    adSpend?: FloatWithAggregatesFilter<"ROASMetrics"> | number
    revenue?: FloatWithAggregatesFilter<"ROASMetrics"> | number
    roasValue?: FloatNullableWithAggregatesFilter<"ROASMetrics"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ROASMetrics"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ROASMetrics"> | Date | string
  }

  export type ConversionMetricsWhereInput = {
    AND?: ConversionMetricsWhereInput | ConversionMetricsWhereInput[]
    OR?: ConversionMetricsWhereInput[]
    NOT?: ConversionMetricsWhereInput | ConversionMetricsWhereInput[]
    id?: StringFilter<"ConversionMetrics"> | string
    date?: DateTimeFilter<"ConversionMetrics"> | Date | string
    source?: StringNullableFilter<"ConversionMetrics"> | string | null
    medium?: StringNullableFilter<"ConversionMetrics"> | string | null
    campaign?: StringNullableFilter<"ConversionMetrics"> | string | null
    landingPage?: StringNullableFilter<"ConversionMetrics"> | string | null
    pageViews?: IntFilter<"ConversionMetrics"> | number
    uniqueVisitors?: IntFilter<"ConversionMetrics"> | number
    conversions?: IntFilter<"ConversionMetrics"> | number
    conversionValue?: FloatFilter<"ConversionMetrics"> | number
    conversionRate?: FloatNullableFilter<"ConversionMetrics"> | number | null
    createdAt?: DateTimeFilter<"ConversionMetrics"> | Date | string
    updatedAt?: DateTimeFilter<"ConversionMetrics"> | Date | string
  }

  export type ConversionMetricsOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    source?: SortOrderInput | SortOrder
    medium?: SortOrderInput | SortOrder
    campaign?: SortOrderInput | SortOrder
    landingPage?: SortOrderInput | SortOrder
    pageViews?: SortOrder
    uniqueVisitors?: SortOrder
    conversions?: SortOrder
    conversionValue?: SortOrder
    conversionRate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversionMetricsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConversionMetricsWhereInput | ConversionMetricsWhereInput[]
    OR?: ConversionMetricsWhereInput[]
    NOT?: ConversionMetricsWhereInput | ConversionMetricsWhereInput[]
    date?: DateTimeFilter<"ConversionMetrics"> | Date | string
    source?: StringNullableFilter<"ConversionMetrics"> | string | null
    medium?: StringNullableFilter<"ConversionMetrics"> | string | null
    campaign?: StringNullableFilter<"ConversionMetrics"> | string | null
    landingPage?: StringNullableFilter<"ConversionMetrics"> | string | null
    pageViews?: IntFilter<"ConversionMetrics"> | number
    uniqueVisitors?: IntFilter<"ConversionMetrics"> | number
    conversions?: IntFilter<"ConversionMetrics"> | number
    conversionValue?: FloatFilter<"ConversionMetrics"> | number
    conversionRate?: FloatNullableFilter<"ConversionMetrics"> | number | null
    createdAt?: DateTimeFilter<"ConversionMetrics"> | Date | string
    updatedAt?: DateTimeFilter<"ConversionMetrics"> | Date | string
  }, "id">

  export type ConversionMetricsOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    source?: SortOrderInput | SortOrder
    medium?: SortOrderInput | SortOrder
    campaign?: SortOrderInput | SortOrder
    landingPage?: SortOrderInput | SortOrder
    pageViews?: SortOrder
    uniqueVisitors?: SortOrder
    conversions?: SortOrder
    conversionValue?: SortOrder
    conversionRate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConversionMetricsCountOrderByAggregateInput
    _avg?: ConversionMetricsAvgOrderByAggregateInput
    _max?: ConversionMetricsMaxOrderByAggregateInput
    _min?: ConversionMetricsMinOrderByAggregateInput
    _sum?: ConversionMetricsSumOrderByAggregateInput
  }

  export type ConversionMetricsScalarWhereWithAggregatesInput = {
    AND?: ConversionMetricsScalarWhereWithAggregatesInput | ConversionMetricsScalarWhereWithAggregatesInput[]
    OR?: ConversionMetricsScalarWhereWithAggregatesInput[]
    NOT?: ConversionMetricsScalarWhereWithAggregatesInput | ConversionMetricsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConversionMetrics"> | string
    date?: DateTimeWithAggregatesFilter<"ConversionMetrics"> | Date | string
    source?: StringNullableWithAggregatesFilter<"ConversionMetrics"> | string | null
    medium?: StringNullableWithAggregatesFilter<"ConversionMetrics"> | string | null
    campaign?: StringNullableWithAggregatesFilter<"ConversionMetrics"> | string | null
    landingPage?: StringNullableWithAggregatesFilter<"ConversionMetrics"> | string | null
    pageViews?: IntWithAggregatesFilter<"ConversionMetrics"> | number
    uniqueVisitors?: IntWithAggregatesFilter<"ConversionMetrics"> | number
    conversions?: IntWithAggregatesFilter<"ConversionMetrics"> | number
    conversionValue?: FloatWithAggregatesFilter<"ConversionMetrics"> | number
    conversionRate?: FloatNullableWithAggregatesFilter<"ConversionMetrics"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"ConversionMetrics"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ConversionMetrics"> | Date | string
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    color?: StringNullableFilter<"Tag"> | string | null
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    campaigns?: TagsOnCampaignsListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    campaigns?: TagsOnCampaignsOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    color?: StringNullableFilter<"Tag"> | string | null
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    campaigns?: TagsOnCampaignsListRelationFilter
  }, "id" | "name">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tag"> | string
    name?: StringWithAggregatesFilter<"Tag"> | string
    color?: StringNullableWithAggregatesFilter<"Tag"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
  }

  export type TagsOnCampaignsWhereInput = {
    AND?: TagsOnCampaignsWhereInput | TagsOnCampaignsWhereInput[]
    OR?: TagsOnCampaignsWhereInput[]
    NOT?: TagsOnCampaignsWhereInput | TagsOnCampaignsWhereInput[]
    tagId?: StringFilter<"TagsOnCampaigns"> | string
    campaignId?: StringFilter<"TagsOnCampaigns"> | string
    assignedAt?: DateTimeFilter<"TagsOnCampaigns"> | Date | string
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }

  export type TagsOnCampaignsOrderByWithRelationInput = {
    tagId?: SortOrder
    campaignId?: SortOrder
    assignedAt?: SortOrder
    tag?: TagOrderByWithRelationInput
    campaign?: CampaignOrderByWithRelationInput
  }

  export type TagsOnCampaignsWhereUniqueInput = Prisma.AtLeast<{
    tagId_campaignId?: TagsOnCampaignsTagIdCampaignIdCompoundUniqueInput
    AND?: TagsOnCampaignsWhereInput | TagsOnCampaignsWhereInput[]
    OR?: TagsOnCampaignsWhereInput[]
    NOT?: TagsOnCampaignsWhereInput | TagsOnCampaignsWhereInput[]
    tagId?: StringFilter<"TagsOnCampaigns"> | string
    campaignId?: StringFilter<"TagsOnCampaigns"> | string
    assignedAt?: DateTimeFilter<"TagsOnCampaigns"> | Date | string
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
    campaign?: XOR<CampaignScalarRelationFilter, CampaignWhereInput>
  }, "tagId_campaignId">

  export type TagsOnCampaignsOrderByWithAggregationInput = {
    tagId?: SortOrder
    campaignId?: SortOrder
    assignedAt?: SortOrder
    _count?: TagsOnCampaignsCountOrderByAggregateInput
    _max?: TagsOnCampaignsMaxOrderByAggregateInput
    _min?: TagsOnCampaignsMinOrderByAggregateInput
  }

  export type TagsOnCampaignsScalarWhereWithAggregatesInput = {
    AND?: TagsOnCampaignsScalarWhereWithAggregatesInput | TagsOnCampaignsScalarWhereWithAggregatesInput[]
    OR?: TagsOnCampaignsScalarWhereWithAggregatesInput[]
    NOT?: TagsOnCampaignsScalarWhereWithAggregatesInput | TagsOnCampaignsScalarWhereWithAggregatesInput[]
    tagId?: StringWithAggregatesFilter<"TagsOnCampaigns"> | string
    campaignId?: StringWithAggregatesFilter<"TagsOnCampaigns"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"TagsOnCampaigns"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type SettingWhereInput = {
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    id?: StringFilter<"Setting"> | string
    key?: StringFilter<"Setting"> | string
    value?: StringFilter<"Setting"> | string
    description?: StringNullableFilter<"Setting"> | string | null
    createdAt?: DateTimeFilter<"Setting"> | Date | string
    updatedAt?: DateTimeFilter<"Setting"> | Date | string
  }

  export type SettingOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    value?: StringFilter<"Setting"> | string
    description?: StringNullableFilter<"Setting"> | string | null
    createdAt?: DateTimeFilter<"Setting"> | Date | string
    updatedAt?: DateTimeFilter<"Setting"> | Date | string
  }, "id" | "key">

  export type SettingOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SettingCountOrderByAggregateInput
    _max?: SettingMaxOrderByAggregateInput
    _min?: SettingMinOrderByAggregateInput
  }

  export type SettingScalarWhereWithAggregatesInput = {
    AND?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    OR?: SettingScalarWhereWithAggregatesInput[]
    NOT?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Setting"> | string
    key?: StringWithAggregatesFilter<"Setting"> | string
    value?: StringWithAggregatesFilter<"Setting"> | string
    description?: StringNullableWithAggregatesFilter<"Setting"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Setting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Setting"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    metaAccounts?: MetaAccountCreateNestedManyWithoutUserInput
    socialAccounts?: SocialMediaAccountCreateNestedManyWithoutUserInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    adsets?: AdSetCreateNestedManyWithoutUserInput
    ads?: AdCreateNestedManyWithoutUserInput
    schedules?: ScheduleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    influencers?: InfluencerCreateNestedManyWithoutUserInput
    clinics?: ClinicCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    metaAccounts?: MetaAccountUncheckedCreateNestedManyWithoutUserInput
    socialAccounts?: SocialMediaAccountUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    adsets?: AdSetUncheckedCreateNestedManyWithoutUserInput
    ads?: AdUncheckedCreateNestedManyWithoutUserInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    influencers?: InfluencerUncheckedCreateNestedManyWithoutUserInput
    clinics?: ClinicUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaAccounts?: MetaAccountUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialMediaAccountUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    adsets?: AdSetUpdateManyWithoutUserNestedInput
    ads?: AdUpdateManyWithoutUserNestedInput
    schedules?: ScheduleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    influencers?: InfluencerUpdateManyWithoutUserNestedInput
    clinics?: ClinicUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaAccounts?: MetaAccountUncheckedUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialMediaAccountUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    adsets?: AdSetUncheckedUpdateManyWithoutUserNestedInput
    ads?: AdUncheckedUpdateManyWithoutUserNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    influencers?: InfluencerUncheckedUpdateManyWithoutUserNestedInput
    clinics?: ClinicUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MetaAccountCreateInput = {
    id?: string
    metaAccountId: string
    accessToken: string
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    businessName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMetaAccountsInput
    campaigns?: CampaignCreateNestedManyWithoutMetaAccountInput
    adSets?: AdSetCreateNestedManyWithoutMetaAccountInput
    ads?: AdCreateNestedManyWithoutMetaAccountInput
    adAccounts?: AdAccountCreateNestedManyWithoutMetaAccountInput
  }

  export type MetaAccountUncheckedCreateInput = {
    id?: string
    userId: string
    metaAccountId: string
    accessToken: string
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    businessName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignUncheckedCreateNestedManyWithoutMetaAccountInput
    adSets?: AdSetUncheckedCreateNestedManyWithoutMetaAccountInput
    ads?: AdUncheckedCreateNestedManyWithoutMetaAccountInput
    adAccounts?: AdAccountUncheckedCreateNestedManyWithoutMetaAccountInput
  }

  export type MetaAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    metaAccountId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMetaAccountsNestedInput
    campaigns?: CampaignUpdateManyWithoutMetaAccountNestedInput
    adSets?: AdSetUpdateManyWithoutMetaAccountNestedInput
    ads?: AdUpdateManyWithoutMetaAccountNestedInput
    adAccounts?: AdAccountUpdateManyWithoutMetaAccountNestedInput
  }

  export type MetaAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    metaAccountId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUncheckedUpdateManyWithoutMetaAccountNestedInput
    adSets?: AdSetUncheckedUpdateManyWithoutMetaAccountNestedInput
    ads?: AdUncheckedUpdateManyWithoutMetaAccountNestedInput
    adAccounts?: AdAccountUncheckedUpdateManyWithoutMetaAccountNestedInput
  }

  export type MetaAccountCreateManyInput = {
    id?: string
    userId: string
    metaAccountId: string
    accessToken: string
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    businessName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MetaAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    metaAccountId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MetaAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    metaAccountId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdAccountCreateInput = {
    id?: string
    adAccountId: string
    name: string
    currency: string
    timezone: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    metaAccount: MetaAccountCreateNestedOneWithoutAdAccountsInput
    campaigns?: CampaignCreateNestedManyWithoutAdAccountInput
  }

  export type AdAccountUncheckedCreateInput = {
    id?: string
    metaAccountId: string
    adAccountId: string
    name: string
    currency: string
    timezone: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignUncheckedCreateNestedManyWithoutAdAccountInput
  }

  export type AdAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adAccountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaAccount?: MetaAccountUpdateOneRequiredWithoutAdAccountsNestedInput
    campaigns?: CampaignUpdateManyWithoutAdAccountNestedInput
  }

  export type AdAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    metaAccountId?: StringFieldUpdateOperationsInput | string
    adAccountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUncheckedUpdateManyWithoutAdAccountNestedInput
  }

  export type AdAccountCreateManyInput = {
    id?: string
    metaAccountId: string
    adAccountId: string
    name: string
    currency: string
    timezone: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    adAccountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    metaAccountId?: StringFieldUpdateOperationsInput | string
    adAccountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignCreateInput = {
    id?: string
    campaignId?: string | null
    name: string
    objective: string
    status: $Enums.CampaignStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCampaignsInput
    metaAccount?: MetaAccountCreateNestedOneWithoutCampaignsInput
    adAccount?: AdAccountCreateNestedOneWithoutCampaignsInput
    adSets?: AdSetCreateNestedManyWithoutCampaignInput
    tags?: TagsOnCampaignsCreateNestedManyWithoutCampaignInput
    metrics?: CampaignMetricsCreateNestedManyWithoutCampaignInput
    clinic?: ClinicCreateNestedOneWithoutCampaignsInput
    product?: ProductCreateNestedOneWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateInput = {
    id?: string
    userId: string
    metaAccountId?: string | null
    adAccountId?: string | null
    campaignId?: string | null
    name: string
    objective: string
    status: $Enums.CampaignStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinicId?: string | null
    productId?: string | null
    adSets?: AdSetUncheckedCreateNestedManyWithoutCampaignInput
    tags?: TagsOnCampaignsUncheckedCreateNestedManyWithoutCampaignInput
    metrics?: CampaignMetricsUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCampaignsNestedInput
    metaAccount?: MetaAccountUpdateOneWithoutCampaignsNestedInput
    adAccount?: AdAccountUpdateOneWithoutCampaignsNestedInput
    adSets?: AdSetUpdateManyWithoutCampaignNestedInput
    tags?: TagsOnCampaignsUpdateManyWithoutCampaignNestedInput
    metrics?: CampaignMetricsUpdateManyWithoutCampaignNestedInput
    clinic?: ClinicUpdateOneWithoutCampaignsNestedInput
    product?: ProductUpdateOneWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    metaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    adAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    adSets?: AdSetUncheckedUpdateManyWithoutCampaignNestedInput
    tags?: TagsOnCampaignsUncheckedUpdateManyWithoutCampaignNestedInput
    metrics?: CampaignMetricsUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignCreateManyInput = {
    id?: string
    userId: string
    metaAccountId?: string | null
    adAccountId?: string | null
    campaignId?: string | null
    name: string
    objective: string
    status: $Enums.CampaignStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinicId?: string | null
    productId?: string | null
  }

  export type CampaignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    metaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    adAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CampaignMetricsCreateInput = {
    id?: string
    date: Date | string
    impressions?: number
    clicks?: number
    reach?: number
    spend?: number
    conversions?: number
    costPerResult?: number | null
    ctr?: number | null
    cpc?: number | null
    cpm?: number | null
    frequency?: number | null
    campaign: CampaignCreateNestedOneWithoutMetricsInput
  }

  export type CampaignMetricsUncheckedCreateInput = {
    id?: string
    campaignId: string
    date: Date | string
    impressions?: number
    clicks?: number
    reach?: number
    spend?: number
    conversions?: number
    costPerResult?: number | null
    ctr?: number | null
    cpc?: number | null
    cpm?: number | null
    frequency?: number | null
  }

  export type CampaignMetricsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    reach?: IntFieldUpdateOperationsInput | number
    spend?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    costPerResult?: NullableFloatFieldUpdateOperationsInput | number | null
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    cpc?: NullableFloatFieldUpdateOperationsInput | number | null
    cpm?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
    campaign?: CampaignUpdateOneRequiredWithoutMetricsNestedInput
  }

  export type CampaignMetricsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    reach?: IntFieldUpdateOperationsInput | number
    spend?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    costPerResult?: NullableFloatFieldUpdateOperationsInput | number | null
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    cpc?: NullableFloatFieldUpdateOperationsInput | number | null
    cpm?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CampaignMetricsCreateManyInput = {
    id?: string
    campaignId: string
    date: Date | string
    impressions?: number
    clicks?: number
    reach?: number
    spend?: number
    conversions?: number
    costPerResult?: number | null
    ctr?: number | null
    cpc?: number | null
    cpm?: number | null
    frequency?: number | null
  }

  export type CampaignMetricsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    reach?: IntFieldUpdateOperationsInput | number
    spend?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    costPerResult?: NullableFloatFieldUpdateOperationsInput | number | null
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    cpc?: NullableFloatFieldUpdateOperationsInput | number | null
    cpm?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CampaignMetricsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    reach?: IntFieldUpdateOperationsInput | number
    spend?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    costPerResult?: NullableFloatFieldUpdateOperationsInput | number | null
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    cpc?: NullableFloatFieldUpdateOperationsInput | number | null
    cpm?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type AdSetCreateInput = {
    id?: string
    adSetId?: string | null
    name: string
    status: $Enums.AdSetStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    bidStrategy?: string | null
    bidAmount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targeting?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAdsetsInput
    campaign: CampaignCreateNestedOneWithoutAdSetsInput
    metaAccount?: MetaAccountCreateNestedOneWithoutAdSetsInput
    ads?: AdCreateNestedManyWithoutAdSetInput
    metrics?: AdSetMetricsCreateNestedManyWithoutAdSetInput
  }

  export type AdSetUncheckedCreateInput = {
    id?: string
    userId: string
    campaignId: string
    metaAccountId?: string | null
    adSetId?: string | null
    name: string
    status: $Enums.AdSetStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    bidStrategy?: string | null
    bidAmount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targeting?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ads?: AdUncheckedCreateNestedManyWithoutAdSetInput
    metrics?: AdSetMetricsUncheckedCreateNestedManyWithoutAdSetInput
  }

  export type AdSetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adSetId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAdSetStatusFieldUpdateOperationsInput | $Enums.AdSetStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    bidStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    bidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targeting?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdsetsNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutAdSetsNestedInput
    metaAccount?: MetaAccountUpdateOneWithoutAdSetsNestedInput
    ads?: AdUpdateManyWithoutAdSetNestedInput
    metrics?: AdSetMetricsUpdateManyWithoutAdSetNestedInput
  }

  export type AdSetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    metaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    adSetId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAdSetStatusFieldUpdateOperationsInput | $Enums.AdSetStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    bidStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    bidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targeting?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ads?: AdUncheckedUpdateManyWithoutAdSetNestedInput
    metrics?: AdSetMetricsUncheckedUpdateManyWithoutAdSetNestedInput
  }

  export type AdSetCreateManyInput = {
    id?: string
    userId: string
    campaignId: string
    metaAccountId?: string | null
    adSetId?: string | null
    name: string
    status: $Enums.AdSetStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    bidStrategy?: string | null
    bidAmount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targeting?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdSetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    adSetId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAdSetStatusFieldUpdateOperationsInput | $Enums.AdSetStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    bidStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    bidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targeting?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdSetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    metaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    adSetId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAdSetStatusFieldUpdateOperationsInput | $Enums.AdSetStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    bidStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    bidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targeting?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdSetMetricsCreateInput = {
    id?: string
    date: Date | string
    impressions?: number
    clicks?: number
    reach?: number
    spend?: number
    conversions?: number
    costPerResult?: number | null
    ctr?: number | null
    cpc?: number | null
    cpm?: number | null
    frequency?: number | null
    adSet: AdSetCreateNestedOneWithoutMetricsInput
  }

  export type AdSetMetricsUncheckedCreateInput = {
    id?: string
    adSetId: string
    date: Date | string
    impressions?: number
    clicks?: number
    reach?: number
    spend?: number
    conversions?: number
    costPerResult?: number | null
    ctr?: number | null
    cpc?: number | null
    cpm?: number | null
    frequency?: number | null
  }

  export type AdSetMetricsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    reach?: IntFieldUpdateOperationsInput | number
    spend?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    costPerResult?: NullableFloatFieldUpdateOperationsInput | number | null
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    cpc?: NullableFloatFieldUpdateOperationsInput | number | null
    cpm?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
    adSet?: AdSetUpdateOneRequiredWithoutMetricsNestedInput
  }

  export type AdSetMetricsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adSetId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    reach?: IntFieldUpdateOperationsInput | number
    spend?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    costPerResult?: NullableFloatFieldUpdateOperationsInput | number | null
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    cpc?: NullableFloatFieldUpdateOperationsInput | number | null
    cpm?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type AdSetMetricsCreateManyInput = {
    id?: string
    adSetId: string
    date: Date | string
    impressions?: number
    clicks?: number
    reach?: number
    spend?: number
    conversions?: number
    costPerResult?: number | null
    ctr?: number | null
    cpc?: number | null
    cpm?: number | null
    frequency?: number | null
  }

  export type AdSetMetricsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    reach?: IntFieldUpdateOperationsInput | number
    spend?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    costPerResult?: NullableFloatFieldUpdateOperationsInput | number | null
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    cpc?: NullableFloatFieldUpdateOperationsInput | number | null
    cpm?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type AdSetMetricsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adSetId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    reach?: IntFieldUpdateOperationsInput | number
    spend?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    costPerResult?: NullableFloatFieldUpdateOperationsInput | number | null
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    cpc?: NullableFloatFieldUpdateOperationsInput | number | null
    cpm?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type AdCreateInput = {
    id?: string
    adId?: string | null
    name: string
    status: $Enums.AdStatus
    headline?: string | null
    description?: string | null
    creativeType?: $Enums.CreativeType | null
    imageUrl?: string | null
    videoUrl?: string | null
    destinationUrl?: string | null
    callToAction?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAdsInput
    adSet: AdSetCreateNestedOneWithoutAdsInput
    metaAccount?: MetaAccountCreateNestedOneWithoutAdsInput
    metrics?: AdMetricsCreateNestedManyWithoutAdInput
    schedules?: ScheduleCreateNestedManyWithoutAdInput
  }

  export type AdUncheckedCreateInput = {
    id?: string
    userId: string
    adSetId: string
    metaAccountId?: string | null
    adId?: string | null
    name: string
    status: $Enums.AdStatus
    headline?: string | null
    description?: string | null
    creativeType?: $Enums.CreativeType | null
    imageUrl?: string | null
    videoUrl?: string | null
    destinationUrl?: string | null
    callToAction?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metrics?: AdMetricsUncheckedCreateNestedManyWithoutAdInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutAdInput
  }

  export type AdUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAdStatusFieldUpdateOperationsInput | $Enums.AdStatus
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creativeType?: NullableEnumCreativeTypeFieldUpdateOperationsInput | $Enums.CreativeType | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    destinationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    callToAction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdsNestedInput
    adSet?: AdSetUpdateOneRequiredWithoutAdsNestedInput
    metaAccount?: MetaAccountUpdateOneWithoutAdsNestedInput
    metrics?: AdMetricsUpdateManyWithoutAdNestedInput
    schedules?: ScheduleUpdateManyWithoutAdNestedInput
  }

  export type AdUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    adSetId?: StringFieldUpdateOperationsInput | string
    metaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    adId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAdStatusFieldUpdateOperationsInput | $Enums.AdStatus
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creativeType?: NullableEnumCreativeTypeFieldUpdateOperationsInput | $Enums.CreativeType | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    destinationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    callToAction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: AdMetricsUncheckedUpdateManyWithoutAdNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutAdNestedInput
  }

  export type AdCreateManyInput = {
    id?: string
    userId: string
    adSetId: string
    metaAccountId?: string | null
    adId?: string | null
    name: string
    status: $Enums.AdStatus
    headline?: string | null
    description?: string | null
    creativeType?: $Enums.CreativeType | null
    imageUrl?: string | null
    videoUrl?: string | null
    destinationUrl?: string | null
    callToAction?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    adId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAdStatusFieldUpdateOperationsInput | $Enums.AdStatus
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creativeType?: NullableEnumCreativeTypeFieldUpdateOperationsInput | $Enums.CreativeType | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    destinationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    callToAction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    adSetId?: StringFieldUpdateOperationsInput | string
    metaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    adId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAdStatusFieldUpdateOperationsInput | $Enums.AdStatus
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creativeType?: NullableEnumCreativeTypeFieldUpdateOperationsInput | $Enums.CreativeType | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    destinationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    callToAction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdMetricsCreateInput = {
    id?: string
    date: Date | string
    impressions?: number
    clicks?: number
    reach?: number
    spend?: number
    conversions?: number
    costPerResult?: number | null
    ctr?: number | null
    cpc?: number | null
    cpm?: number | null
    frequency?: number | null
    engagements?: number
    shares?: number
    comments?: number
    saves?: number
    ad: AdCreateNestedOneWithoutMetricsInput
  }

  export type AdMetricsUncheckedCreateInput = {
    id?: string
    adId: string
    date: Date | string
    impressions?: number
    clicks?: number
    reach?: number
    spend?: number
    conversions?: number
    costPerResult?: number | null
    ctr?: number | null
    cpc?: number | null
    cpm?: number | null
    frequency?: number | null
    engagements?: number
    shares?: number
    comments?: number
    saves?: number
  }

  export type AdMetricsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    reach?: IntFieldUpdateOperationsInput | number
    spend?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    costPerResult?: NullableFloatFieldUpdateOperationsInput | number | null
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    cpc?: NullableFloatFieldUpdateOperationsInput | number | null
    cpm?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
    engagements?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    saves?: IntFieldUpdateOperationsInput | number
    ad?: AdUpdateOneRequiredWithoutMetricsNestedInput
  }

  export type AdMetricsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    reach?: IntFieldUpdateOperationsInput | number
    spend?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    costPerResult?: NullableFloatFieldUpdateOperationsInput | number | null
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    cpc?: NullableFloatFieldUpdateOperationsInput | number | null
    cpm?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
    engagements?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    saves?: IntFieldUpdateOperationsInput | number
  }

  export type AdMetricsCreateManyInput = {
    id?: string
    adId: string
    date: Date | string
    impressions?: number
    clicks?: number
    reach?: number
    spend?: number
    conversions?: number
    costPerResult?: number | null
    ctr?: number | null
    cpc?: number | null
    cpm?: number | null
    frequency?: number | null
    engagements?: number
    shares?: number
    comments?: number
    saves?: number
  }

  export type AdMetricsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    reach?: IntFieldUpdateOperationsInput | number
    spend?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    costPerResult?: NullableFloatFieldUpdateOperationsInput | number | null
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    cpc?: NullableFloatFieldUpdateOperationsInput | number | null
    cpm?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
    engagements?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    saves?: IntFieldUpdateOperationsInput | number
  }

  export type AdMetricsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    reach?: IntFieldUpdateOperationsInput | number
    spend?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    costPerResult?: NullableFloatFieldUpdateOperationsInput | number | null
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    cpc?: NullableFloatFieldUpdateOperationsInput | number | null
    cpm?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
    engagements?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    saves?: IntFieldUpdateOperationsInput | number
  }

  export type ScheduleCreateInput = {
    id?: string
    title: string
    startDate: Date | string
    endDate: Date | string
    status: $Enums.ScheduleStatus
    priority?: $Enums.SchedulePriority
    category?: $Enums.ScheduleCategory | null
    recurrence?: $Enums.RecurrencePattern | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSchedulesInput
    ad?: AdCreateNestedOneWithoutSchedulesInput
    clinic?: ClinicCreateNestedOneWithoutSchedulesInput
    product?: ProductCreateNestedOneWithoutSchedulesInput
  }

  export type ScheduleUncheckedCreateInput = {
    id?: string
    userId: string
    adId?: string | null
    title: string
    startDate: Date | string
    endDate: Date | string
    status: $Enums.ScheduleStatus
    priority?: $Enums.SchedulePriority
    category?: $Enums.ScheduleCategory | null
    clinicId?: string | null
    productId?: string | null
    recurrence?: $Enums.RecurrencePattern | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumScheduleStatusFieldUpdateOperationsInput | $Enums.ScheduleStatus
    priority?: EnumSchedulePriorityFieldUpdateOperationsInput | $Enums.SchedulePriority
    category?: NullableEnumScheduleCategoryFieldUpdateOperationsInput | $Enums.ScheduleCategory | null
    recurrence?: NullableEnumRecurrencePatternFieldUpdateOperationsInput | $Enums.RecurrencePattern | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSchedulesNestedInput
    ad?: AdUpdateOneWithoutSchedulesNestedInput
    clinic?: ClinicUpdateOneWithoutSchedulesNestedInput
    product?: ProductUpdateOneWithoutSchedulesNestedInput
  }

  export type ScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    adId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumScheduleStatusFieldUpdateOperationsInput | $Enums.ScheduleStatus
    priority?: EnumSchedulePriorityFieldUpdateOperationsInput | $Enums.SchedulePriority
    category?: NullableEnumScheduleCategoryFieldUpdateOperationsInput | $Enums.ScheduleCategory | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    recurrence?: NullableEnumRecurrencePatternFieldUpdateOperationsInput | $Enums.RecurrencePattern | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleCreateManyInput = {
    id?: string
    userId: string
    adId?: string | null
    title: string
    startDate: Date | string
    endDate: Date | string
    status: $Enums.ScheduleStatus
    priority?: $Enums.SchedulePriority
    category?: $Enums.ScheduleCategory | null
    clinicId?: string | null
    productId?: string | null
    recurrence?: $Enums.RecurrencePattern | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumScheduleStatusFieldUpdateOperationsInput | $Enums.ScheduleStatus
    priority?: EnumSchedulePriorityFieldUpdateOperationsInput | $Enums.SchedulePriority
    category?: NullableEnumScheduleCategoryFieldUpdateOperationsInput | $Enums.ScheduleCategory | null
    recurrence?: NullableEnumRecurrencePatternFieldUpdateOperationsInput | $Enums.RecurrencePattern | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    adId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumScheduleStatusFieldUpdateOperationsInput | $Enums.ScheduleStatus
    priority?: EnumSchedulePriorityFieldUpdateOperationsInput | $Enums.SchedulePriority
    category?: NullableEnumScheduleCategoryFieldUpdateOperationsInput | $Enums.ScheduleCategory | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    recurrence?: NullableEnumRecurrencePatternFieldUpdateOperationsInput | $Enums.RecurrencePattern | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdsPlannerCreateInput = {
    id?: string
    name: string
    description?: string | null
    objective: $Enums.CampaignObjective
    budgetType: $Enums.BudgetType
    budgetAmount: number
    whatsappNumber?: string | null
    startDate: Date | string
    endDate: Date | string
    location?: string | null
    minAge?: number | null
    maxAge?: number | null
    gender?: $Enums.GenderTarget | null
    detailTargeting?: string | null
    videoUrl?: string | null
    websiteUrl?: string | null
    primaryText?: string | null
    headline?: string | null
    ctaName?: string | null
    ctaText?: string | null
    preFilledMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    planItems?: PlannerItemCreateNestedManyWithoutPlannerInput
  }

  export type AdsPlannerUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    objective: $Enums.CampaignObjective
    budgetType: $Enums.BudgetType
    budgetAmount: number
    whatsappNumber?: string | null
    startDate: Date | string
    endDate: Date | string
    location?: string | null
    minAge?: number | null
    maxAge?: number | null
    gender?: $Enums.GenderTarget | null
    detailTargeting?: string | null
    videoUrl?: string | null
    websiteUrl?: string | null
    primaryText?: string | null
    headline?: string | null
    ctaName?: string | null
    ctaText?: string | null
    preFilledMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    planItems?: PlannerItemUncheckedCreateNestedManyWithoutPlannerInput
  }

  export type AdsPlannerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objective?: EnumCampaignObjectiveFieldUpdateOperationsInput | $Enums.CampaignObjective
    budgetType?: EnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType
    budgetAmount?: FloatFieldUpdateOperationsInput | number
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    minAge?: NullableIntFieldUpdateOperationsInput | number | null
    maxAge?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableEnumGenderTargetFieldUpdateOperationsInput | $Enums.GenderTarget | null
    detailTargeting?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryText?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    ctaName?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    preFilledMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planItems?: PlannerItemUpdateManyWithoutPlannerNestedInput
  }

  export type AdsPlannerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objective?: EnumCampaignObjectiveFieldUpdateOperationsInput | $Enums.CampaignObjective
    budgetType?: EnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType
    budgetAmount?: FloatFieldUpdateOperationsInput | number
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    minAge?: NullableIntFieldUpdateOperationsInput | number | null
    maxAge?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableEnumGenderTargetFieldUpdateOperationsInput | $Enums.GenderTarget | null
    detailTargeting?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryText?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    ctaName?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    preFilledMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planItems?: PlannerItemUncheckedUpdateManyWithoutPlannerNestedInput
  }

  export type AdsPlannerCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    objective: $Enums.CampaignObjective
    budgetType: $Enums.BudgetType
    budgetAmount: number
    whatsappNumber?: string | null
    startDate: Date | string
    endDate: Date | string
    location?: string | null
    minAge?: number | null
    maxAge?: number | null
    gender?: $Enums.GenderTarget | null
    detailTargeting?: string | null
    videoUrl?: string | null
    websiteUrl?: string | null
    primaryText?: string | null
    headline?: string | null
    ctaName?: string | null
    ctaText?: string | null
    preFilledMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdsPlannerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objective?: EnumCampaignObjectiveFieldUpdateOperationsInput | $Enums.CampaignObjective
    budgetType?: EnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType
    budgetAmount?: FloatFieldUpdateOperationsInput | number
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    minAge?: NullableIntFieldUpdateOperationsInput | number | null
    maxAge?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableEnumGenderTargetFieldUpdateOperationsInput | $Enums.GenderTarget | null
    detailTargeting?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryText?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    ctaName?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    preFilledMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdsPlannerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objective?: EnumCampaignObjectiveFieldUpdateOperationsInput | $Enums.CampaignObjective
    budgetType?: EnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType
    budgetAmount?: FloatFieldUpdateOperationsInput | number
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    minAge?: NullableIntFieldUpdateOperationsInput | number | null
    maxAge?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableEnumGenderTargetFieldUpdateOperationsInput | $Enums.GenderTarget | null
    detailTargeting?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryText?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    ctaName?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    preFilledMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlannerItemCreateInput = {
    id?: string
    title: string
    description?: string | null
    platform: $Enums.PlatformType
    format?: string | null
    budget?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: $Enums.PlannerItemStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    planner: AdsPlannerCreateNestedOneWithoutPlanItemsInput
  }

  export type PlannerItemUncheckedCreateInput = {
    id?: string
    plannerId: string
    title: string
    description?: string | null
    platform: $Enums.PlatformType
    format?: string | null
    budget?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: $Enums.PlannerItemStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlannerItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | $Enums.PlatformType
    format?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPlannerItemStatusFieldUpdateOperationsInput | $Enums.PlannerItemStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planner?: AdsPlannerUpdateOneRequiredWithoutPlanItemsNestedInput
  }

  export type PlannerItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    plannerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | $Enums.PlatformType
    format?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPlannerItemStatusFieldUpdateOperationsInput | $Enums.PlannerItemStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlannerItemCreateManyInput = {
    id?: string
    plannerId: string
    title: string
    description?: string | null
    platform: $Enums.PlatformType
    format?: string | null
    budget?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: $Enums.PlannerItemStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlannerItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | $Enums.PlatformType
    format?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPlannerItemStatusFieldUpdateOperationsInput | $Enums.PlannerItemStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlannerItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    plannerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | $Enums.PlatformType
    format?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPlannerItemStatusFieldUpdateOperationsInput | $Enums.PlannerItemStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialMediaAccountCreateInput = {
    id?: string
    platform: $Enums.PlatformType
    accountName: string
    accountId?: string | null
    followers?: number
    accessToken?: string | null
    tokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSocialAccountsInput
    platformMetrics?: PlatformMetricsCreateNestedManyWithoutAccountInput
    engagementMetrics?: EngagementMetricsCreateNestedManyWithoutAccountInput
    influencers?: InfluencerCreateNestedManyWithoutAccountInput
  }

  export type SocialMediaAccountUncheckedCreateInput = {
    id?: string
    userId: string
    platform: $Enums.PlatformType
    accountName: string
    accountId?: string | null
    followers?: number
    accessToken?: string | null
    tokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    platformMetrics?: PlatformMetricsUncheckedCreateNestedManyWithoutAccountInput
    engagementMetrics?: EngagementMetricsUncheckedCreateNestedManyWithoutAccountInput
    influencers?: InfluencerUncheckedCreateNestedManyWithoutAccountInput
  }

  export type SocialMediaAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | $Enums.PlatformType
    accountName?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    followers?: IntFieldUpdateOperationsInput | number
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSocialAccountsNestedInput
    platformMetrics?: PlatformMetricsUpdateManyWithoutAccountNestedInput
    engagementMetrics?: EngagementMetricsUpdateManyWithoutAccountNestedInput
    influencers?: InfluencerUpdateManyWithoutAccountNestedInput
  }

  export type SocialMediaAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | $Enums.PlatformType
    accountName?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    followers?: IntFieldUpdateOperationsInput | number
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platformMetrics?: PlatformMetricsUncheckedUpdateManyWithoutAccountNestedInput
    engagementMetrics?: EngagementMetricsUncheckedUpdateManyWithoutAccountNestedInput
    influencers?: InfluencerUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type SocialMediaAccountCreateManyInput = {
    id?: string
    userId: string
    platform: $Enums.PlatformType
    accountName: string
    accountId?: string | null
    followers?: number
    accessToken?: string | null
    tokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialMediaAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | $Enums.PlatformType
    accountName?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    followers?: IntFieldUpdateOperationsInput | number
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialMediaAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | $Enums.PlatformType
    accountName?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    followers?: IntFieldUpdateOperationsInput | number
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformMetricsCreateInput = {
    id?: string
    date: Date | string
    followers?: number
    following?: number
    posts?: number
    impressions?: number
    reach?: number
    profileViews?: number
    websiteClicks?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    account: SocialMediaAccountCreateNestedOneWithoutPlatformMetricsInput
  }

  export type PlatformMetricsUncheckedCreateInput = {
    id?: string
    accountId: string
    date: Date | string
    followers?: number
    following?: number
    posts?: number
    impressions?: number
    reach?: number
    profileViews?: number
    websiteClicks?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformMetricsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    followers?: IntFieldUpdateOperationsInput | number
    following?: IntFieldUpdateOperationsInput | number
    posts?: IntFieldUpdateOperationsInput | number
    impressions?: IntFieldUpdateOperationsInput | number
    reach?: IntFieldUpdateOperationsInput | number
    profileViews?: IntFieldUpdateOperationsInput | number
    websiteClicks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: SocialMediaAccountUpdateOneRequiredWithoutPlatformMetricsNestedInput
  }

  export type PlatformMetricsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    followers?: IntFieldUpdateOperationsInput | number
    following?: IntFieldUpdateOperationsInput | number
    posts?: IntFieldUpdateOperationsInput | number
    impressions?: IntFieldUpdateOperationsInput | number
    reach?: IntFieldUpdateOperationsInput | number
    profileViews?: IntFieldUpdateOperationsInput | number
    websiteClicks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformMetricsCreateManyInput = {
    id?: string
    accountId: string
    date: Date | string
    followers?: number
    following?: number
    posts?: number
    impressions?: number
    reach?: number
    profileViews?: number
    websiteClicks?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformMetricsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    followers?: IntFieldUpdateOperationsInput | number
    following?: IntFieldUpdateOperationsInput | number
    posts?: IntFieldUpdateOperationsInput | number
    impressions?: IntFieldUpdateOperationsInput | number
    reach?: IntFieldUpdateOperationsInput | number
    profileViews?: IntFieldUpdateOperationsInput | number
    websiteClicks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformMetricsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    followers?: IntFieldUpdateOperationsInput | number
    following?: IntFieldUpdateOperationsInput | number
    posts?: IntFieldUpdateOperationsInput | number
    impressions?: IntFieldUpdateOperationsInput | number
    reach?: IntFieldUpdateOperationsInput | number
    profileViews?: IntFieldUpdateOperationsInput | number
    websiteClicks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EngagementMetricsCreateInput = {
    id?: string
    date: Date | string
    likes?: number
    comments?: number
    shares?: number
    saves?: number
    clicks?: number
    engagementRate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: SocialMediaAccountCreateNestedOneWithoutEngagementMetricsInput
  }

  export type EngagementMetricsUncheckedCreateInput = {
    id?: string
    accountId: string
    date: Date | string
    likes?: number
    comments?: number
    shares?: number
    saves?: number
    clicks?: number
    engagementRate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EngagementMetricsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    saves?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: SocialMediaAccountUpdateOneRequiredWithoutEngagementMetricsNestedInput
  }

  export type EngagementMetricsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    saves?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EngagementMetricsCreateManyInput = {
    id?: string
    accountId: string
    date: Date | string
    likes?: number
    comments?: number
    shares?: number
    saves?: number
    clicks?: number
    engagementRate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EngagementMetricsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    saves?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EngagementMetricsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    saves?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InfluencerCreateInput = {
    id?: string
    name: string
    contactInfo?: string | null
    reach?: number
    engagementRate?: number | null
    niche?: string | null
    cost?: number | null
    status?: $Enums.InfluencerStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInfluencersInput
    account: SocialMediaAccountCreateNestedOneWithoutInfluencersInput
    campaigns?: InfluencerCampaignsCreateNestedManyWithoutInfluencerInput
  }

  export type InfluencerUncheckedCreateInput = {
    id?: string
    userId: string
    accountId: string
    name: string
    contactInfo?: string | null
    reach?: number
    engagementRate?: number | null
    niche?: string | null
    cost?: number | null
    status?: $Enums.InfluencerStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: InfluencerCampaignsUncheckedCreateNestedManyWithoutInfluencerInput
  }

  export type InfluencerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    reach?: IntFieldUpdateOperationsInput | number
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    niche?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumInfluencerStatusFieldUpdateOperationsInput | $Enums.InfluencerStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInfluencersNestedInput
    account?: SocialMediaAccountUpdateOneRequiredWithoutInfluencersNestedInput
    campaigns?: InfluencerCampaignsUpdateManyWithoutInfluencerNestedInput
  }

  export type InfluencerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    reach?: IntFieldUpdateOperationsInput | number
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    niche?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumInfluencerStatusFieldUpdateOperationsInput | $Enums.InfluencerStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: InfluencerCampaignsUncheckedUpdateManyWithoutInfluencerNestedInput
  }

  export type InfluencerCreateManyInput = {
    id?: string
    userId: string
    accountId: string
    name: string
    contactInfo?: string | null
    reach?: number
    engagementRate?: number | null
    niche?: string | null
    cost?: number | null
    status?: $Enums.InfluencerStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InfluencerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    reach?: IntFieldUpdateOperationsInput | number
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    niche?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumInfluencerStatusFieldUpdateOperationsInput | $Enums.InfluencerStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InfluencerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    reach?: IntFieldUpdateOperationsInput | number
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    niche?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumInfluencerStatusFieldUpdateOperationsInput | $Enums.InfluencerStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InfluencerCampaignsCreateInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate?: Date | string | null
    budget: number
    results?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.InfluencerCampaignStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    influencer: InfluencerCreateNestedOneWithoutCampaignsInput
  }

  export type InfluencerCampaignsUncheckedCreateInput = {
    id?: string
    influencerId: string
    name: string
    startDate: Date | string
    endDate?: Date | string | null
    budget: number
    results?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.InfluencerCampaignStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InfluencerCampaignsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: FloatFieldUpdateOperationsInput | number
    results?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumInfluencerCampaignStatusFieldUpdateOperationsInput | $Enums.InfluencerCampaignStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    influencer?: InfluencerUpdateOneRequiredWithoutCampaignsNestedInput
  }

  export type InfluencerCampaignsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    influencerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: FloatFieldUpdateOperationsInput | number
    results?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumInfluencerCampaignStatusFieldUpdateOperationsInput | $Enums.InfluencerCampaignStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InfluencerCampaignsCreateManyInput = {
    id?: string
    influencerId: string
    name: string
    startDate: Date | string
    endDate?: Date | string | null
    budget: number
    results?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.InfluencerCampaignStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InfluencerCampaignsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: FloatFieldUpdateOperationsInput | number
    results?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumInfluencerCampaignStatusFieldUpdateOperationsInput | $Enums.InfluencerCampaignStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InfluencerCampaignsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    influencerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: FloatFieldUpdateOperationsInput | number
    results?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumInfluencerCampaignStatusFieldUpdateOperationsInput | $Enums.InfluencerCampaignStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicCreateInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    featured?: boolean
    logoUrl?: string | null
    rating?: number | null
    reviewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClinicsInput
    schedules?: ScheduleCreateNestedManyWithoutClinicInput
    campaigns?: CampaignCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    address?: string | null
    city?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    featured?: boolean
    logoUrl?: string | null
    rating?: number | null
    reviewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleUncheckedCreateNestedManyWithoutClinicInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClinicsNestedInput
    schedules?: ScheduleUpdateManyWithoutClinicNestedInput
    campaigns?: CampaignUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUncheckedUpdateManyWithoutClinicNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type ClinicCreateManyInput = {
    id?: string
    userId: string
    name: string
    address?: string | null
    city?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    featured?: boolean
    logoUrl?: string | null
    rating?: number | null
    reviewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    name: string
    description?: string | null
    price?: number | null
    sku?: string | null
    imageUrl?: string | null
    featured?: boolean
    category?: string | null
    stock?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProductsInput
    schedules?: ScheduleCreateNestedManyWithoutProductInput
    campaigns?: CampaignCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    price?: number | null
    sku?: string | null
    imageUrl?: string | null
    featured?: boolean
    category?: string | null
    stock?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleUncheckedCreateNestedManyWithoutProductInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProductsNestedInput
    schedules?: ScheduleUpdateManyWithoutProductNestedInput
    campaigns?: CampaignUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUncheckedUpdateManyWithoutProductNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    price?: number | null
    sku?: string | null
    imageUrl?: string | null
    featured?: boolean
    category?: string | null
    stock?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncomeCreateInput = {
    id?: string
    source: string
    amount: number
    description?: string | null
    date: Date | string
    category: $Enums.IncomeCategory
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncomeUncheckedCreateInput = {
    id?: string
    source: string
    amount: number
    description?: string | null
    date: Date | string
    category: $Enums.IncomeCategory
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncomeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumIncomeCategoryFieldUpdateOperationsInput | $Enums.IncomeCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncomeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumIncomeCategoryFieldUpdateOperationsInput | $Enums.IncomeCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncomeCreateManyInput = {
    id?: string
    source: string
    amount: number
    description?: string | null
    date: Date | string
    category: $Enums.IncomeCategory
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IncomeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumIncomeCategoryFieldUpdateOperationsInput | $Enums.IncomeCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IncomeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumIncomeCategoryFieldUpdateOperationsInput | $Enums.IncomeCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    amount: number
    currency?: string
    status: $Enums.PaymentStatus
    method: $Enums.PaymentMethod
    description?: string | null
    transactionId?: string | null
    receiptUrl?: string | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentsInput
    invoice?: InvoiceCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    userId: string
    amount: number
    currency?: string
    status: $Enums.PaymentStatus
    method: $Enums.PaymentMethod
    description?: string | null
    transactionId?: string | null
    receiptUrl?: string | null
    invoiceId?: string | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
    invoice?: InvoiceUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    userId: string
    amount: number
    currency?: string
    status: $Enums.PaymentStatus
    method: $Enums.PaymentMethod
    description?: string | null
    transactionId?: string | null
    receiptUrl?: string | null
    invoiceId?: string | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    invoiceNumber: string
    amount: number
    currency?: string
    status: $Enums.InvoiceStatus
    dueDate: Date | string
    issueDate?: Date | string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInvoicesInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    userId: string
    invoiceNumber: string
    amount: number
    currency?: string
    status: $Enums.InvoiceStatus
    dueDate: Date | string
    issueDate?: Date | string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInvoicesNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    userId: string
    invoiceNumber: string
    amount: number
    currency?: string
    status: $Enums.InvoiceStatus
    dueDate: Date | string
    issueDate?: Date | string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ROASMetricsCreateInput = {
    id?: string
    date: Date | string
    adSpend?: number
    revenue?: number
    roasValue?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ROASMetricsUncheckedCreateInput = {
    id?: string
    date: Date | string
    adSpend?: number
    revenue?: number
    roasValue?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ROASMetricsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    adSpend?: FloatFieldUpdateOperationsInput | number
    revenue?: FloatFieldUpdateOperationsInput | number
    roasValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ROASMetricsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    adSpend?: FloatFieldUpdateOperationsInput | number
    revenue?: FloatFieldUpdateOperationsInput | number
    roasValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ROASMetricsCreateManyInput = {
    id?: string
    date: Date | string
    adSpend?: number
    revenue?: number
    roasValue?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ROASMetricsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    adSpend?: FloatFieldUpdateOperationsInput | number
    revenue?: FloatFieldUpdateOperationsInput | number
    roasValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ROASMetricsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    adSpend?: FloatFieldUpdateOperationsInput | number
    revenue?: FloatFieldUpdateOperationsInput | number
    roasValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversionMetricsCreateInput = {
    id?: string
    date: Date | string
    source?: string | null
    medium?: string | null
    campaign?: string | null
    landingPage?: string | null
    pageViews?: number
    uniqueVisitors?: number
    conversions?: number
    conversionValue?: number
    conversionRate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversionMetricsUncheckedCreateInput = {
    id?: string
    date: Date | string
    source?: string | null
    medium?: string | null
    campaign?: string | null
    landingPage?: string | null
    pageViews?: number
    uniqueVisitors?: number
    conversions?: number
    conversionValue?: number
    conversionRate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversionMetricsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    landingPage?: NullableStringFieldUpdateOperationsInput | string | null
    pageViews?: IntFieldUpdateOperationsInput | number
    uniqueVisitors?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    conversionValue?: FloatFieldUpdateOperationsInput | number
    conversionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversionMetricsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    landingPage?: NullableStringFieldUpdateOperationsInput | string | null
    pageViews?: IntFieldUpdateOperationsInput | number
    uniqueVisitors?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    conversionValue?: FloatFieldUpdateOperationsInput | number
    conversionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversionMetricsCreateManyInput = {
    id?: string
    date: Date | string
    source?: string | null
    medium?: string | null
    campaign?: string | null
    landingPage?: string | null
    pageViews?: number
    uniqueVisitors?: number
    conversions?: number
    conversionValue?: number
    conversionRate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversionMetricsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    landingPage?: NullableStringFieldUpdateOperationsInput | string | null
    pageViews?: IntFieldUpdateOperationsInput | number
    uniqueVisitors?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    conversionValue?: FloatFieldUpdateOperationsInput | number
    conversionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversionMetricsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: NullableStringFieldUpdateOperationsInput | string | null
    medium?: NullableStringFieldUpdateOperationsInput | string | null
    campaign?: NullableStringFieldUpdateOperationsInput | string | null
    landingPage?: NullableStringFieldUpdateOperationsInput | string | null
    pageViews?: IntFieldUpdateOperationsInput | number
    uniqueVisitors?: IntFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    conversionValue?: FloatFieldUpdateOperationsInput | number
    conversionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagCreateInput = {
    id?: string
    name: string
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: TagsOnCampaignsCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    name: string
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: TagsOnCampaignsUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: TagsOnCampaignsUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: TagsOnCampaignsUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    name: string
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagsOnCampaignsCreateInput = {
    assignedAt?: Date | string
    tag: TagCreateNestedOneWithoutCampaignsInput
    campaign: CampaignCreateNestedOneWithoutTagsInput
  }

  export type TagsOnCampaignsUncheckedCreateInput = {
    tagId: string
    campaignId: string
    assignedAt?: Date | string
  }

  export type TagsOnCampaignsUpdateInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: TagUpdateOneRequiredWithoutCampaignsNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutTagsNestedInput
  }

  export type TagsOnCampaignsUncheckedUpdateInput = {
    tagId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagsOnCampaignsCreateManyInput = {
    tagId: string
    campaignId: string
    assignedAt?: Date | string
  }

  export type TagsOnCampaignsUpdateManyMutationInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagsOnCampaignsUncheckedUpdateManyInput = {
    tagId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    message: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    title: string
    message: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingCreateInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingUncheckedCreateInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingCreateManyInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type MetaAccountListRelationFilter = {
    every?: MetaAccountWhereInput
    some?: MetaAccountWhereInput
    none?: MetaAccountWhereInput
  }

  export type SocialMediaAccountListRelationFilter = {
    every?: SocialMediaAccountWhereInput
    some?: SocialMediaAccountWhereInput
    none?: SocialMediaAccountWhereInput
  }

  export type CampaignListRelationFilter = {
    every?: CampaignWhereInput
    some?: CampaignWhereInput
    none?: CampaignWhereInput
  }

  export type AdSetListRelationFilter = {
    every?: AdSetWhereInput
    some?: AdSetWhereInput
    none?: AdSetWhereInput
  }

  export type AdListRelationFilter = {
    every?: AdWhereInput
    some?: AdWhereInput
    none?: AdWhereInput
  }

  export type ScheduleListRelationFilter = {
    every?: ScheduleWhereInput
    some?: ScheduleWhereInput
    none?: ScheduleWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type InfluencerListRelationFilter = {
    every?: InfluencerWhereInput
    some?: InfluencerWhereInput
    none?: InfluencerWhereInput
  }

  export type ClinicListRelationFilter = {
    every?: ClinicWhereInput
    some?: ClinicWhereInput
    none?: ClinicWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type MetaAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SocialMediaAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdSetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InfluencerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClinicOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AdAccountListRelationFilter = {
    every?: AdAccountWhereInput
    some?: AdAccountWhereInput
    none?: AdAccountWhereInput
  }

  export type AdAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MetaAccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    metaAccountId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenExpiresAt?: SortOrder
    businessName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MetaAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    metaAccountId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenExpiresAt?: SortOrder
    businessName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MetaAccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    metaAccountId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    tokenExpiresAt?: SortOrder
    businessName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type MetaAccountScalarRelationFilter = {
    is?: MetaAccountWhereInput
    isNot?: MetaAccountWhereInput
  }

  export type AdAccountCountOrderByAggregateInput = {
    id?: SortOrder
    metaAccountId?: SortOrder
    adAccountId?: SortOrder
    name?: SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    metaAccountId?: SortOrder
    adAccountId?: SortOrder
    name?: SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdAccountMinOrderByAggregateInput = {
    id?: SortOrder
    metaAccountId?: SortOrder
    adAccountId?: SortOrder
    name?: SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCampaignStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusFilter<$PrismaModel> | $Enums.CampaignStatus
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumBudgetTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetType | EnumBudgetTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.BudgetType[] | ListEnumBudgetTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BudgetType[] | ListEnumBudgetTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBudgetTypeNullableFilter<$PrismaModel> | $Enums.BudgetType | null
  }

  export type MetaAccountNullableScalarRelationFilter = {
    is?: MetaAccountWhereInput | null
    isNot?: MetaAccountWhereInput | null
  }

  export type AdAccountNullableScalarRelationFilter = {
    is?: AdAccountWhereInput | null
    isNot?: AdAccountWhereInput | null
  }

  export type TagsOnCampaignsListRelationFilter = {
    every?: TagsOnCampaignsWhereInput
    some?: TagsOnCampaignsWhereInput
    none?: TagsOnCampaignsWhereInput
  }

  export type CampaignMetricsListRelationFilter = {
    every?: CampaignMetricsWhereInput
    some?: CampaignMetricsWhereInput
    none?: CampaignMetricsWhereInput
  }

  export type ClinicNullableScalarRelationFilter = {
    is?: ClinicWhereInput | null
    isNot?: ClinicWhereInput | null
  }

  export type ProductNullableScalarRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type TagsOnCampaignsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignMetricsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    metaAccountId?: SortOrder
    adAccountId?: SortOrder
    campaignId?: SortOrder
    name?: SortOrder
    objective?: SortOrder
    status?: SortOrder
    budget?: SortOrder
    budgetType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clinicId?: SortOrder
    productId?: SortOrder
  }

  export type CampaignAvgOrderByAggregateInput = {
    budget?: SortOrder
  }

  export type CampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    metaAccountId?: SortOrder
    adAccountId?: SortOrder
    campaignId?: SortOrder
    name?: SortOrder
    objective?: SortOrder
    status?: SortOrder
    budget?: SortOrder
    budgetType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clinicId?: SortOrder
    productId?: SortOrder
  }

  export type CampaignMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    metaAccountId?: SortOrder
    adAccountId?: SortOrder
    campaignId?: SortOrder
    name?: SortOrder
    objective?: SortOrder
    status?: SortOrder
    budget?: SortOrder
    budgetType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clinicId?: SortOrder
    productId?: SortOrder
  }

  export type CampaignSumOrderByAggregateInput = {
    budget?: SortOrder
  }

  export type EnumCampaignStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel> | $Enums.CampaignStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignStatusFilter<$PrismaModel>
    _max?: NestedEnumCampaignStatusFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumBudgetTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetType | EnumBudgetTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.BudgetType[] | ListEnumBudgetTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BudgetType[] | ListEnumBudgetTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBudgetTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.BudgetType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumBudgetTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumBudgetTypeNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type CampaignScalarRelationFilter = {
    is?: CampaignWhereInput
    isNot?: CampaignWhereInput
  }

  export type CampaignMetricsCampaignIdDateCompoundUniqueInput = {
    campaignId: string
    date: Date | string
  }

  export type CampaignMetricsCountOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    date?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    reach?: SortOrder
    spend?: SortOrder
    conversions?: SortOrder
    costPerResult?: SortOrder
    ctr?: SortOrder
    cpc?: SortOrder
    cpm?: SortOrder
    frequency?: SortOrder
  }

  export type CampaignMetricsAvgOrderByAggregateInput = {
    impressions?: SortOrder
    clicks?: SortOrder
    reach?: SortOrder
    spend?: SortOrder
    conversions?: SortOrder
    costPerResult?: SortOrder
    ctr?: SortOrder
    cpc?: SortOrder
    cpm?: SortOrder
    frequency?: SortOrder
  }

  export type CampaignMetricsMaxOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    date?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    reach?: SortOrder
    spend?: SortOrder
    conversions?: SortOrder
    costPerResult?: SortOrder
    ctr?: SortOrder
    cpc?: SortOrder
    cpm?: SortOrder
    frequency?: SortOrder
  }

  export type CampaignMetricsMinOrderByAggregateInput = {
    id?: SortOrder
    campaignId?: SortOrder
    date?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    reach?: SortOrder
    spend?: SortOrder
    conversions?: SortOrder
    costPerResult?: SortOrder
    ctr?: SortOrder
    cpc?: SortOrder
    cpm?: SortOrder
    frequency?: SortOrder
  }

  export type CampaignMetricsSumOrderByAggregateInput = {
    impressions?: SortOrder
    clicks?: SortOrder
    reach?: SortOrder
    spend?: SortOrder
    conversions?: SortOrder
    costPerResult?: SortOrder
    ctr?: SortOrder
    cpc?: SortOrder
    cpm?: SortOrder
    frequency?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumAdSetStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AdSetStatus | EnumAdSetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdSetStatus[] | ListEnumAdSetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdSetStatus[] | ListEnumAdSetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdSetStatusFilter<$PrismaModel> | $Enums.AdSetStatus
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AdSetMetricsListRelationFilter = {
    every?: AdSetMetricsWhereInput
    some?: AdSetMetricsWhereInput
    none?: AdSetMetricsWhereInput
  }

  export type AdSetMetricsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdSetCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrder
    metaAccountId?: SortOrder
    adSetId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    budget?: SortOrder
    budgetType?: SortOrder
    bidStrategy?: SortOrder
    bidAmount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    targeting?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdSetAvgOrderByAggregateInput = {
    budget?: SortOrder
    bidAmount?: SortOrder
  }

  export type AdSetMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrder
    metaAccountId?: SortOrder
    adSetId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    budget?: SortOrder
    budgetType?: SortOrder
    bidStrategy?: SortOrder
    bidAmount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdSetMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    campaignId?: SortOrder
    metaAccountId?: SortOrder
    adSetId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    budget?: SortOrder
    budgetType?: SortOrder
    bidStrategy?: SortOrder
    bidAmount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdSetSumOrderByAggregateInput = {
    budget?: SortOrder
    bidAmount?: SortOrder
  }

  export type EnumAdSetStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdSetStatus | EnumAdSetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdSetStatus[] | ListEnumAdSetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdSetStatus[] | ListEnumAdSetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdSetStatusWithAggregatesFilter<$PrismaModel> | $Enums.AdSetStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdSetStatusFilter<$PrismaModel>
    _max?: NestedEnumAdSetStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type AdSetScalarRelationFilter = {
    is?: AdSetWhereInput
    isNot?: AdSetWhereInput
  }

  export type AdSetMetricsAdSetIdDateCompoundUniqueInput = {
    adSetId: string
    date: Date | string
  }

  export type AdSetMetricsCountOrderByAggregateInput = {
    id?: SortOrder
    adSetId?: SortOrder
    date?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    reach?: SortOrder
    spend?: SortOrder
    conversions?: SortOrder
    costPerResult?: SortOrder
    ctr?: SortOrder
    cpc?: SortOrder
    cpm?: SortOrder
    frequency?: SortOrder
  }

  export type AdSetMetricsAvgOrderByAggregateInput = {
    impressions?: SortOrder
    clicks?: SortOrder
    reach?: SortOrder
    spend?: SortOrder
    conversions?: SortOrder
    costPerResult?: SortOrder
    ctr?: SortOrder
    cpc?: SortOrder
    cpm?: SortOrder
    frequency?: SortOrder
  }

  export type AdSetMetricsMaxOrderByAggregateInput = {
    id?: SortOrder
    adSetId?: SortOrder
    date?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    reach?: SortOrder
    spend?: SortOrder
    conversions?: SortOrder
    costPerResult?: SortOrder
    ctr?: SortOrder
    cpc?: SortOrder
    cpm?: SortOrder
    frequency?: SortOrder
  }

  export type AdSetMetricsMinOrderByAggregateInput = {
    id?: SortOrder
    adSetId?: SortOrder
    date?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    reach?: SortOrder
    spend?: SortOrder
    conversions?: SortOrder
    costPerResult?: SortOrder
    ctr?: SortOrder
    cpc?: SortOrder
    cpm?: SortOrder
    frequency?: SortOrder
  }

  export type AdSetMetricsSumOrderByAggregateInput = {
    impressions?: SortOrder
    clicks?: SortOrder
    reach?: SortOrder
    spend?: SortOrder
    conversions?: SortOrder
    costPerResult?: SortOrder
    ctr?: SortOrder
    cpc?: SortOrder
    cpm?: SortOrder
    frequency?: SortOrder
  }

  export type EnumAdStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AdStatus | EnumAdStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdStatus[] | ListEnumAdStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdStatus[] | ListEnumAdStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdStatusFilter<$PrismaModel> | $Enums.AdStatus
  }

  export type EnumCreativeTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CreativeType | EnumCreativeTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.CreativeType[] | ListEnumCreativeTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CreativeType[] | ListEnumCreativeTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCreativeTypeNullableFilter<$PrismaModel> | $Enums.CreativeType | null
  }

  export type AdMetricsListRelationFilter = {
    every?: AdMetricsWhereInput
    some?: AdMetricsWhereInput
    none?: AdMetricsWhereInput
  }

  export type AdMetricsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adSetId?: SortOrder
    metaAccountId?: SortOrder
    adId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    headline?: SortOrder
    description?: SortOrder
    creativeType?: SortOrder
    imageUrl?: SortOrder
    videoUrl?: SortOrder
    destinationUrl?: SortOrder
    callToAction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adSetId?: SortOrder
    metaAccountId?: SortOrder
    adId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    headline?: SortOrder
    description?: SortOrder
    creativeType?: SortOrder
    imageUrl?: SortOrder
    videoUrl?: SortOrder
    destinationUrl?: SortOrder
    callToAction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adSetId?: SortOrder
    metaAccountId?: SortOrder
    adId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    headline?: SortOrder
    description?: SortOrder
    creativeType?: SortOrder
    imageUrl?: SortOrder
    videoUrl?: SortOrder
    destinationUrl?: SortOrder
    callToAction?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAdStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdStatus | EnumAdStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdStatus[] | ListEnumAdStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdStatus[] | ListEnumAdStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdStatusWithAggregatesFilter<$PrismaModel> | $Enums.AdStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdStatusFilter<$PrismaModel>
    _max?: NestedEnumAdStatusFilter<$PrismaModel>
  }

  export type EnumCreativeTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CreativeType | EnumCreativeTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.CreativeType[] | ListEnumCreativeTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CreativeType[] | ListEnumCreativeTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCreativeTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.CreativeType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCreativeTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumCreativeTypeNullableFilter<$PrismaModel>
  }

  export type AdScalarRelationFilter = {
    is?: AdWhereInput
    isNot?: AdWhereInput
  }

  export type AdMetricsAdIdDateCompoundUniqueInput = {
    adId: string
    date: Date | string
  }

  export type AdMetricsCountOrderByAggregateInput = {
    id?: SortOrder
    adId?: SortOrder
    date?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    reach?: SortOrder
    spend?: SortOrder
    conversions?: SortOrder
    costPerResult?: SortOrder
    ctr?: SortOrder
    cpc?: SortOrder
    cpm?: SortOrder
    frequency?: SortOrder
    engagements?: SortOrder
    shares?: SortOrder
    comments?: SortOrder
    saves?: SortOrder
  }

  export type AdMetricsAvgOrderByAggregateInput = {
    impressions?: SortOrder
    clicks?: SortOrder
    reach?: SortOrder
    spend?: SortOrder
    conversions?: SortOrder
    costPerResult?: SortOrder
    ctr?: SortOrder
    cpc?: SortOrder
    cpm?: SortOrder
    frequency?: SortOrder
    engagements?: SortOrder
    shares?: SortOrder
    comments?: SortOrder
    saves?: SortOrder
  }

  export type AdMetricsMaxOrderByAggregateInput = {
    id?: SortOrder
    adId?: SortOrder
    date?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    reach?: SortOrder
    spend?: SortOrder
    conversions?: SortOrder
    costPerResult?: SortOrder
    ctr?: SortOrder
    cpc?: SortOrder
    cpm?: SortOrder
    frequency?: SortOrder
    engagements?: SortOrder
    shares?: SortOrder
    comments?: SortOrder
    saves?: SortOrder
  }

  export type AdMetricsMinOrderByAggregateInput = {
    id?: SortOrder
    adId?: SortOrder
    date?: SortOrder
    impressions?: SortOrder
    clicks?: SortOrder
    reach?: SortOrder
    spend?: SortOrder
    conversions?: SortOrder
    costPerResult?: SortOrder
    ctr?: SortOrder
    cpc?: SortOrder
    cpm?: SortOrder
    frequency?: SortOrder
    engagements?: SortOrder
    shares?: SortOrder
    comments?: SortOrder
    saves?: SortOrder
  }

  export type AdMetricsSumOrderByAggregateInput = {
    impressions?: SortOrder
    clicks?: SortOrder
    reach?: SortOrder
    spend?: SortOrder
    conversions?: SortOrder
    costPerResult?: SortOrder
    ctr?: SortOrder
    cpc?: SortOrder
    cpm?: SortOrder
    frequency?: SortOrder
    engagements?: SortOrder
    shares?: SortOrder
    comments?: SortOrder
    saves?: SortOrder
  }

  export type EnumScheduleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleStatus | EnumScheduleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduleStatus[] | ListEnumScheduleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduleStatus[] | ListEnumScheduleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduleStatusFilter<$PrismaModel> | $Enums.ScheduleStatus
  }

  export type EnumSchedulePriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.SchedulePriority | EnumSchedulePriorityFieldRefInput<$PrismaModel>
    in?: $Enums.SchedulePriority[] | ListEnumSchedulePriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SchedulePriority[] | ListEnumSchedulePriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumSchedulePriorityFilter<$PrismaModel> | $Enums.SchedulePriority
  }

  export type EnumScheduleCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleCategory | EnumScheduleCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.ScheduleCategory[] | ListEnumScheduleCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ScheduleCategory[] | ListEnumScheduleCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumScheduleCategoryNullableFilter<$PrismaModel> | $Enums.ScheduleCategory | null
  }

  export type EnumRecurrencePatternNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurrencePattern | EnumRecurrencePatternFieldRefInput<$PrismaModel> | null
    in?: $Enums.RecurrencePattern[] | ListEnumRecurrencePatternFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RecurrencePattern[] | ListEnumRecurrencePatternFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRecurrencePatternNullableFilter<$PrismaModel> | $Enums.RecurrencePattern | null
  }

  export type AdNullableScalarRelationFilter = {
    is?: AdWhereInput | null
    isNot?: AdWhereInput | null
  }

  export type ScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adId?: SortOrder
    title?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    category?: SortOrder
    clinicId?: SortOrder
    productId?: SortOrder
    recurrence?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adId?: SortOrder
    title?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    category?: SortOrder
    clinicId?: SortOrder
    productId?: SortOrder
    recurrence?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    adId?: SortOrder
    title?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    category?: SortOrder
    clinicId?: SortOrder
    productId?: SortOrder
    recurrence?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumScheduleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleStatus | EnumScheduleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduleStatus[] | ListEnumScheduleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduleStatus[] | ListEnumScheduleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduleStatusWithAggregatesFilter<$PrismaModel> | $Enums.ScheduleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScheduleStatusFilter<$PrismaModel>
    _max?: NestedEnumScheduleStatusFilter<$PrismaModel>
  }

  export type EnumSchedulePriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SchedulePriority | EnumSchedulePriorityFieldRefInput<$PrismaModel>
    in?: $Enums.SchedulePriority[] | ListEnumSchedulePriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SchedulePriority[] | ListEnumSchedulePriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumSchedulePriorityWithAggregatesFilter<$PrismaModel> | $Enums.SchedulePriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSchedulePriorityFilter<$PrismaModel>
    _max?: NestedEnumSchedulePriorityFilter<$PrismaModel>
  }

  export type EnumScheduleCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleCategory | EnumScheduleCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.ScheduleCategory[] | ListEnumScheduleCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ScheduleCategory[] | ListEnumScheduleCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumScheduleCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.ScheduleCategory | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumScheduleCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumScheduleCategoryNullableFilter<$PrismaModel>
  }

  export type EnumRecurrencePatternNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurrencePattern | EnumRecurrencePatternFieldRefInput<$PrismaModel> | null
    in?: $Enums.RecurrencePattern[] | ListEnumRecurrencePatternFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RecurrencePattern[] | ListEnumRecurrencePatternFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRecurrencePatternNullableWithAggregatesFilter<$PrismaModel> | $Enums.RecurrencePattern | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRecurrencePatternNullableFilter<$PrismaModel>
    _max?: NestedEnumRecurrencePatternNullableFilter<$PrismaModel>
  }

  export type EnumCampaignObjectiveFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignObjective | EnumCampaignObjectiveFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignObjective[] | ListEnumCampaignObjectiveFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignObjective[] | ListEnumCampaignObjectiveFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignObjectiveFilter<$PrismaModel> | $Enums.CampaignObjective
  }

  export type EnumBudgetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetType | EnumBudgetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BudgetType[] | ListEnumBudgetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BudgetType[] | ListEnumBudgetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBudgetTypeFilter<$PrismaModel> | $Enums.BudgetType
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumGenderTargetNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.GenderTarget | EnumGenderTargetFieldRefInput<$PrismaModel> | null
    in?: $Enums.GenderTarget[] | ListEnumGenderTargetFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.GenderTarget[] | ListEnumGenderTargetFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderTargetNullableFilter<$PrismaModel> | $Enums.GenderTarget | null
  }

  export type PlannerItemListRelationFilter = {
    every?: PlannerItemWhereInput
    some?: PlannerItemWhereInput
    none?: PlannerItemWhereInput
  }

  export type PlannerItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdsPlannerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    objective?: SortOrder
    budgetType?: SortOrder
    budgetAmount?: SortOrder
    whatsappNumber?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrder
    minAge?: SortOrder
    maxAge?: SortOrder
    gender?: SortOrder
    detailTargeting?: SortOrder
    videoUrl?: SortOrder
    websiteUrl?: SortOrder
    primaryText?: SortOrder
    headline?: SortOrder
    ctaName?: SortOrder
    ctaText?: SortOrder
    preFilledMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdsPlannerAvgOrderByAggregateInput = {
    budgetAmount?: SortOrder
    minAge?: SortOrder
    maxAge?: SortOrder
  }

  export type AdsPlannerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    objective?: SortOrder
    budgetType?: SortOrder
    budgetAmount?: SortOrder
    whatsappNumber?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrder
    minAge?: SortOrder
    maxAge?: SortOrder
    gender?: SortOrder
    detailTargeting?: SortOrder
    videoUrl?: SortOrder
    websiteUrl?: SortOrder
    primaryText?: SortOrder
    headline?: SortOrder
    ctaName?: SortOrder
    ctaText?: SortOrder
    preFilledMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdsPlannerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    objective?: SortOrder
    budgetType?: SortOrder
    budgetAmount?: SortOrder
    whatsappNumber?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    location?: SortOrder
    minAge?: SortOrder
    maxAge?: SortOrder
    gender?: SortOrder
    detailTargeting?: SortOrder
    videoUrl?: SortOrder
    websiteUrl?: SortOrder
    primaryText?: SortOrder
    headline?: SortOrder
    ctaName?: SortOrder
    ctaText?: SortOrder
    preFilledMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdsPlannerSumOrderByAggregateInput = {
    budgetAmount?: SortOrder
    minAge?: SortOrder
    maxAge?: SortOrder
  }

  export type EnumCampaignObjectiveWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignObjective | EnumCampaignObjectiveFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignObjective[] | ListEnumCampaignObjectiveFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignObjective[] | ListEnumCampaignObjectiveFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignObjectiveWithAggregatesFilter<$PrismaModel> | $Enums.CampaignObjective
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignObjectiveFilter<$PrismaModel>
    _max?: NestedEnumCampaignObjectiveFilter<$PrismaModel>
  }

  export type EnumBudgetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetType | EnumBudgetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BudgetType[] | ListEnumBudgetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BudgetType[] | ListEnumBudgetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBudgetTypeWithAggregatesFilter<$PrismaModel> | $Enums.BudgetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBudgetTypeFilter<$PrismaModel>
    _max?: NestedEnumBudgetTypeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumGenderTargetNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GenderTarget | EnumGenderTargetFieldRefInput<$PrismaModel> | null
    in?: $Enums.GenderTarget[] | ListEnumGenderTargetFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.GenderTarget[] | ListEnumGenderTargetFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderTargetNullableWithAggregatesFilter<$PrismaModel> | $Enums.GenderTarget | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderTargetNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderTargetNullableFilter<$PrismaModel>
  }

  export type EnumPlatformTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PlatformType | EnumPlatformTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlatformType[] | ListEnumPlatformTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlatformType[] | ListEnumPlatformTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlatformTypeFilter<$PrismaModel> | $Enums.PlatformType
  }

  export type EnumPlannerItemStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PlannerItemStatus | EnumPlannerItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PlannerItemStatus[] | ListEnumPlannerItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlannerItemStatus[] | ListEnumPlannerItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPlannerItemStatusFilter<$PrismaModel> | $Enums.PlannerItemStatus
  }

  export type AdsPlannerScalarRelationFilter = {
    is?: AdsPlannerWhereInput
    isNot?: AdsPlannerWhereInput
  }

  export type PlannerItemCountOrderByAggregateInput = {
    id?: SortOrder
    plannerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    platform?: SortOrder
    format?: SortOrder
    budget?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlannerItemAvgOrderByAggregateInput = {
    budget?: SortOrder
  }

  export type PlannerItemMaxOrderByAggregateInput = {
    id?: SortOrder
    plannerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    platform?: SortOrder
    format?: SortOrder
    budget?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlannerItemMinOrderByAggregateInput = {
    id?: SortOrder
    plannerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    platform?: SortOrder
    format?: SortOrder
    budget?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlannerItemSumOrderByAggregateInput = {
    budget?: SortOrder
  }

  export type EnumPlatformTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlatformType | EnumPlatformTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlatformType[] | ListEnumPlatformTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlatformType[] | ListEnumPlatformTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlatformTypeWithAggregatesFilter<$PrismaModel> | $Enums.PlatformType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlatformTypeFilter<$PrismaModel>
    _max?: NestedEnumPlatformTypeFilter<$PrismaModel>
  }

  export type EnumPlannerItemStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlannerItemStatus | EnumPlannerItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PlannerItemStatus[] | ListEnumPlannerItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlannerItemStatus[] | ListEnumPlannerItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPlannerItemStatusWithAggregatesFilter<$PrismaModel> | $Enums.PlannerItemStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlannerItemStatusFilter<$PrismaModel>
    _max?: NestedEnumPlannerItemStatusFilter<$PrismaModel>
  }

  export type PlatformMetricsListRelationFilter = {
    every?: PlatformMetricsWhereInput
    some?: PlatformMetricsWhereInput
    none?: PlatformMetricsWhereInput
  }

  export type EngagementMetricsListRelationFilter = {
    every?: EngagementMetricsWhereInput
    some?: EngagementMetricsWhereInput
    none?: EngagementMetricsWhereInput
  }

  export type PlatformMetricsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EngagementMetricsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SocialMediaAccountUserIdPlatformAccountNameCompoundUniqueInput = {
    userId: string
    platform: $Enums.PlatformType
    accountName: string
  }

  export type SocialMediaAccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    platform?: SortOrder
    accountName?: SortOrder
    accountId?: SortOrder
    followers?: SortOrder
    accessToken?: SortOrder
    tokenExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialMediaAccountAvgOrderByAggregateInput = {
    followers?: SortOrder
  }

  export type SocialMediaAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    platform?: SortOrder
    accountName?: SortOrder
    accountId?: SortOrder
    followers?: SortOrder
    accessToken?: SortOrder
    tokenExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialMediaAccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    platform?: SortOrder
    accountName?: SortOrder
    accountId?: SortOrder
    followers?: SortOrder
    accessToken?: SortOrder
    tokenExpiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SocialMediaAccountSumOrderByAggregateInput = {
    followers?: SortOrder
  }

  export type SocialMediaAccountScalarRelationFilter = {
    is?: SocialMediaAccountWhereInput
    isNot?: SocialMediaAccountWhereInput
  }

  export type PlatformMetricsAccountIdDateCompoundUniqueInput = {
    accountId: string
    date: Date | string
  }

  export type PlatformMetricsCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    date?: SortOrder
    followers?: SortOrder
    following?: SortOrder
    posts?: SortOrder
    impressions?: SortOrder
    reach?: SortOrder
    profileViews?: SortOrder
    websiteClicks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformMetricsAvgOrderByAggregateInput = {
    followers?: SortOrder
    following?: SortOrder
    posts?: SortOrder
    impressions?: SortOrder
    reach?: SortOrder
    profileViews?: SortOrder
    websiteClicks?: SortOrder
  }

  export type PlatformMetricsMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    date?: SortOrder
    followers?: SortOrder
    following?: SortOrder
    posts?: SortOrder
    impressions?: SortOrder
    reach?: SortOrder
    profileViews?: SortOrder
    websiteClicks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformMetricsMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    date?: SortOrder
    followers?: SortOrder
    following?: SortOrder
    posts?: SortOrder
    impressions?: SortOrder
    reach?: SortOrder
    profileViews?: SortOrder
    websiteClicks?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformMetricsSumOrderByAggregateInput = {
    followers?: SortOrder
    following?: SortOrder
    posts?: SortOrder
    impressions?: SortOrder
    reach?: SortOrder
    profileViews?: SortOrder
    websiteClicks?: SortOrder
  }

  export type EngagementMetricsAccountIdDateCompoundUniqueInput = {
    accountId: string
    date: Date | string
  }

  export type EngagementMetricsCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    date?: SortOrder
    likes?: SortOrder
    comments?: SortOrder
    shares?: SortOrder
    saves?: SortOrder
    clicks?: SortOrder
    engagementRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EngagementMetricsAvgOrderByAggregateInput = {
    likes?: SortOrder
    comments?: SortOrder
    shares?: SortOrder
    saves?: SortOrder
    clicks?: SortOrder
    engagementRate?: SortOrder
  }

  export type EngagementMetricsMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    date?: SortOrder
    likes?: SortOrder
    comments?: SortOrder
    shares?: SortOrder
    saves?: SortOrder
    clicks?: SortOrder
    engagementRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EngagementMetricsMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    date?: SortOrder
    likes?: SortOrder
    comments?: SortOrder
    shares?: SortOrder
    saves?: SortOrder
    clicks?: SortOrder
    engagementRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EngagementMetricsSumOrderByAggregateInput = {
    likes?: SortOrder
    comments?: SortOrder
    shares?: SortOrder
    saves?: SortOrder
    clicks?: SortOrder
    engagementRate?: SortOrder
  }

  export type EnumInfluencerStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InfluencerStatus | EnumInfluencerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InfluencerStatus[] | ListEnumInfluencerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InfluencerStatus[] | ListEnumInfluencerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInfluencerStatusFilter<$PrismaModel> | $Enums.InfluencerStatus
  }

  export type InfluencerCampaignsListRelationFilter = {
    every?: InfluencerCampaignsWhereInput
    some?: InfluencerCampaignsWhereInput
    none?: InfluencerCampaignsWhereInput
  }

  export type InfluencerCampaignsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InfluencerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    name?: SortOrder
    contactInfo?: SortOrder
    reach?: SortOrder
    engagementRate?: SortOrder
    niche?: SortOrder
    cost?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InfluencerAvgOrderByAggregateInput = {
    reach?: SortOrder
    engagementRate?: SortOrder
    cost?: SortOrder
  }

  export type InfluencerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    name?: SortOrder
    contactInfo?: SortOrder
    reach?: SortOrder
    engagementRate?: SortOrder
    niche?: SortOrder
    cost?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InfluencerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    name?: SortOrder
    contactInfo?: SortOrder
    reach?: SortOrder
    engagementRate?: SortOrder
    niche?: SortOrder
    cost?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InfluencerSumOrderByAggregateInput = {
    reach?: SortOrder
    engagementRate?: SortOrder
    cost?: SortOrder
  }

  export type EnumInfluencerStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InfluencerStatus | EnumInfluencerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InfluencerStatus[] | ListEnumInfluencerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InfluencerStatus[] | ListEnumInfluencerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInfluencerStatusWithAggregatesFilter<$PrismaModel> | $Enums.InfluencerStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInfluencerStatusFilter<$PrismaModel>
    _max?: NestedEnumInfluencerStatusFilter<$PrismaModel>
  }

  export type EnumInfluencerCampaignStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InfluencerCampaignStatus | EnumInfluencerCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InfluencerCampaignStatus[] | ListEnumInfluencerCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InfluencerCampaignStatus[] | ListEnumInfluencerCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInfluencerCampaignStatusFilter<$PrismaModel> | $Enums.InfluencerCampaignStatus
  }

  export type InfluencerScalarRelationFilter = {
    is?: InfluencerWhereInput
    isNot?: InfluencerWhereInput
  }

  export type InfluencerCampaignsCountOrderByAggregateInput = {
    id?: SortOrder
    influencerId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    budget?: SortOrder
    results?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InfluencerCampaignsAvgOrderByAggregateInput = {
    budget?: SortOrder
  }

  export type InfluencerCampaignsMaxOrderByAggregateInput = {
    id?: SortOrder
    influencerId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    budget?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InfluencerCampaignsMinOrderByAggregateInput = {
    id?: SortOrder
    influencerId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    budget?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InfluencerCampaignsSumOrderByAggregateInput = {
    budget?: SortOrder
  }

  export type EnumInfluencerCampaignStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InfluencerCampaignStatus | EnumInfluencerCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InfluencerCampaignStatus[] | ListEnumInfluencerCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InfluencerCampaignStatus[] | ListEnumInfluencerCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInfluencerCampaignStatusWithAggregatesFilter<$PrismaModel> | $Enums.InfluencerCampaignStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInfluencerCampaignStatusFilter<$PrismaModel>
    _max?: NestedEnumInfluencerCampaignStatusFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ClinicCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    description?: SortOrder
    featured?: SortOrder
    logoUrl?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicAvgOrderByAggregateInput = {
    rating?: SortOrder
    reviewCount?: SortOrder
  }

  export type ClinicMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    description?: SortOrder
    featured?: SortOrder
    logoUrl?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    description?: SortOrder
    featured?: SortOrder
    logoUrl?: SortOrder
    rating?: SortOrder
    reviewCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicSumOrderByAggregateInput = {
    rating?: SortOrder
    reviewCount?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    sku?: SortOrder
    imageUrl?: SortOrder
    featured?: SortOrder
    category?: SortOrder
    stock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    price?: SortOrder
    stock?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    sku?: SortOrder
    imageUrl?: SortOrder
    featured?: SortOrder
    category?: SortOrder
    stock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    sku?: SortOrder
    imageUrl?: SortOrder
    featured?: SortOrder
    category?: SortOrder
    stock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    price?: SortOrder
    stock?: SortOrder
  }

  export type EnumIncomeCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.IncomeCategory | EnumIncomeCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.IncomeCategory[] | ListEnumIncomeCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncomeCategory[] | ListEnumIncomeCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumIncomeCategoryFilter<$PrismaModel> | $Enums.IncomeCategory
  }

  export type IncomeCountOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    date?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IncomeAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type IncomeMaxOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    date?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IncomeMinOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    date?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IncomeSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumIncomeCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncomeCategory | EnumIncomeCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.IncomeCategory[] | ListEnumIncomeCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncomeCategory[] | ListEnumIncomeCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumIncomeCategoryWithAggregatesFilter<$PrismaModel> | $Enums.IncomeCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncomeCategoryFilter<$PrismaModel>
    _max?: NestedEnumIncomeCategoryFilter<$PrismaModel>
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type InvoiceNullableScalarRelationFilter = {
    is?: InvoiceWhereInput | null
    isNot?: InvoiceWhereInput | null
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    method?: SortOrder
    description?: SortOrder
    transactionId?: SortOrder
    receiptUrl?: SortOrder
    invoiceId?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    method?: SortOrder
    description?: SortOrder
    transactionId?: SortOrder
    receiptUrl?: SortOrder
    invoiceId?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    method?: SortOrder
    description?: SortOrder
    transactionId?: SortOrder
    receiptUrl?: SortOrder
    invoiceId?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    invoiceNumber?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    issueDate?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    invoiceNumber?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    issueDate?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    invoiceNumber?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    issueDate?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type ROASMetricsCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    adSpend?: SortOrder
    revenue?: SortOrder
    roasValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ROASMetricsAvgOrderByAggregateInput = {
    adSpend?: SortOrder
    revenue?: SortOrder
    roasValue?: SortOrder
  }

  export type ROASMetricsMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    adSpend?: SortOrder
    revenue?: SortOrder
    roasValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ROASMetricsMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    adSpend?: SortOrder
    revenue?: SortOrder
    roasValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ROASMetricsSumOrderByAggregateInput = {
    adSpend?: SortOrder
    revenue?: SortOrder
    roasValue?: SortOrder
  }

  export type ConversionMetricsCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    source?: SortOrder
    medium?: SortOrder
    campaign?: SortOrder
    landingPage?: SortOrder
    pageViews?: SortOrder
    uniqueVisitors?: SortOrder
    conversions?: SortOrder
    conversionValue?: SortOrder
    conversionRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversionMetricsAvgOrderByAggregateInput = {
    pageViews?: SortOrder
    uniqueVisitors?: SortOrder
    conversions?: SortOrder
    conversionValue?: SortOrder
    conversionRate?: SortOrder
  }

  export type ConversionMetricsMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    source?: SortOrder
    medium?: SortOrder
    campaign?: SortOrder
    landingPage?: SortOrder
    pageViews?: SortOrder
    uniqueVisitors?: SortOrder
    conversions?: SortOrder
    conversionValue?: SortOrder
    conversionRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversionMetricsMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    source?: SortOrder
    medium?: SortOrder
    campaign?: SortOrder
    landingPage?: SortOrder
    pageViews?: SortOrder
    uniqueVisitors?: SortOrder
    conversions?: SortOrder
    conversionValue?: SortOrder
    conversionRate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversionMetricsSumOrderByAggregateInput = {
    pageViews?: SortOrder
    uniqueVisitors?: SortOrder
    conversions?: SortOrder
    conversionValue?: SortOrder
    conversionRate?: SortOrder
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagScalarRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type TagsOnCampaignsTagIdCampaignIdCompoundUniqueInput = {
    tagId: string
    campaignId: string
  }

  export type TagsOnCampaignsCountOrderByAggregateInput = {
    tagId?: SortOrder
    campaignId?: SortOrder
    assignedAt?: SortOrder
  }

  export type TagsOnCampaignsMaxOrderByAggregateInput = {
    tagId?: SortOrder
    campaignId?: SortOrder
    assignedAt?: SortOrder
  }

  export type TagsOnCampaignsMinOrderByAggregateInput = {
    tagId?: SortOrder
    campaignId?: SortOrder
    assignedAt?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type SettingCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MetaAccountCreateNestedManyWithoutUserInput = {
    create?: XOR<MetaAccountCreateWithoutUserInput, MetaAccountUncheckedCreateWithoutUserInput> | MetaAccountCreateWithoutUserInput[] | MetaAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MetaAccountCreateOrConnectWithoutUserInput | MetaAccountCreateOrConnectWithoutUserInput[]
    createMany?: MetaAccountCreateManyUserInputEnvelope
    connect?: MetaAccountWhereUniqueInput | MetaAccountWhereUniqueInput[]
  }

  export type SocialMediaAccountCreateNestedManyWithoutUserInput = {
    create?: XOR<SocialMediaAccountCreateWithoutUserInput, SocialMediaAccountUncheckedCreateWithoutUserInput> | SocialMediaAccountCreateWithoutUserInput[] | SocialMediaAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SocialMediaAccountCreateOrConnectWithoutUserInput | SocialMediaAccountCreateOrConnectWithoutUserInput[]
    createMany?: SocialMediaAccountCreateManyUserInputEnvelope
    connect?: SocialMediaAccountWhereUniqueInput | SocialMediaAccountWhereUniqueInput[]
  }

  export type CampaignCreateNestedManyWithoutUserInput = {
    create?: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput> | CampaignCreateWithoutUserInput[] | CampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutUserInput | CampaignCreateOrConnectWithoutUserInput[]
    createMany?: CampaignCreateManyUserInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type AdSetCreateNestedManyWithoutUserInput = {
    create?: XOR<AdSetCreateWithoutUserInput, AdSetUncheckedCreateWithoutUserInput> | AdSetCreateWithoutUserInput[] | AdSetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdSetCreateOrConnectWithoutUserInput | AdSetCreateOrConnectWithoutUserInput[]
    createMany?: AdSetCreateManyUserInputEnvelope
    connect?: AdSetWhereUniqueInput | AdSetWhereUniqueInput[]
  }

  export type AdCreateNestedManyWithoutUserInput = {
    create?: XOR<AdCreateWithoutUserInput, AdUncheckedCreateWithoutUserInput> | AdCreateWithoutUserInput[] | AdUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdCreateOrConnectWithoutUserInput | AdCreateOrConnectWithoutUserInput[]
    createMany?: AdCreateManyUserInputEnvelope
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
  }

  export type ScheduleCreateNestedManyWithoutUserInput = {
    create?: XOR<ScheduleCreateWithoutUserInput, ScheduleUncheckedCreateWithoutUserInput> | ScheduleCreateWithoutUserInput[] | ScheduleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutUserInput | ScheduleCreateOrConnectWithoutUserInput[]
    createMany?: ScheduleCreateManyUserInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutUserInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type InfluencerCreateNestedManyWithoutUserInput = {
    create?: XOR<InfluencerCreateWithoutUserInput, InfluencerUncheckedCreateWithoutUserInput> | InfluencerCreateWithoutUserInput[] | InfluencerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InfluencerCreateOrConnectWithoutUserInput | InfluencerCreateOrConnectWithoutUserInput[]
    createMany?: InfluencerCreateManyUserInputEnvelope
    connect?: InfluencerWhereUniqueInput | InfluencerWhereUniqueInput[]
  }

  export type ClinicCreateNestedManyWithoutUserInput = {
    create?: XOR<ClinicCreateWithoutUserInput, ClinicUncheckedCreateWithoutUserInput> | ClinicCreateWithoutUserInput[] | ClinicUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClinicCreateOrConnectWithoutUserInput | ClinicCreateOrConnectWithoutUserInput[]
    createMany?: ClinicCreateManyUserInputEnvelope
    connect?: ClinicWhereUniqueInput | ClinicWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutUserInput = {
    create?: XOR<ProductCreateWithoutUserInput, ProductUncheckedCreateWithoutUserInput> | ProductCreateWithoutUserInput[] | ProductUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUserInput | ProductCreateOrConnectWithoutUserInput[]
    createMany?: ProductCreateManyUserInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type MetaAccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MetaAccountCreateWithoutUserInput, MetaAccountUncheckedCreateWithoutUserInput> | MetaAccountCreateWithoutUserInput[] | MetaAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MetaAccountCreateOrConnectWithoutUserInput | MetaAccountCreateOrConnectWithoutUserInput[]
    createMany?: MetaAccountCreateManyUserInputEnvelope
    connect?: MetaAccountWhereUniqueInput | MetaAccountWhereUniqueInput[]
  }

  export type SocialMediaAccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SocialMediaAccountCreateWithoutUserInput, SocialMediaAccountUncheckedCreateWithoutUserInput> | SocialMediaAccountCreateWithoutUserInput[] | SocialMediaAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SocialMediaAccountCreateOrConnectWithoutUserInput | SocialMediaAccountCreateOrConnectWithoutUserInput[]
    createMany?: SocialMediaAccountCreateManyUserInputEnvelope
    connect?: SocialMediaAccountWhereUniqueInput | SocialMediaAccountWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput> | CampaignCreateWithoutUserInput[] | CampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutUserInput | CampaignCreateOrConnectWithoutUserInput[]
    createMany?: CampaignCreateManyUserInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type AdSetUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AdSetCreateWithoutUserInput, AdSetUncheckedCreateWithoutUserInput> | AdSetCreateWithoutUserInput[] | AdSetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdSetCreateOrConnectWithoutUserInput | AdSetCreateOrConnectWithoutUserInput[]
    createMany?: AdSetCreateManyUserInputEnvelope
    connect?: AdSetWhereUniqueInput | AdSetWhereUniqueInput[]
  }

  export type AdUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AdCreateWithoutUserInput, AdUncheckedCreateWithoutUserInput> | AdCreateWithoutUserInput[] | AdUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdCreateOrConnectWithoutUserInput | AdCreateOrConnectWithoutUserInput[]
    createMany?: AdCreateManyUserInputEnvelope
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
  }

  export type ScheduleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ScheduleCreateWithoutUserInput, ScheduleUncheckedCreateWithoutUserInput> | ScheduleCreateWithoutUserInput[] | ScheduleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutUserInput | ScheduleCreateOrConnectWithoutUserInput[]
    createMany?: ScheduleCreateManyUserInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type InfluencerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InfluencerCreateWithoutUserInput, InfluencerUncheckedCreateWithoutUserInput> | InfluencerCreateWithoutUserInput[] | InfluencerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InfluencerCreateOrConnectWithoutUserInput | InfluencerCreateOrConnectWithoutUserInput[]
    createMany?: InfluencerCreateManyUserInputEnvelope
    connect?: InfluencerWhereUniqueInput | InfluencerWhereUniqueInput[]
  }

  export type ClinicUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ClinicCreateWithoutUserInput, ClinicUncheckedCreateWithoutUserInput> | ClinicCreateWithoutUserInput[] | ClinicUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClinicCreateOrConnectWithoutUserInput | ClinicCreateOrConnectWithoutUserInput[]
    createMany?: ClinicCreateManyUserInputEnvelope
    connect?: ClinicWhereUniqueInput | ClinicWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProductCreateWithoutUserInput, ProductUncheckedCreateWithoutUserInput> | ProductCreateWithoutUserInput[] | ProductUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUserInput | ProductCreateOrConnectWithoutUserInput[]
    createMany?: ProductCreateManyUserInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type MetaAccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<MetaAccountCreateWithoutUserInput, MetaAccountUncheckedCreateWithoutUserInput> | MetaAccountCreateWithoutUserInput[] | MetaAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MetaAccountCreateOrConnectWithoutUserInput | MetaAccountCreateOrConnectWithoutUserInput[]
    upsert?: MetaAccountUpsertWithWhereUniqueWithoutUserInput | MetaAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MetaAccountCreateManyUserInputEnvelope
    set?: MetaAccountWhereUniqueInput | MetaAccountWhereUniqueInput[]
    disconnect?: MetaAccountWhereUniqueInput | MetaAccountWhereUniqueInput[]
    delete?: MetaAccountWhereUniqueInput | MetaAccountWhereUniqueInput[]
    connect?: MetaAccountWhereUniqueInput | MetaAccountWhereUniqueInput[]
    update?: MetaAccountUpdateWithWhereUniqueWithoutUserInput | MetaAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MetaAccountUpdateManyWithWhereWithoutUserInput | MetaAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MetaAccountScalarWhereInput | MetaAccountScalarWhereInput[]
  }

  export type SocialMediaAccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<SocialMediaAccountCreateWithoutUserInput, SocialMediaAccountUncheckedCreateWithoutUserInput> | SocialMediaAccountCreateWithoutUserInput[] | SocialMediaAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SocialMediaAccountCreateOrConnectWithoutUserInput | SocialMediaAccountCreateOrConnectWithoutUserInput[]
    upsert?: SocialMediaAccountUpsertWithWhereUniqueWithoutUserInput | SocialMediaAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SocialMediaAccountCreateManyUserInputEnvelope
    set?: SocialMediaAccountWhereUniqueInput | SocialMediaAccountWhereUniqueInput[]
    disconnect?: SocialMediaAccountWhereUniqueInput | SocialMediaAccountWhereUniqueInput[]
    delete?: SocialMediaAccountWhereUniqueInput | SocialMediaAccountWhereUniqueInput[]
    connect?: SocialMediaAccountWhereUniqueInput | SocialMediaAccountWhereUniqueInput[]
    update?: SocialMediaAccountUpdateWithWhereUniqueWithoutUserInput | SocialMediaAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SocialMediaAccountUpdateManyWithWhereWithoutUserInput | SocialMediaAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SocialMediaAccountScalarWhereInput | SocialMediaAccountScalarWhereInput[]
  }

  export type CampaignUpdateManyWithoutUserNestedInput = {
    create?: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput> | CampaignCreateWithoutUserInput[] | CampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutUserInput | CampaignCreateOrConnectWithoutUserInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutUserInput | CampaignUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CampaignCreateManyUserInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutUserInput | CampaignUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutUserInput | CampaignUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type AdSetUpdateManyWithoutUserNestedInput = {
    create?: XOR<AdSetCreateWithoutUserInput, AdSetUncheckedCreateWithoutUserInput> | AdSetCreateWithoutUserInput[] | AdSetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdSetCreateOrConnectWithoutUserInput | AdSetCreateOrConnectWithoutUserInput[]
    upsert?: AdSetUpsertWithWhereUniqueWithoutUserInput | AdSetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AdSetCreateManyUserInputEnvelope
    set?: AdSetWhereUniqueInput | AdSetWhereUniqueInput[]
    disconnect?: AdSetWhereUniqueInput | AdSetWhereUniqueInput[]
    delete?: AdSetWhereUniqueInput | AdSetWhereUniqueInput[]
    connect?: AdSetWhereUniqueInput | AdSetWhereUniqueInput[]
    update?: AdSetUpdateWithWhereUniqueWithoutUserInput | AdSetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AdSetUpdateManyWithWhereWithoutUserInput | AdSetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AdSetScalarWhereInput | AdSetScalarWhereInput[]
  }

  export type AdUpdateManyWithoutUserNestedInput = {
    create?: XOR<AdCreateWithoutUserInput, AdUncheckedCreateWithoutUserInput> | AdCreateWithoutUserInput[] | AdUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdCreateOrConnectWithoutUserInput | AdCreateOrConnectWithoutUserInput[]
    upsert?: AdUpsertWithWhereUniqueWithoutUserInput | AdUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AdCreateManyUserInputEnvelope
    set?: AdWhereUniqueInput | AdWhereUniqueInput[]
    disconnect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    delete?: AdWhereUniqueInput | AdWhereUniqueInput[]
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    update?: AdUpdateWithWhereUniqueWithoutUserInput | AdUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AdUpdateManyWithWhereWithoutUserInput | AdUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AdScalarWhereInput | AdScalarWhereInput[]
  }

  export type ScheduleUpdateManyWithoutUserNestedInput = {
    create?: XOR<ScheduleCreateWithoutUserInput, ScheduleUncheckedCreateWithoutUserInput> | ScheduleCreateWithoutUserInput[] | ScheduleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutUserInput | ScheduleCreateOrConnectWithoutUserInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutUserInput | ScheduleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ScheduleCreateManyUserInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutUserInput | ScheduleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutUserInput | ScheduleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutUserNestedInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutUserInput | InvoiceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutUserInput | InvoiceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutUserInput | InvoiceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type InfluencerUpdateManyWithoutUserNestedInput = {
    create?: XOR<InfluencerCreateWithoutUserInput, InfluencerUncheckedCreateWithoutUserInput> | InfluencerCreateWithoutUserInput[] | InfluencerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InfluencerCreateOrConnectWithoutUserInput | InfluencerCreateOrConnectWithoutUserInput[]
    upsert?: InfluencerUpsertWithWhereUniqueWithoutUserInput | InfluencerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InfluencerCreateManyUserInputEnvelope
    set?: InfluencerWhereUniqueInput | InfluencerWhereUniqueInput[]
    disconnect?: InfluencerWhereUniqueInput | InfluencerWhereUniqueInput[]
    delete?: InfluencerWhereUniqueInput | InfluencerWhereUniqueInput[]
    connect?: InfluencerWhereUniqueInput | InfluencerWhereUniqueInput[]
    update?: InfluencerUpdateWithWhereUniqueWithoutUserInput | InfluencerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InfluencerUpdateManyWithWhereWithoutUserInput | InfluencerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InfluencerScalarWhereInput | InfluencerScalarWhereInput[]
  }

  export type ClinicUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClinicCreateWithoutUserInput, ClinicUncheckedCreateWithoutUserInput> | ClinicCreateWithoutUserInput[] | ClinicUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClinicCreateOrConnectWithoutUserInput | ClinicCreateOrConnectWithoutUserInput[]
    upsert?: ClinicUpsertWithWhereUniqueWithoutUserInput | ClinicUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClinicCreateManyUserInputEnvelope
    set?: ClinicWhereUniqueInput | ClinicWhereUniqueInput[]
    disconnect?: ClinicWhereUniqueInput | ClinicWhereUniqueInput[]
    delete?: ClinicWhereUniqueInput | ClinicWhereUniqueInput[]
    connect?: ClinicWhereUniqueInput | ClinicWhereUniqueInput[]
    update?: ClinicUpdateWithWhereUniqueWithoutUserInput | ClinicUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClinicUpdateManyWithWhereWithoutUserInput | ClinicUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClinicScalarWhereInput | ClinicScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProductCreateWithoutUserInput, ProductUncheckedCreateWithoutUserInput> | ProductCreateWithoutUserInput[] | ProductUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUserInput | ProductCreateOrConnectWithoutUserInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutUserInput | ProductUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProductCreateManyUserInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutUserInput | ProductUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutUserInput | ProductUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type MetaAccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MetaAccountCreateWithoutUserInput, MetaAccountUncheckedCreateWithoutUserInput> | MetaAccountCreateWithoutUserInput[] | MetaAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MetaAccountCreateOrConnectWithoutUserInput | MetaAccountCreateOrConnectWithoutUserInput[]
    upsert?: MetaAccountUpsertWithWhereUniqueWithoutUserInput | MetaAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MetaAccountCreateManyUserInputEnvelope
    set?: MetaAccountWhereUniqueInput | MetaAccountWhereUniqueInput[]
    disconnect?: MetaAccountWhereUniqueInput | MetaAccountWhereUniqueInput[]
    delete?: MetaAccountWhereUniqueInput | MetaAccountWhereUniqueInput[]
    connect?: MetaAccountWhereUniqueInput | MetaAccountWhereUniqueInput[]
    update?: MetaAccountUpdateWithWhereUniqueWithoutUserInput | MetaAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MetaAccountUpdateManyWithWhereWithoutUserInput | MetaAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MetaAccountScalarWhereInput | MetaAccountScalarWhereInput[]
  }

  export type SocialMediaAccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SocialMediaAccountCreateWithoutUserInput, SocialMediaAccountUncheckedCreateWithoutUserInput> | SocialMediaAccountCreateWithoutUserInput[] | SocialMediaAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SocialMediaAccountCreateOrConnectWithoutUserInput | SocialMediaAccountCreateOrConnectWithoutUserInput[]
    upsert?: SocialMediaAccountUpsertWithWhereUniqueWithoutUserInput | SocialMediaAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SocialMediaAccountCreateManyUserInputEnvelope
    set?: SocialMediaAccountWhereUniqueInput | SocialMediaAccountWhereUniqueInput[]
    disconnect?: SocialMediaAccountWhereUniqueInput | SocialMediaAccountWhereUniqueInput[]
    delete?: SocialMediaAccountWhereUniqueInput | SocialMediaAccountWhereUniqueInput[]
    connect?: SocialMediaAccountWhereUniqueInput | SocialMediaAccountWhereUniqueInput[]
    update?: SocialMediaAccountUpdateWithWhereUniqueWithoutUserInput | SocialMediaAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SocialMediaAccountUpdateManyWithWhereWithoutUserInput | SocialMediaAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SocialMediaAccountScalarWhereInput | SocialMediaAccountScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput> | CampaignCreateWithoutUserInput[] | CampaignUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutUserInput | CampaignCreateOrConnectWithoutUserInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutUserInput | CampaignUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CampaignCreateManyUserInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutUserInput | CampaignUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutUserInput | CampaignUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type AdSetUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AdSetCreateWithoutUserInput, AdSetUncheckedCreateWithoutUserInput> | AdSetCreateWithoutUserInput[] | AdSetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdSetCreateOrConnectWithoutUserInput | AdSetCreateOrConnectWithoutUserInput[]
    upsert?: AdSetUpsertWithWhereUniqueWithoutUserInput | AdSetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AdSetCreateManyUserInputEnvelope
    set?: AdSetWhereUniqueInput | AdSetWhereUniqueInput[]
    disconnect?: AdSetWhereUniqueInput | AdSetWhereUniqueInput[]
    delete?: AdSetWhereUniqueInput | AdSetWhereUniqueInput[]
    connect?: AdSetWhereUniqueInput | AdSetWhereUniqueInput[]
    update?: AdSetUpdateWithWhereUniqueWithoutUserInput | AdSetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AdSetUpdateManyWithWhereWithoutUserInput | AdSetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AdSetScalarWhereInput | AdSetScalarWhereInput[]
  }

  export type AdUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AdCreateWithoutUserInput, AdUncheckedCreateWithoutUserInput> | AdCreateWithoutUserInput[] | AdUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AdCreateOrConnectWithoutUserInput | AdCreateOrConnectWithoutUserInput[]
    upsert?: AdUpsertWithWhereUniqueWithoutUserInput | AdUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AdCreateManyUserInputEnvelope
    set?: AdWhereUniqueInput | AdWhereUniqueInput[]
    disconnect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    delete?: AdWhereUniqueInput | AdWhereUniqueInput[]
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    update?: AdUpdateWithWhereUniqueWithoutUserInput | AdUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AdUpdateManyWithWhereWithoutUserInput | AdUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AdScalarWhereInput | AdScalarWhereInput[]
  }

  export type ScheduleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ScheduleCreateWithoutUserInput, ScheduleUncheckedCreateWithoutUserInput> | ScheduleCreateWithoutUserInput[] | ScheduleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutUserInput | ScheduleCreateOrConnectWithoutUserInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutUserInput | ScheduleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ScheduleCreateManyUserInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutUserInput | ScheduleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutUserInput | ScheduleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput> | InvoiceCreateWithoutUserInput[] | InvoiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutUserInput | InvoiceCreateOrConnectWithoutUserInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutUserInput | InvoiceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InvoiceCreateManyUserInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutUserInput | InvoiceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutUserInput | InvoiceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type InfluencerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InfluencerCreateWithoutUserInput, InfluencerUncheckedCreateWithoutUserInput> | InfluencerCreateWithoutUserInput[] | InfluencerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InfluencerCreateOrConnectWithoutUserInput | InfluencerCreateOrConnectWithoutUserInput[]
    upsert?: InfluencerUpsertWithWhereUniqueWithoutUserInput | InfluencerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InfluencerCreateManyUserInputEnvelope
    set?: InfluencerWhereUniqueInput | InfluencerWhereUniqueInput[]
    disconnect?: InfluencerWhereUniqueInput | InfluencerWhereUniqueInput[]
    delete?: InfluencerWhereUniqueInput | InfluencerWhereUniqueInput[]
    connect?: InfluencerWhereUniqueInput | InfluencerWhereUniqueInput[]
    update?: InfluencerUpdateWithWhereUniqueWithoutUserInput | InfluencerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InfluencerUpdateManyWithWhereWithoutUserInput | InfluencerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InfluencerScalarWhereInput | InfluencerScalarWhereInput[]
  }

  export type ClinicUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClinicCreateWithoutUserInput, ClinicUncheckedCreateWithoutUserInput> | ClinicCreateWithoutUserInput[] | ClinicUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClinicCreateOrConnectWithoutUserInput | ClinicCreateOrConnectWithoutUserInput[]
    upsert?: ClinicUpsertWithWhereUniqueWithoutUserInput | ClinicUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClinicCreateManyUserInputEnvelope
    set?: ClinicWhereUniqueInput | ClinicWhereUniqueInput[]
    disconnect?: ClinicWhereUniqueInput | ClinicWhereUniqueInput[]
    delete?: ClinicWhereUniqueInput | ClinicWhereUniqueInput[]
    connect?: ClinicWhereUniqueInput | ClinicWhereUniqueInput[]
    update?: ClinicUpdateWithWhereUniqueWithoutUserInput | ClinicUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClinicUpdateManyWithWhereWithoutUserInput | ClinicUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClinicScalarWhereInput | ClinicScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProductCreateWithoutUserInput, ProductUncheckedCreateWithoutUserInput> | ProductCreateWithoutUserInput[] | ProductUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUserInput | ProductCreateOrConnectWithoutUserInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutUserInput | ProductUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProductCreateManyUserInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutUserInput | ProductUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutUserInput | ProductUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutMetaAccountsInput = {
    create?: XOR<UserCreateWithoutMetaAccountsInput, UserUncheckedCreateWithoutMetaAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMetaAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type CampaignCreateNestedManyWithoutMetaAccountInput = {
    create?: XOR<CampaignCreateWithoutMetaAccountInput, CampaignUncheckedCreateWithoutMetaAccountInput> | CampaignCreateWithoutMetaAccountInput[] | CampaignUncheckedCreateWithoutMetaAccountInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutMetaAccountInput | CampaignCreateOrConnectWithoutMetaAccountInput[]
    createMany?: CampaignCreateManyMetaAccountInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type AdSetCreateNestedManyWithoutMetaAccountInput = {
    create?: XOR<AdSetCreateWithoutMetaAccountInput, AdSetUncheckedCreateWithoutMetaAccountInput> | AdSetCreateWithoutMetaAccountInput[] | AdSetUncheckedCreateWithoutMetaAccountInput[]
    connectOrCreate?: AdSetCreateOrConnectWithoutMetaAccountInput | AdSetCreateOrConnectWithoutMetaAccountInput[]
    createMany?: AdSetCreateManyMetaAccountInputEnvelope
    connect?: AdSetWhereUniqueInput | AdSetWhereUniqueInput[]
  }

  export type AdCreateNestedManyWithoutMetaAccountInput = {
    create?: XOR<AdCreateWithoutMetaAccountInput, AdUncheckedCreateWithoutMetaAccountInput> | AdCreateWithoutMetaAccountInput[] | AdUncheckedCreateWithoutMetaAccountInput[]
    connectOrCreate?: AdCreateOrConnectWithoutMetaAccountInput | AdCreateOrConnectWithoutMetaAccountInput[]
    createMany?: AdCreateManyMetaAccountInputEnvelope
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
  }

  export type AdAccountCreateNestedManyWithoutMetaAccountInput = {
    create?: XOR<AdAccountCreateWithoutMetaAccountInput, AdAccountUncheckedCreateWithoutMetaAccountInput> | AdAccountCreateWithoutMetaAccountInput[] | AdAccountUncheckedCreateWithoutMetaAccountInput[]
    connectOrCreate?: AdAccountCreateOrConnectWithoutMetaAccountInput | AdAccountCreateOrConnectWithoutMetaAccountInput[]
    createMany?: AdAccountCreateManyMetaAccountInputEnvelope
    connect?: AdAccountWhereUniqueInput | AdAccountWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutMetaAccountInput = {
    create?: XOR<CampaignCreateWithoutMetaAccountInput, CampaignUncheckedCreateWithoutMetaAccountInput> | CampaignCreateWithoutMetaAccountInput[] | CampaignUncheckedCreateWithoutMetaAccountInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutMetaAccountInput | CampaignCreateOrConnectWithoutMetaAccountInput[]
    createMany?: CampaignCreateManyMetaAccountInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type AdSetUncheckedCreateNestedManyWithoutMetaAccountInput = {
    create?: XOR<AdSetCreateWithoutMetaAccountInput, AdSetUncheckedCreateWithoutMetaAccountInput> | AdSetCreateWithoutMetaAccountInput[] | AdSetUncheckedCreateWithoutMetaAccountInput[]
    connectOrCreate?: AdSetCreateOrConnectWithoutMetaAccountInput | AdSetCreateOrConnectWithoutMetaAccountInput[]
    createMany?: AdSetCreateManyMetaAccountInputEnvelope
    connect?: AdSetWhereUniqueInput | AdSetWhereUniqueInput[]
  }

  export type AdUncheckedCreateNestedManyWithoutMetaAccountInput = {
    create?: XOR<AdCreateWithoutMetaAccountInput, AdUncheckedCreateWithoutMetaAccountInput> | AdCreateWithoutMetaAccountInput[] | AdUncheckedCreateWithoutMetaAccountInput[]
    connectOrCreate?: AdCreateOrConnectWithoutMetaAccountInput | AdCreateOrConnectWithoutMetaAccountInput[]
    createMany?: AdCreateManyMetaAccountInputEnvelope
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
  }

  export type AdAccountUncheckedCreateNestedManyWithoutMetaAccountInput = {
    create?: XOR<AdAccountCreateWithoutMetaAccountInput, AdAccountUncheckedCreateWithoutMetaAccountInput> | AdAccountCreateWithoutMetaAccountInput[] | AdAccountUncheckedCreateWithoutMetaAccountInput[]
    connectOrCreate?: AdAccountCreateOrConnectWithoutMetaAccountInput | AdAccountCreateOrConnectWithoutMetaAccountInput[]
    createMany?: AdAccountCreateManyMetaAccountInputEnvelope
    connect?: AdAccountWhereUniqueInput | AdAccountWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutMetaAccountsNestedInput = {
    create?: XOR<UserCreateWithoutMetaAccountsInput, UserUncheckedCreateWithoutMetaAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMetaAccountsInput
    upsert?: UserUpsertWithoutMetaAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMetaAccountsInput, UserUpdateWithoutMetaAccountsInput>, UserUncheckedUpdateWithoutMetaAccountsInput>
  }

  export type CampaignUpdateManyWithoutMetaAccountNestedInput = {
    create?: XOR<CampaignCreateWithoutMetaAccountInput, CampaignUncheckedCreateWithoutMetaAccountInput> | CampaignCreateWithoutMetaAccountInput[] | CampaignUncheckedCreateWithoutMetaAccountInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutMetaAccountInput | CampaignCreateOrConnectWithoutMetaAccountInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutMetaAccountInput | CampaignUpsertWithWhereUniqueWithoutMetaAccountInput[]
    createMany?: CampaignCreateManyMetaAccountInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutMetaAccountInput | CampaignUpdateWithWhereUniqueWithoutMetaAccountInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutMetaAccountInput | CampaignUpdateManyWithWhereWithoutMetaAccountInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type AdSetUpdateManyWithoutMetaAccountNestedInput = {
    create?: XOR<AdSetCreateWithoutMetaAccountInput, AdSetUncheckedCreateWithoutMetaAccountInput> | AdSetCreateWithoutMetaAccountInput[] | AdSetUncheckedCreateWithoutMetaAccountInput[]
    connectOrCreate?: AdSetCreateOrConnectWithoutMetaAccountInput | AdSetCreateOrConnectWithoutMetaAccountInput[]
    upsert?: AdSetUpsertWithWhereUniqueWithoutMetaAccountInput | AdSetUpsertWithWhereUniqueWithoutMetaAccountInput[]
    createMany?: AdSetCreateManyMetaAccountInputEnvelope
    set?: AdSetWhereUniqueInput | AdSetWhereUniqueInput[]
    disconnect?: AdSetWhereUniqueInput | AdSetWhereUniqueInput[]
    delete?: AdSetWhereUniqueInput | AdSetWhereUniqueInput[]
    connect?: AdSetWhereUniqueInput | AdSetWhereUniqueInput[]
    update?: AdSetUpdateWithWhereUniqueWithoutMetaAccountInput | AdSetUpdateWithWhereUniqueWithoutMetaAccountInput[]
    updateMany?: AdSetUpdateManyWithWhereWithoutMetaAccountInput | AdSetUpdateManyWithWhereWithoutMetaAccountInput[]
    deleteMany?: AdSetScalarWhereInput | AdSetScalarWhereInput[]
  }

  export type AdUpdateManyWithoutMetaAccountNestedInput = {
    create?: XOR<AdCreateWithoutMetaAccountInput, AdUncheckedCreateWithoutMetaAccountInput> | AdCreateWithoutMetaAccountInput[] | AdUncheckedCreateWithoutMetaAccountInput[]
    connectOrCreate?: AdCreateOrConnectWithoutMetaAccountInput | AdCreateOrConnectWithoutMetaAccountInput[]
    upsert?: AdUpsertWithWhereUniqueWithoutMetaAccountInput | AdUpsertWithWhereUniqueWithoutMetaAccountInput[]
    createMany?: AdCreateManyMetaAccountInputEnvelope
    set?: AdWhereUniqueInput | AdWhereUniqueInput[]
    disconnect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    delete?: AdWhereUniqueInput | AdWhereUniqueInput[]
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    update?: AdUpdateWithWhereUniqueWithoutMetaAccountInput | AdUpdateWithWhereUniqueWithoutMetaAccountInput[]
    updateMany?: AdUpdateManyWithWhereWithoutMetaAccountInput | AdUpdateManyWithWhereWithoutMetaAccountInput[]
    deleteMany?: AdScalarWhereInput | AdScalarWhereInput[]
  }

  export type AdAccountUpdateManyWithoutMetaAccountNestedInput = {
    create?: XOR<AdAccountCreateWithoutMetaAccountInput, AdAccountUncheckedCreateWithoutMetaAccountInput> | AdAccountCreateWithoutMetaAccountInput[] | AdAccountUncheckedCreateWithoutMetaAccountInput[]
    connectOrCreate?: AdAccountCreateOrConnectWithoutMetaAccountInput | AdAccountCreateOrConnectWithoutMetaAccountInput[]
    upsert?: AdAccountUpsertWithWhereUniqueWithoutMetaAccountInput | AdAccountUpsertWithWhereUniqueWithoutMetaAccountInput[]
    createMany?: AdAccountCreateManyMetaAccountInputEnvelope
    set?: AdAccountWhereUniqueInput | AdAccountWhereUniqueInput[]
    disconnect?: AdAccountWhereUniqueInput | AdAccountWhereUniqueInput[]
    delete?: AdAccountWhereUniqueInput | AdAccountWhereUniqueInput[]
    connect?: AdAccountWhereUniqueInput | AdAccountWhereUniqueInput[]
    update?: AdAccountUpdateWithWhereUniqueWithoutMetaAccountInput | AdAccountUpdateWithWhereUniqueWithoutMetaAccountInput[]
    updateMany?: AdAccountUpdateManyWithWhereWithoutMetaAccountInput | AdAccountUpdateManyWithWhereWithoutMetaAccountInput[]
    deleteMany?: AdAccountScalarWhereInput | AdAccountScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutMetaAccountNestedInput = {
    create?: XOR<CampaignCreateWithoutMetaAccountInput, CampaignUncheckedCreateWithoutMetaAccountInput> | CampaignCreateWithoutMetaAccountInput[] | CampaignUncheckedCreateWithoutMetaAccountInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutMetaAccountInput | CampaignCreateOrConnectWithoutMetaAccountInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutMetaAccountInput | CampaignUpsertWithWhereUniqueWithoutMetaAccountInput[]
    createMany?: CampaignCreateManyMetaAccountInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutMetaAccountInput | CampaignUpdateWithWhereUniqueWithoutMetaAccountInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutMetaAccountInput | CampaignUpdateManyWithWhereWithoutMetaAccountInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type AdSetUncheckedUpdateManyWithoutMetaAccountNestedInput = {
    create?: XOR<AdSetCreateWithoutMetaAccountInput, AdSetUncheckedCreateWithoutMetaAccountInput> | AdSetCreateWithoutMetaAccountInput[] | AdSetUncheckedCreateWithoutMetaAccountInput[]
    connectOrCreate?: AdSetCreateOrConnectWithoutMetaAccountInput | AdSetCreateOrConnectWithoutMetaAccountInput[]
    upsert?: AdSetUpsertWithWhereUniqueWithoutMetaAccountInput | AdSetUpsertWithWhereUniqueWithoutMetaAccountInput[]
    createMany?: AdSetCreateManyMetaAccountInputEnvelope
    set?: AdSetWhereUniqueInput | AdSetWhereUniqueInput[]
    disconnect?: AdSetWhereUniqueInput | AdSetWhereUniqueInput[]
    delete?: AdSetWhereUniqueInput | AdSetWhereUniqueInput[]
    connect?: AdSetWhereUniqueInput | AdSetWhereUniqueInput[]
    update?: AdSetUpdateWithWhereUniqueWithoutMetaAccountInput | AdSetUpdateWithWhereUniqueWithoutMetaAccountInput[]
    updateMany?: AdSetUpdateManyWithWhereWithoutMetaAccountInput | AdSetUpdateManyWithWhereWithoutMetaAccountInput[]
    deleteMany?: AdSetScalarWhereInput | AdSetScalarWhereInput[]
  }

  export type AdUncheckedUpdateManyWithoutMetaAccountNestedInput = {
    create?: XOR<AdCreateWithoutMetaAccountInput, AdUncheckedCreateWithoutMetaAccountInput> | AdCreateWithoutMetaAccountInput[] | AdUncheckedCreateWithoutMetaAccountInput[]
    connectOrCreate?: AdCreateOrConnectWithoutMetaAccountInput | AdCreateOrConnectWithoutMetaAccountInput[]
    upsert?: AdUpsertWithWhereUniqueWithoutMetaAccountInput | AdUpsertWithWhereUniqueWithoutMetaAccountInput[]
    createMany?: AdCreateManyMetaAccountInputEnvelope
    set?: AdWhereUniqueInput | AdWhereUniqueInput[]
    disconnect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    delete?: AdWhereUniqueInput | AdWhereUniqueInput[]
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    update?: AdUpdateWithWhereUniqueWithoutMetaAccountInput | AdUpdateWithWhereUniqueWithoutMetaAccountInput[]
    updateMany?: AdUpdateManyWithWhereWithoutMetaAccountInput | AdUpdateManyWithWhereWithoutMetaAccountInput[]
    deleteMany?: AdScalarWhereInput | AdScalarWhereInput[]
  }

  export type AdAccountUncheckedUpdateManyWithoutMetaAccountNestedInput = {
    create?: XOR<AdAccountCreateWithoutMetaAccountInput, AdAccountUncheckedCreateWithoutMetaAccountInput> | AdAccountCreateWithoutMetaAccountInput[] | AdAccountUncheckedCreateWithoutMetaAccountInput[]
    connectOrCreate?: AdAccountCreateOrConnectWithoutMetaAccountInput | AdAccountCreateOrConnectWithoutMetaAccountInput[]
    upsert?: AdAccountUpsertWithWhereUniqueWithoutMetaAccountInput | AdAccountUpsertWithWhereUniqueWithoutMetaAccountInput[]
    createMany?: AdAccountCreateManyMetaAccountInputEnvelope
    set?: AdAccountWhereUniqueInput | AdAccountWhereUniqueInput[]
    disconnect?: AdAccountWhereUniqueInput | AdAccountWhereUniqueInput[]
    delete?: AdAccountWhereUniqueInput | AdAccountWhereUniqueInput[]
    connect?: AdAccountWhereUniqueInput | AdAccountWhereUniqueInput[]
    update?: AdAccountUpdateWithWhereUniqueWithoutMetaAccountInput | AdAccountUpdateWithWhereUniqueWithoutMetaAccountInput[]
    updateMany?: AdAccountUpdateManyWithWhereWithoutMetaAccountInput | AdAccountUpdateManyWithWhereWithoutMetaAccountInput[]
    deleteMany?: AdAccountScalarWhereInput | AdAccountScalarWhereInput[]
  }

  export type MetaAccountCreateNestedOneWithoutAdAccountsInput = {
    create?: XOR<MetaAccountCreateWithoutAdAccountsInput, MetaAccountUncheckedCreateWithoutAdAccountsInput>
    connectOrCreate?: MetaAccountCreateOrConnectWithoutAdAccountsInput
    connect?: MetaAccountWhereUniqueInput
  }

  export type CampaignCreateNestedManyWithoutAdAccountInput = {
    create?: XOR<CampaignCreateWithoutAdAccountInput, CampaignUncheckedCreateWithoutAdAccountInput> | CampaignCreateWithoutAdAccountInput[] | CampaignUncheckedCreateWithoutAdAccountInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutAdAccountInput | CampaignCreateOrConnectWithoutAdAccountInput[]
    createMany?: CampaignCreateManyAdAccountInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutAdAccountInput = {
    create?: XOR<CampaignCreateWithoutAdAccountInput, CampaignUncheckedCreateWithoutAdAccountInput> | CampaignCreateWithoutAdAccountInput[] | CampaignUncheckedCreateWithoutAdAccountInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutAdAccountInput | CampaignCreateOrConnectWithoutAdAccountInput[]
    createMany?: CampaignCreateManyAdAccountInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type MetaAccountUpdateOneRequiredWithoutAdAccountsNestedInput = {
    create?: XOR<MetaAccountCreateWithoutAdAccountsInput, MetaAccountUncheckedCreateWithoutAdAccountsInput>
    connectOrCreate?: MetaAccountCreateOrConnectWithoutAdAccountsInput
    upsert?: MetaAccountUpsertWithoutAdAccountsInput
    connect?: MetaAccountWhereUniqueInput
    update?: XOR<XOR<MetaAccountUpdateToOneWithWhereWithoutAdAccountsInput, MetaAccountUpdateWithoutAdAccountsInput>, MetaAccountUncheckedUpdateWithoutAdAccountsInput>
  }

  export type CampaignUpdateManyWithoutAdAccountNestedInput = {
    create?: XOR<CampaignCreateWithoutAdAccountInput, CampaignUncheckedCreateWithoutAdAccountInput> | CampaignCreateWithoutAdAccountInput[] | CampaignUncheckedCreateWithoutAdAccountInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutAdAccountInput | CampaignCreateOrConnectWithoutAdAccountInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutAdAccountInput | CampaignUpsertWithWhereUniqueWithoutAdAccountInput[]
    createMany?: CampaignCreateManyAdAccountInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutAdAccountInput | CampaignUpdateWithWhereUniqueWithoutAdAccountInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutAdAccountInput | CampaignUpdateManyWithWhereWithoutAdAccountInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutAdAccountNestedInput = {
    create?: XOR<CampaignCreateWithoutAdAccountInput, CampaignUncheckedCreateWithoutAdAccountInput> | CampaignCreateWithoutAdAccountInput[] | CampaignUncheckedCreateWithoutAdAccountInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutAdAccountInput | CampaignCreateOrConnectWithoutAdAccountInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutAdAccountInput | CampaignUpsertWithWhereUniqueWithoutAdAccountInput[]
    createMany?: CampaignCreateManyAdAccountInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutAdAccountInput | CampaignUpdateWithWhereUniqueWithoutAdAccountInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutAdAccountInput | CampaignUpdateManyWithWhereWithoutAdAccountInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<UserCreateWithoutCampaignsInput, UserUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCampaignsInput
    connect?: UserWhereUniqueInput
  }

  export type MetaAccountCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<MetaAccountCreateWithoutCampaignsInput, MetaAccountUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: MetaAccountCreateOrConnectWithoutCampaignsInput
    connect?: MetaAccountWhereUniqueInput
  }

  export type AdAccountCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<AdAccountCreateWithoutCampaignsInput, AdAccountUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: AdAccountCreateOrConnectWithoutCampaignsInput
    connect?: AdAccountWhereUniqueInput
  }

  export type AdSetCreateNestedManyWithoutCampaignInput = {
    create?: XOR<AdSetCreateWithoutCampaignInput, AdSetUncheckedCreateWithoutCampaignInput> | AdSetCreateWithoutCampaignInput[] | AdSetUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: AdSetCreateOrConnectWithoutCampaignInput | AdSetCreateOrConnectWithoutCampaignInput[]
    createMany?: AdSetCreateManyCampaignInputEnvelope
    connect?: AdSetWhereUniqueInput | AdSetWhereUniqueInput[]
  }

  export type TagsOnCampaignsCreateNestedManyWithoutCampaignInput = {
    create?: XOR<TagsOnCampaignsCreateWithoutCampaignInput, TagsOnCampaignsUncheckedCreateWithoutCampaignInput> | TagsOnCampaignsCreateWithoutCampaignInput[] | TagsOnCampaignsUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: TagsOnCampaignsCreateOrConnectWithoutCampaignInput | TagsOnCampaignsCreateOrConnectWithoutCampaignInput[]
    createMany?: TagsOnCampaignsCreateManyCampaignInputEnvelope
    connect?: TagsOnCampaignsWhereUniqueInput | TagsOnCampaignsWhereUniqueInput[]
  }

  export type CampaignMetricsCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignMetricsCreateWithoutCampaignInput, CampaignMetricsUncheckedCreateWithoutCampaignInput> | CampaignMetricsCreateWithoutCampaignInput[] | CampaignMetricsUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignMetricsCreateOrConnectWithoutCampaignInput | CampaignMetricsCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignMetricsCreateManyCampaignInputEnvelope
    connect?: CampaignMetricsWhereUniqueInput | CampaignMetricsWhereUniqueInput[]
  }

  export type ClinicCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<ClinicCreateWithoutCampaignsInput, ClinicUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutCampaignsInput
    connect?: ClinicWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<ProductCreateWithoutCampaignsInput, ProductUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCampaignsInput
    connect?: ProductWhereUniqueInput
  }

  export type AdSetUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<AdSetCreateWithoutCampaignInput, AdSetUncheckedCreateWithoutCampaignInput> | AdSetCreateWithoutCampaignInput[] | AdSetUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: AdSetCreateOrConnectWithoutCampaignInput | AdSetCreateOrConnectWithoutCampaignInput[]
    createMany?: AdSetCreateManyCampaignInputEnvelope
    connect?: AdSetWhereUniqueInput | AdSetWhereUniqueInput[]
  }

  export type TagsOnCampaignsUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<TagsOnCampaignsCreateWithoutCampaignInput, TagsOnCampaignsUncheckedCreateWithoutCampaignInput> | TagsOnCampaignsCreateWithoutCampaignInput[] | TagsOnCampaignsUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: TagsOnCampaignsCreateOrConnectWithoutCampaignInput | TagsOnCampaignsCreateOrConnectWithoutCampaignInput[]
    createMany?: TagsOnCampaignsCreateManyCampaignInputEnvelope
    connect?: TagsOnCampaignsWhereUniqueInput | TagsOnCampaignsWhereUniqueInput[]
  }

  export type CampaignMetricsUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<CampaignMetricsCreateWithoutCampaignInput, CampaignMetricsUncheckedCreateWithoutCampaignInput> | CampaignMetricsCreateWithoutCampaignInput[] | CampaignMetricsUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignMetricsCreateOrConnectWithoutCampaignInput | CampaignMetricsCreateOrConnectWithoutCampaignInput[]
    createMany?: CampaignMetricsCreateManyCampaignInputEnvelope
    connect?: CampaignMetricsWhereUniqueInput | CampaignMetricsWhereUniqueInput[]
  }

  export type EnumCampaignStatusFieldUpdateOperationsInput = {
    set?: $Enums.CampaignStatus
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumBudgetTypeFieldUpdateOperationsInput = {
    set?: $Enums.BudgetType | null
  }

  export type UserUpdateOneRequiredWithoutCampaignsNestedInput = {
    create?: XOR<UserCreateWithoutCampaignsInput, UserUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCampaignsInput
    upsert?: UserUpsertWithoutCampaignsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCampaignsInput, UserUpdateWithoutCampaignsInput>, UserUncheckedUpdateWithoutCampaignsInput>
  }

  export type MetaAccountUpdateOneWithoutCampaignsNestedInput = {
    create?: XOR<MetaAccountCreateWithoutCampaignsInput, MetaAccountUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: MetaAccountCreateOrConnectWithoutCampaignsInput
    upsert?: MetaAccountUpsertWithoutCampaignsInput
    disconnect?: MetaAccountWhereInput | boolean
    delete?: MetaAccountWhereInput | boolean
    connect?: MetaAccountWhereUniqueInput
    update?: XOR<XOR<MetaAccountUpdateToOneWithWhereWithoutCampaignsInput, MetaAccountUpdateWithoutCampaignsInput>, MetaAccountUncheckedUpdateWithoutCampaignsInput>
  }

  export type AdAccountUpdateOneWithoutCampaignsNestedInput = {
    create?: XOR<AdAccountCreateWithoutCampaignsInput, AdAccountUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: AdAccountCreateOrConnectWithoutCampaignsInput
    upsert?: AdAccountUpsertWithoutCampaignsInput
    disconnect?: AdAccountWhereInput | boolean
    delete?: AdAccountWhereInput | boolean
    connect?: AdAccountWhereUniqueInput
    update?: XOR<XOR<AdAccountUpdateToOneWithWhereWithoutCampaignsInput, AdAccountUpdateWithoutCampaignsInput>, AdAccountUncheckedUpdateWithoutCampaignsInput>
  }

  export type AdSetUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<AdSetCreateWithoutCampaignInput, AdSetUncheckedCreateWithoutCampaignInput> | AdSetCreateWithoutCampaignInput[] | AdSetUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: AdSetCreateOrConnectWithoutCampaignInput | AdSetCreateOrConnectWithoutCampaignInput[]
    upsert?: AdSetUpsertWithWhereUniqueWithoutCampaignInput | AdSetUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: AdSetCreateManyCampaignInputEnvelope
    set?: AdSetWhereUniqueInput | AdSetWhereUniqueInput[]
    disconnect?: AdSetWhereUniqueInput | AdSetWhereUniqueInput[]
    delete?: AdSetWhereUniqueInput | AdSetWhereUniqueInput[]
    connect?: AdSetWhereUniqueInput | AdSetWhereUniqueInput[]
    update?: AdSetUpdateWithWhereUniqueWithoutCampaignInput | AdSetUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: AdSetUpdateManyWithWhereWithoutCampaignInput | AdSetUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: AdSetScalarWhereInput | AdSetScalarWhereInput[]
  }

  export type TagsOnCampaignsUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<TagsOnCampaignsCreateWithoutCampaignInput, TagsOnCampaignsUncheckedCreateWithoutCampaignInput> | TagsOnCampaignsCreateWithoutCampaignInput[] | TagsOnCampaignsUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: TagsOnCampaignsCreateOrConnectWithoutCampaignInput | TagsOnCampaignsCreateOrConnectWithoutCampaignInput[]
    upsert?: TagsOnCampaignsUpsertWithWhereUniqueWithoutCampaignInput | TagsOnCampaignsUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: TagsOnCampaignsCreateManyCampaignInputEnvelope
    set?: TagsOnCampaignsWhereUniqueInput | TagsOnCampaignsWhereUniqueInput[]
    disconnect?: TagsOnCampaignsWhereUniqueInput | TagsOnCampaignsWhereUniqueInput[]
    delete?: TagsOnCampaignsWhereUniqueInput | TagsOnCampaignsWhereUniqueInput[]
    connect?: TagsOnCampaignsWhereUniqueInput | TagsOnCampaignsWhereUniqueInput[]
    update?: TagsOnCampaignsUpdateWithWhereUniqueWithoutCampaignInput | TagsOnCampaignsUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: TagsOnCampaignsUpdateManyWithWhereWithoutCampaignInput | TagsOnCampaignsUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: TagsOnCampaignsScalarWhereInput | TagsOnCampaignsScalarWhereInput[]
  }

  export type CampaignMetricsUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignMetricsCreateWithoutCampaignInput, CampaignMetricsUncheckedCreateWithoutCampaignInput> | CampaignMetricsCreateWithoutCampaignInput[] | CampaignMetricsUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignMetricsCreateOrConnectWithoutCampaignInput | CampaignMetricsCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignMetricsUpsertWithWhereUniqueWithoutCampaignInput | CampaignMetricsUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignMetricsCreateManyCampaignInputEnvelope
    set?: CampaignMetricsWhereUniqueInput | CampaignMetricsWhereUniqueInput[]
    disconnect?: CampaignMetricsWhereUniqueInput | CampaignMetricsWhereUniqueInput[]
    delete?: CampaignMetricsWhereUniqueInput | CampaignMetricsWhereUniqueInput[]
    connect?: CampaignMetricsWhereUniqueInput | CampaignMetricsWhereUniqueInput[]
    update?: CampaignMetricsUpdateWithWhereUniqueWithoutCampaignInput | CampaignMetricsUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignMetricsUpdateManyWithWhereWithoutCampaignInput | CampaignMetricsUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignMetricsScalarWhereInput | CampaignMetricsScalarWhereInput[]
  }

  export type ClinicUpdateOneWithoutCampaignsNestedInput = {
    create?: XOR<ClinicCreateWithoutCampaignsInput, ClinicUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutCampaignsInput
    upsert?: ClinicUpsertWithoutCampaignsInput
    disconnect?: ClinicWhereInput | boolean
    delete?: ClinicWhereInput | boolean
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutCampaignsInput, ClinicUpdateWithoutCampaignsInput>, ClinicUncheckedUpdateWithoutCampaignsInput>
  }

  export type ProductUpdateOneWithoutCampaignsNestedInput = {
    create?: XOR<ProductCreateWithoutCampaignsInput, ProductUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutCampaignsInput
    upsert?: ProductUpsertWithoutCampaignsInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutCampaignsInput, ProductUpdateWithoutCampaignsInput>, ProductUncheckedUpdateWithoutCampaignsInput>
  }

  export type AdSetUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<AdSetCreateWithoutCampaignInput, AdSetUncheckedCreateWithoutCampaignInput> | AdSetCreateWithoutCampaignInput[] | AdSetUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: AdSetCreateOrConnectWithoutCampaignInput | AdSetCreateOrConnectWithoutCampaignInput[]
    upsert?: AdSetUpsertWithWhereUniqueWithoutCampaignInput | AdSetUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: AdSetCreateManyCampaignInputEnvelope
    set?: AdSetWhereUniqueInput | AdSetWhereUniqueInput[]
    disconnect?: AdSetWhereUniqueInput | AdSetWhereUniqueInput[]
    delete?: AdSetWhereUniqueInput | AdSetWhereUniqueInput[]
    connect?: AdSetWhereUniqueInput | AdSetWhereUniqueInput[]
    update?: AdSetUpdateWithWhereUniqueWithoutCampaignInput | AdSetUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: AdSetUpdateManyWithWhereWithoutCampaignInput | AdSetUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: AdSetScalarWhereInput | AdSetScalarWhereInput[]
  }

  export type TagsOnCampaignsUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<TagsOnCampaignsCreateWithoutCampaignInput, TagsOnCampaignsUncheckedCreateWithoutCampaignInput> | TagsOnCampaignsCreateWithoutCampaignInput[] | TagsOnCampaignsUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: TagsOnCampaignsCreateOrConnectWithoutCampaignInput | TagsOnCampaignsCreateOrConnectWithoutCampaignInput[]
    upsert?: TagsOnCampaignsUpsertWithWhereUniqueWithoutCampaignInput | TagsOnCampaignsUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: TagsOnCampaignsCreateManyCampaignInputEnvelope
    set?: TagsOnCampaignsWhereUniqueInput | TagsOnCampaignsWhereUniqueInput[]
    disconnect?: TagsOnCampaignsWhereUniqueInput | TagsOnCampaignsWhereUniqueInput[]
    delete?: TagsOnCampaignsWhereUniqueInput | TagsOnCampaignsWhereUniqueInput[]
    connect?: TagsOnCampaignsWhereUniqueInput | TagsOnCampaignsWhereUniqueInput[]
    update?: TagsOnCampaignsUpdateWithWhereUniqueWithoutCampaignInput | TagsOnCampaignsUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: TagsOnCampaignsUpdateManyWithWhereWithoutCampaignInput | TagsOnCampaignsUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: TagsOnCampaignsScalarWhereInput | TagsOnCampaignsScalarWhereInput[]
  }

  export type CampaignMetricsUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<CampaignMetricsCreateWithoutCampaignInput, CampaignMetricsUncheckedCreateWithoutCampaignInput> | CampaignMetricsCreateWithoutCampaignInput[] | CampaignMetricsUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: CampaignMetricsCreateOrConnectWithoutCampaignInput | CampaignMetricsCreateOrConnectWithoutCampaignInput[]
    upsert?: CampaignMetricsUpsertWithWhereUniqueWithoutCampaignInput | CampaignMetricsUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: CampaignMetricsCreateManyCampaignInputEnvelope
    set?: CampaignMetricsWhereUniqueInput | CampaignMetricsWhereUniqueInput[]
    disconnect?: CampaignMetricsWhereUniqueInput | CampaignMetricsWhereUniqueInput[]
    delete?: CampaignMetricsWhereUniqueInput | CampaignMetricsWhereUniqueInput[]
    connect?: CampaignMetricsWhereUniqueInput | CampaignMetricsWhereUniqueInput[]
    update?: CampaignMetricsUpdateWithWhereUniqueWithoutCampaignInput | CampaignMetricsUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: CampaignMetricsUpdateManyWithWhereWithoutCampaignInput | CampaignMetricsUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: CampaignMetricsScalarWhereInput | CampaignMetricsScalarWhereInput[]
  }

  export type CampaignCreateNestedOneWithoutMetricsInput = {
    create?: XOR<CampaignCreateWithoutMetricsInput, CampaignUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutMetricsInput
    connect?: CampaignWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CampaignUpdateOneRequiredWithoutMetricsNestedInput = {
    create?: XOR<CampaignCreateWithoutMetricsInput, CampaignUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutMetricsInput
    upsert?: CampaignUpsertWithoutMetricsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutMetricsInput, CampaignUpdateWithoutMetricsInput>, CampaignUncheckedUpdateWithoutMetricsInput>
  }

  export type UserCreateNestedOneWithoutAdsetsInput = {
    create?: XOR<UserCreateWithoutAdsetsInput, UserUncheckedCreateWithoutAdsetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdsetsInput
    connect?: UserWhereUniqueInput
  }

  export type CampaignCreateNestedOneWithoutAdSetsInput = {
    create?: XOR<CampaignCreateWithoutAdSetsInput, CampaignUncheckedCreateWithoutAdSetsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutAdSetsInput
    connect?: CampaignWhereUniqueInput
  }

  export type MetaAccountCreateNestedOneWithoutAdSetsInput = {
    create?: XOR<MetaAccountCreateWithoutAdSetsInput, MetaAccountUncheckedCreateWithoutAdSetsInput>
    connectOrCreate?: MetaAccountCreateOrConnectWithoutAdSetsInput
    connect?: MetaAccountWhereUniqueInput
  }

  export type AdCreateNestedManyWithoutAdSetInput = {
    create?: XOR<AdCreateWithoutAdSetInput, AdUncheckedCreateWithoutAdSetInput> | AdCreateWithoutAdSetInput[] | AdUncheckedCreateWithoutAdSetInput[]
    connectOrCreate?: AdCreateOrConnectWithoutAdSetInput | AdCreateOrConnectWithoutAdSetInput[]
    createMany?: AdCreateManyAdSetInputEnvelope
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
  }

  export type AdSetMetricsCreateNestedManyWithoutAdSetInput = {
    create?: XOR<AdSetMetricsCreateWithoutAdSetInput, AdSetMetricsUncheckedCreateWithoutAdSetInput> | AdSetMetricsCreateWithoutAdSetInput[] | AdSetMetricsUncheckedCreateWithoutAdSetInput[]
    connectOrCreate?: AdSetMetricsCreateOrConnectWithoutAdSetInput | AdSetMetricsCreateOrConnectWithoutAdSetInput[]
    createMany?: AdSetMetricsCreateManyAdSetInputEnvelope
    connect?: AdSetMetricsWhereUniqueInput | AdSetMetricsWhereUniqueInput[]
  }

  export type AdUncheckedCreateNestedManyWithoutAdSetInput = {
    create?: XOR<AdCreateWithoutAdSetInput, AdUncheckedCreateWithoutAdSetInput> | AdCreateWithoutAdSetInput[] | AdUncheckedCreateWithoutAdSetInput[]
    connectOrCreate?: AdCreateOrConnectWithoutAdSetInput | AdCreateOrConnectWithoutAdSetInput[]
    createMany?: AdCreateManyAdSetInputEnvelope
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
  }

  export type AdSetMetricsUncheckedCreateNestedManyWithoutAdSetInput = {
    create?: XOR<AdSetMetricsCreateWithoutAdSetInput, AdSetMetricsUncheckedCreateWithoutAdSetInput> | AdSetMetricsCreateWithoutAdSetInput[] | AdSetMetricsUncheckedCreateWithoutAdSetInput[]
    connectOrCreate?: AdSetMetricsCreateOrConnectWithoutAdSetInput | AdSetMetricsCreateOrConnectWithoutAdSetInput[]
    createMany?: AdSetMetricsCreateManyAdSetInputEnvelope
    connect?: AdSetMetricsWhereUniqueInput | AdSetMetricsWhereUniqueInput[]
  }

  export type EnumAdSetStatusFieldUpdateOperationsInput = {
    set?: $Enums.AdSetStatus
  }

  export type UserUpdateOneRequiredWithoutAdsetsNestedInput = {
    create?: XOR<UserCreateWithoutAdsetsInput, UserUncheckedCreateWithoutAdsetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdsetsInput
    upsert?: UserUpsertWithoutAdsetsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdsetsInput, UserUpdateWithoutAdsetsInput>, UserUncheckedUpdateWithoutAdsetsInput>
  }

  export type CampaignUpdateOneRequiredWithoutAdSetsNestedInput = {
    create?: XOR<CampaignCreateWithoutAdSetsInput, CampaignUncheckedCreateWithoutAdSetsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutAdSetsInput
    upsert?: CampaignUpsertWithoutAdSetsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutAdSetsInput, CampaignUpdateWithoutAdSetsInput>, CampaignUncheckedUpdateWithoutAdSetsInput>
  }

  export type MetaAccountUpdateOneWithoutAdSetsNestedInput = {
    create?: XOR<MetaAccountCreateWithoutAdSetsInput, MetaAccountUncheckedCreateWithoutAdSetsInput>
    connectOrCreate?: MetaAccountCreateOrConnectWithoutAdSetsInput
    upsert?: MetaAccountUpsertWithoutAdSetsInput
    disconnect?: MetaAccountWhereInput | boolean
    delete?: MetaAccountWhereInput | boolean
    connect?: MetaAccountWhereUniqueInput
    update?: XOR<XOR<MetaAccountUpdateToOneWithWhereWithoutAdSetsInput, MetaAccountUpdateWithoutAdSetsInput>, MetaAccountUncheckedUpdateWithoutAdSetsInput>
  }

  export type AdUpdateManyWithoutAdSetNestedInput = {
    create?: XOR<AdCreateWithoutAdSetInput, AdUncheckedCreateWithoutAdSetInput> | AdCreateWithoutAdSetInput[] | AdUncheckedCreateWithoutAdSetInput[]
    connectOrCreate?: AdCreateOrConnectWithoutAdSetInput | AdCreateOrConnectWithoutAdSetInput[]
    upsert?: AdUpsertWithWhereUniqueWithoutAdSetInput | AdUpsertWithWhereUniqueWithoutAdSetInput[]
    createMany?: AdCreateManyAdSetInputEnvelope
    set?: AdWhereUniqueInput | AdWhereUniqueInput[]
    disconnect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    delete?: AdWhereUniqueInput | AdWhereUniqueInput[]
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    update?: AdUpdateWithWhereUniqueWithoutAdSetInput | AdUpdateWithWhereUniqueWithoutAdSetInput[]
    updateMany?: AdUpdateManyWithWhereWithoutAdSetInput | AdUpdateManyWithWhereWithoutAdSetInput[]
    deleteMany?: AdScalarWhereInput | AdScalarWhereInput[]
  }

  export type AdSetMetricsUpdateManyWithoutAdSetNestedInput = {
    create?: XOR<AdSetMetricsCreateWithoutAdSetInput, AdSetMetricsUncheckedCreateWithoutAdSetInput> | AdSetMetricsCreateWithoutAdSetInput[] | AdSetMetricsUncheckedCreateWithoutAdSetInput[]
    connectOrCreate?: AdSetMetricsCreateOrConnectWithoutAdSetInput | AdSetMetricsCreateOrConnectWithoutAdSetInput[]
    upsert?: AdSetMetricsUpsertWithWhereUniqueWithoutAdSetInput | AdSetMetricsUpsertWithWhereUniqueWithoutAdSetInput[]
    createMany?: AdSetMetricsCreateManyAdSetInputEnvelope
    set?: AdSetMetricsWhereUniqueInput | AdSetMetricsWhereUniqueInput[]
    disconnect?: AdSetMetricsWhereUniqueInput | AdSetMetricsWhereUniqueInput[]
    delete?: AdSetMetricsWhereUniqueInput | AdSetMetricsWhereUniqueInput[]
    connect?: AdSetMetricsWhereUniqueInput | AdSetMetricsWhereUniqueInput[]
    update?: AdSetMetricsUpdateWithWhereUniqueWithoutAdSetInput | AdSetMetricsUpdateWithWhereUniqueWithoutAdSetInput[]
    updateMany?: AdSetMetricsUpdateManyWithWhereWithoutAdSetInput | AdSetMetricsUpdateManyWithWhereWithoutAdSetInput[]
    deleteMany?: AdSetMetricsScalarWhereInput | AdSetMetricsScalarWhereInput[]
  }

  export type AdUncheckedUpdateManyWithoutAdSetNestedInput = {
    create?: XOR<AdCreateWithoutAdSetInput, AdUncheckedCreateWithoutAdSetInput> | AdCreateWithoutAdSetInput[] | AdUncheckedCreateWithoutAdSetInput[]
    connectOrCreate?: AdCreateOrConnectWithoutAdSetInput | AdCreateOrConnectWithoutAdSetInput[]
    upsert?: AdUpsertWithWhereUniqueWithoutAdSetInput | AdUpsertWithWhereUniqueWithoutAdSetInput[]
    createMany?: AdCreateManyAdSetInputEnvelope
    set?: AdWhereUniqueInput | AdWhereUniqueInput[]
    disconnect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    delete?: AdWhereUniqueInput | AdWhereUniqueInput[]
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    update?: AdUpdateWithWhereUniqueWithoutAdSetInput | AdUpdateWithWhereUniqueWithoutAdSetInput[]
    updateMany?: AdUpdateManyWithWhereWithoutAdSetInput | AdUpdateManyWithWhereWithoutAdSetInput[]
    deleteMany?: AdScalarWhereInput | AdScalarWhereInput[]
  }

  export type AdSetMetricsUncheckedUpdateManyWithoutAdSetNestedInput = {
    create?: XOR<AdSetMetricsCreateWithoutAdSetInput, AdSetMetricsUncheckedCreateWithoutAdSetInput> | AdSetMetricsCreateWithoutAdSetInput[] | AdSetMetricsUncheckedCreateWithoutAdSetInput[]
    connectOrCreate?: AdSetMetricsCreateOrConnectWithoutAdSetInput | AdSetMetricsCreateOrConnectWithoutAdSetInput[]
    upsert?: AdSetMetricsUpsertWithWhereUniqueWithoutAdSetInput | AdSetMetricsUpsertWithWhereUniqueWithoutAdSetInput[]
    createMany?: AdSetMetricsCreateManyAdSetInputEnvelope
    set?: AdSetMetricsWhereUniqueInput | AdSetMetricsWhereUniqueInput[]
    disconnect?: AdSetMetricsWhereUniqueInput | AdSetMetricsWhereUniqueInput[]
    delete?: AdSetMetricsWhereUniqueInput | AdSetMetricsWhereUniqueInput[]
    connect?: AdSetMetricsWhereUniqueInput | AdSetMetricsWhereUniqueInput[]
    update?: AdSetMetricsUpdateWithWhereUniqueWithoutAdSetInput | AdSetMetricsUpdateWithWhereUniqueWithoutAdSetInput[]
    updateMany?: AdSetMetricsUpdateManyWithWhereWithoutAdSetInput | AdSetMetricsUpdateManyWithWhereWithoutAdSetInput[]
    deleteMany?: AdSetMetricsScalarWhereInput | AdSetMetricsScalarWhereInput[]
  }

  export type AdSetCreateNestedOneWithoutMetricsInput = {
    create?: XOR<AdSetCreateWithoutMetricsInput, AdSetUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: AdSetCreateOrConnectWithoutMetricsInput
    connect?: AdSetWhereUniqueInput
  }

  export type AdSetUpdateOneRequiredWithoutMetricsNestedInput = {
    create?: XOR<AdSetCreateWithoutMetricsInput, AdSetUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: AdSetCreateOrConnectWithoutMetricsInput
    upsert?: AdSetUpsertWithoutMetricsInput
    connect?: AdSetWhereUniqueInput
    update?: XOR<XOR<AdSetUpdateToOneWithWhereWithoutMetricsInput, AdSetUpdateWithoutMetricsInput>, AdSetUncheckedUpdateWithoutMetricsInput>
  }

  export type UserCreateNestedOneWithoutAdsInput = {
    create?: XOR<UserCreateWithoutAdsInput, UserUncheckedCreateWithoutAdsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdsInput
    connect?: UserWhereUniqueInput
  }

  export type AdSetCreateNestedOneWithoutAdsInput = {
    create?: XOR<AdSetCreateWithoutAdsInput, AdSetUncheckedCreateWithoutAdsInput>
    connectOrCreate?: AdSetCreateOrConnectWithoutAdsInput
    connect?: AdSetWhereUniqueInput
  }

  export type MetaAccountCreateNestedOneWithoutAdsInput = {
    create?: XOR<MetaAccountCreateWithoutAdsInput, MetaAccountUncheckedCreateWithoutAdsInput>
    connectOrCreate?: MetaAccountCreateOrConnectWithoutAdsInput
    connect?: MetaAccountWhereUniqueInput
  }

  export type AdMetricsCreateNestedManyWithoutAdInput = {
    create?: XOR<AdMetricsCreateWithoutAdInput, AdMetricsUncheckedCreateWithoutAdInput> | AdMetricsCreateWithoutAdInput[] | AdMetricsUncheckedCreateWithoutAdInput[]
    connectOrCreate?: AdMetricsCreateOrConnectWithoutAdInput | AdMetricsCreateOrConnectWithoutAdInput[]
    createMany?: AdMetricsCreateManyAdInputEnvelope
    connect?: AdMetricsWhereUniqueInput | AdMetricsWhereUniqueInput[]
  }

  export type ScheduleCreateNestedManyWithoutAdInput = {
    create?: XOR<ScheduleCreateWithoutAdInput, ScheduleUncheckedCreateWithoutAdInput> | ScheduleCreateWithoutAdInput[] | ScheduleUncheckedCreateWithoutAdInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutAdInput | ScheduleCreateOrConnectWithoutAdInput[]
    createMany?: ScheduleCreateManyAdInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type AdMetricsUncheckedCreateNestedManyWithoutAdInput = {
    create?: XOR<AdMetricsCreateWithoutAdInput, AdMetricsUncheckedCreateWithoutAdInput> | AdMetricsCreateWithoutAdInput[] | AdMetricsUncheckedCreateWithoutAdInput[]
    connectOrCreate?: AdMetricsCreateOrConnectWithoutAdInput | AdMetricsCreateOrConnectWithoutAdInput[]
    createMany?: AdMetricsCreateManyAdInputEnvelope
    connect?: AdMetricsWhereUniqueInput | AdMetricsWhereUniqueInput[]
  }

  export type ScheduleUncheckedCreateNestedManyWithoutAdInput = {
    create?: XOR<ScheduleCreateWithoutAdInput, ScheduleUncheckedCreateWithoutAdInput> | ScheduleCreateWithoutAdInput[] | ScheduleUncheckedCreateWithoutAdInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutAdInput | ScheduleCreateOrConnectWithoutAdInput[]
    createMany?: ScheduleCreateManyAdInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type EnumAdStatusFieldUpdateOperationsInput = {
    set?: $Enums.AdStatus
  }

  export type NullableEnumCreativeTypeFieldUpdateOperationsInput = {
    set?: $Enums.CreativeType | null
  }

  export type UserUpdateOneRequiredWithoutAdsNestedInput = {
    create?: XOR<UserCreateWithoutAdsInput, UserUncheckedCreateWithoutAdsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdsInput
    upsert?: UserUpsertWithoutAdsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdsInput, UserUpdateWithoutAdsInput>, UserUncheckedUpdateWithoutAdsInput>
  }

  export type AdSetUpdateOneRequiredWithoutAdsNestedInput = {
    create?: XOR<AdSetCreateWithoutAdsInput, AdSetUncheckedCreateWithoutAdsInput>
    connectOrCreate?: AdSetCreateOrConnectWithoutAdsInput
    upsert?: AdSetUpsertWithoutAdsInput
    connect?: AdSetWhereUniqueInput
    update?: XOR<XOR<AdSetUpdateToOneWithWhereWithoutAdsInput, AdSetUpdateWithoutAdsInput>, AdSetUncheckedUpdateWithoutAdsInput>
  }

  export type MetaAccountUpdateOneWithoutAdsNestedInput = {
    create?: XOR<MetaAccountCreateWithoutAdsInput, MetaAccountUncheckedCreateWithoutAdsInput>
    connectOrCreate?: MetaAccountCreateOrConnectWithoutAdsInput
    upsert?: MetaAccountUpsertWithoutAdsInput
    disconnect?: MetaAccountWhereInput | boolean
    delete?: MetaAccountWhereInput | boolean
    connect?: MetaAccountWhereUniqueInput
    update?: XOR<XOR<MetaAccountUpdateToOneWithWhereWithoutAdsInput, MetaAccountUpdateWithoutAdsInput>, MetaAccountUncheckedUpdateWithoutAdsInput>
  }

  export type AdMetricsUpdateManyWithoutAdNestedInput = {
    create?: XOR<AdMetricsCreateWithoutAdInput, AdMetricsUncheckedCreateWithoutAdInput> | AdMetricsCreateWithoutAdInput[] | AdMetricsUncheckedCreateWithoutAdInput[]
    connectOrCreate?: AdMetricsCreateOrConnectWithoutAdInput | AdMetricsCreateOrConnectWithoutAdInput[]
    upsert?: AdMetricsUpsertWithWhereUniqueWithoutAdInput | AdMetricsUpsertWithWhereUniqueWithoutAdInput[]
    createMany?: AdMetricsCreateManyAdInputEnvelope
    set?: AdMetricsWhereUniqueInput | AdMetricsWhereUniqueInput[]
    disconnect?: AdMetricsWhereUniqueInput | AdMetricsWhereUniqueInput[]
    delete?: AdMetricsWhereUniqueInput | AdMetricsWhereUniqueInput[]
    connect?: AdMetricsWhereUniqueInput | AdMetricsWhereUniqueInput[]
    update?: AdMetricsUpdateWithWhereUniqueWithoutAdInput | AdMetricsUpdateWithWhereUniqueWithoutAdInput[]
    updateMany?: AdMetricsUpdateManyWithWhereWithoutAdInput | AdMetricsUpdateManyWithWhereWithoutAdInput[]
    deleteMany?: AdMetricsScalarWhereInput | AdMetricsScalarWhereInput[]
  }

  export type ScheduleUpdateManyWithoutAdNestedInput = {
    create?: XOR<ScheduleCreateWithoutAdInput, ScheduleUncheckedCreateWithoutAdInput> | ScheduleCreateWithoutAdInput[] | ScheduleUncheckedCreateWithoutAdInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutAdInput | ScheduleCreateOrConnectWithoutAdInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutAdInput | ScheduleUpsertWithWhereUniqueWithoutAdInput[]
    createMany?: ScheduleCreateManyAdInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutAdInput | ScheduleUpdateWithWhereUniqueWithoutAdInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutAdInput | ScheduleUpdateManyWithWhereWithoutAdInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type AdMetricsUncheckedUpdateManyWithoutAdNestedInput = {
    create?: XOR<AdMetricsCreateWithoutAdInput, AdMetricsUncheckedCreateWithoutAdInput> | AdMetricsCreateWithoutAdInput[] | AdMetricsUncheckedCreateWithoutAdInput[]
    connectOrCreate?: AdMetricsCreateOrConnectWithoutAdInput | AdMetricsCreateOrConnectWithoutAdInput[]
    upsert?: AdMetricsUpsertWithWhereUniqueWithoutAdInput | AdMetricsUpsertWithWhereUniqueWithoutAdInput[]
    createMany?: AdMetricsCreateManyAdInputEnvelope
    set?: AdMetricsWhereUniqueInput | AdMetricsWhereUniqueInput[]
    disconnect?: AdMetricsWhereUniqueInput | AdMetricsWhereUniqueInput[]
    delete?: AdMetricsWhereUniqueInput | AdMetricsWhereUniqueInput[]
    connect?: AdMetricsWhereUniqueInput | AdMetricsWhereUniqueInput[]
    update?: AdMetricsUpdateWithWhereUniqueWithoutAdInput | AdMetricsUpdateWithWhereUniqueWithoutAdInput[]
    updateMany?: AdMetricsUpdateManyWithWhereWithoutAdInput | AdMetricsUpdateManyWithWhereWithoutAdInput[]
    deleteMany?: AdMetricsScalarWhereInput | AdMetricsScalarWhereInput[]
  }

  export type ScheduleUncheckedUpdateManyWithoutAdNestedInput = {
    create?: XOR<ScheduleCreateWithoutAdInput, ScheduleUncheckedCreateWithoutAdInput> | ScheduleCreateWithoutAdInput[] | ScheduleUncheckedCreateWithoutAdInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutAdInput | ScheduleCreateOrConnectWithoutAdInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutAdInput | ScheduleUpsertWithWhereUniqueWithoutAdInput[]
    createMany?: ScheduleCreateManyAdInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutAdInput | ScheduleUpdateWithWhereUniqueWithoutAdInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutAdInput | ScheduleUpdateManyWithWhereWithoutAdInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type AdCreateNestedOneWithoutMetricsInput = {
    create?: XOR<AdCreateWithoutMetricsInput, AdUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: AdCreateOrConnectWithoutMetricsInput
    connect?: AdWhereUniqueInput
  }

  export type AdUpdateOneRequiredWithoutMetricsNestedInput = {
    create?: XOR<AdCreateWithoutMetricsInput, AdUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: AdCreateOrConnectWithoutMetricsInput
    upsert?: AdUpsertWithoutMetricsInput
    connect?: AdWhereUniqueInput
    update?: XOR<XOR<AdUpdateToOneWithWhereWithoutMetricsInput, AdUpdateWithoutMetricsInput>, AdUncheckedUpdateWithoutMetricsInput>
  }

  export type UserCreateNestedOneWithoutSchedulesInput = {
    create?: XOR<UserCreateWithoutSchedulesInput, UserUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSchedulesInput
    connect?: UserWhereUniqueInput
  }

  export type AdCreateNestedOneWithoutSchedulesInput = {
    create?: XOR<AdCreateWithoutSchedulesInput, AdUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: AdCreateOrConnectWithoutSchedulesInput
    connect?: AdWhereUniqueInput
  }

  export type ClinicCreateNestedOneWithoutSchedulesInput = {
    create?: XOR<ClinicCreateWithoutSchedulesInput, ClinicUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutSchedulesInput
    connect?: ClinicWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutSchedulesInput = {
    create?: XOR<ProductCreateWithoutSchedulesInput, ProductUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSchedulesInput
    connect?: ProductWhereUniqueInput
  }

  export type EnumScheduleStatusFieldUpdateOperationsInput = {
    set?: $Enums.ScheduleStatus
  }

  export type EnumSchedulePriorityFieldUpdateOperationsInput = {
    set?: $Enums.SchedulePriority
  }

  export type NullableEnumScheduleCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ScheduleCategory | null
  }

  export type NullableEnumRecurrencePatternFieldUpdateOperationsInput = {
    set?: $Enums.RecurrencePattern | null
  }

  export type UserUpdateOneRequiredWithoutSchedulesNestedInput = {
    create?: XOR<UserCreateWithoutSchedulesInput, UserUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSchedulesInput
    upsert?: UserUpsertWithoutSchedulesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSchedulesInput, UserUpdateWithoutSchedulesInput>, UserUncheckedUpdateWithoutSchedulesInput>
  }

  export type AdUpdateOneWithoutSchedulesNestedInput = {
    create?: XOR<AdCreateWithoutSchedulesInput, AdUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: AdCreateOrConnectWithoutSchedulesInput
    upsert?: AdUpsertWithoutSchedulesInput
    disconnect?: AdWhereInput | boolean
    delete?: AdWhereInput | boolean
    connect?: AdWhereUniqueInput
    update?: XOR<XOR<AdUpdateToOneWithWhereWithoutSchedulesInput, AdUpdateWithoutSchedulesInput>, AdUncheckedUpdateWithoutSchedulesInput>
  }

  export type ClinicUpdateOneWithoutSchedulesNestedInput = {
    create?: XOR<ClinicCreateWithoutSchedulesInput, ClinicUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutSchedulesInput
    upsert?: ClinicUpsertWithoutSchedulesInput
    disconnect?: ClinicWhereInput | boolean
    delete?: ClinicWhereInput | boolean
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutSchedulesInput, ClinicUpdateWithoutSchedulesInput>, ClinicUncheckedUpdateWithoutSchedulesInput>
  }

  export type ProductUpdateOneWithoutSchedulesNestedInput = {
    create?: XOR<ProductCreateWithoutSchedulesInput, ProductUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSchedulesInput
    upsert?: ProductUpsertWithoutSchedulesInput
    disconnect?: ProductWhereInput | boolean
    delete?: ProductWhereInput | boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutSchedulesInput, ProductUpdateWithoutSchedulesInput>, ProductUncheckedUpdateWithoutSchedulesInput>
  }

  export type PlannerItemCreateNestedManyWithoutPlannerInput = {
    create?: XOR<PlannerItemCreateWithoutPlannerInput, PlannerItemUncheckedCreateWithoutPlannerInput> | PlannerItemCreateWithoutPlannerInput[] | PlannerItemUncheckedCreateWithoutPlannerInput[]
    connectOrCreate?: PlannerItemCreateOrConnectWithoutPlannerInput | PlannerItemCreateOrConnectWithoutPlannerInput[]
    createMany?: PlannerItemCreateManyPlannerInputEnvelope
    connect?: PlannerItemWhereUniqueInput | PlannerItemWhereUniqueInput[]
  }

  export type PlannerItemUncheckedCreateNestedManyWithoutPlannerInput = {
    create?: XOR<PlannerItemCreateWithoutPlannerInput, PlannerItemUncheckedCreateWithoutPlannerInput> | PlannerItemCreateWithoutPlannerInput[] | PlannerItemUncheckedCreateWithoutPlannerInput[]
    connectOrCreate?: PlannerItemCreateOrConnectWithoutPlannerInput | PlannerItemCreateOrConnectWithoutPlannerInput[]
    createMany?: PlannerItemCreateManyPlannerInputEnvelope
    connect?: PlannerItemWhereUniqueInput | PlannerItemWhereUniqueInput[]
  }

  export type EnumCampaignObjectiveFieldUpdateOperationsInput = {
    set?: $Enums.CampaignObjective
  }

  export type EnumBudgetTypeFieldUpdateOperationsInput = {
    set?: $Enums.BudgetType
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumGenderTargetFieldUpdateOperationsInput = {
    set?: $Enums.GenderTarget | null
  }

  export type PlannerItemUpdateManyWithoutPlannerNestedInput = {
    create?: XOR<PlannerItemCreateWithoutPlannerInput, PlannerItemUncheckedCreateWithoutPlannerInput> | PlannerItemCreateWithoutPlannerInput[] | PlannerItemUncheckedCreateWithoutPlannerInput[]
    connectOrCreate?: PlannerItemCreateOrConnectWithoutPlannerInput | PlannerItemCreateOrConnectWithoutPlannerInput[]
    upsert?: PlannerItemUpsertWithWhereUniqueWithoutPlannerInput | PlannerItemUpsertWithWhereUniqueWithoutPlannerInput[]
    createMany?: PlannerItemCreateManyPlannerInputEnvelope
    set?: PlannerItemWhereUniqueInput | PlannerItemWhereUniqueInput[]
    disconnect?: PlannerItemWhereUniqueInput | PlannerItemWhereUniqueInput[]
    delete?: PlannerItemWhereUniqueInput | PlannerItemWhereUniqueInput[]
    connect?: PlannerItemWhereUniqueInput | PlannerItemWhereUniqueInput[]
    update?: PlannerItemUpdateWithWhereUniqueWithoutPlannerInput | PlannerItemUpdateWithWhereUniqueWithoutPlannerInput[]
    updateMany?: PlannerItemUpdateManyWithWhereWithoutPlannerInput | PlannerItemUpdateManyWithWhereWithoutPlannerInput[]
    deleteMany?: PlannerItemScalarWhereInput | PlannerItemScalarWhereInput[]
  }

  export type PlannerItemUncheckedUpdateManyWithoutPlannerNestedInput = {
    create?: XOR<PlannerItemCreateWithoutPlannerInput, PlannerItemUncheckedCreateWithoutPlannerInput> | PlannerItemCreateWithoutPlannerInput[] | PlannerItemUncheckedCreateWithoutPlannerInput[]
    connectOrCreate?: PlannerItemCreateOrConnectWithoutPlannerInput | PlannerItemCreateOrConnectWithoutPlannerInput[]
    upsert?: PlannerItemUpsertWithWhereUniqueWithoutPlannerInput | PlannerItemUpsertWithWhereUniqueWithoutPlannerInput[]
    createMany?: PlannerItemCreateManyPlannerInputEnvelope
    set?: PlannerItemWhereUniqueInput | PlannerItemWhereUniqueInput[]
    disconnect?: PlannerItemWhereUniqueInput | PlannerItemWhereUniqueInput[]
    delete?: PlannerItemWhereUniqueInput | PlannerItemWhereUniqueInput[]
    connect?: PlannerItemWhereUniqueInput | PlannerItemWhereUniqueInput[]
    update?: PlannerItemUpdateWithWhereUniqueWithoutPlannerInput | PlannerItemUpdateWithWhereUniqueWithoutPlannerInput[]
    updateMany?: PlannerItemUpdateManyWithWhereWithoutPlannerInput | PlannerItemUpdateManyWithWhereWithoutPlannerInput[]
    deleteMany?: PlannerItemScalarWhereInput | PlannerItemScalarWhereInput[]
  }

  export type AdsPlannerCreateNestedOneWithoutPlanItemsInput = {
    create?: XOR<AdsPlannerCreateWithoutPlanItemsInput, AdsPlannerUncheckedCreateWithoutPlanItemsInput>
    connectOrCreate?: AdsPlannerCreateOrConnectWithoutPlanItemsInput
    connect?: AdsPlannerWhereUniqueInput
  }

  export type EnumPlatformTypeFieldUpdateOperationsInput = {
    set?: $Enums.PlatformType
  }

  export type EnumPlannerItemStatusFieldUpdateOperationsInput = {
    set?: $Enums.PlannerItemStatus
  }

  export type AdsPlannerUpdateOneRequiredWithoutPlanItemsNestedInput = {
    create?: XOR<AdsPlannerCreateWithoutPlanItemsInput, AdsPlannerUncheckedCreateWithoutPlanItemsInput>
    connectOrCreate?: AdsPlannerCreateOrConnectWithoutPlanItemsInput
    upsert?: AdsPlannerUpsertWithoutPlanItemsInput
    connect?: AdsPlannerWhereUniqueInput
    update?: XOR<XOR<AdsPlannerUpdateToOneWithWhereWithoutPlanItemsInput, AdsPlannerUpdateWithoutPlanItemsInput>, AdsPlannerUncheckedUpdateWithoutPlanItemsInput>
  }

  export type UserCreateNestedOneWithoutSocialAccountsInput = {
    create?: XOR<UserCreateWithoutSocialAccountsInput, UserUncheckedCreateWithoutSocialAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSocialAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type PlatformMetricsCreateNestedManyWithoutAccountInput = {
    create?: XOR<PlatformMetricsCreateWithoutAccountInput, PlatformMetricsUncheckedCreateWithoutAccountInput> | PlatformMetricsCreateWithoutAccountInput[] | PlatformMetricsUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PlatformMetricsCreateOrConnectWithoutAccountInput | PlatformMetricsCreateOrConnectWithoutAccountInput[]
    createMany?: PlatformMetricsCreateManyAccountInputEnvelope
    connect?: PlatformMetricsWhereUniqueInput | PlatformMetricsWhereUniqueInput[]
  }

  export type EngagementMetricsCreateNestedManyWithoutAccountInput = {
    create?: XOR<EngagementMetricsCreateWithoutAccountInput, EngagementMetricsUncheckedCreateWithoutAccountInput> | EngagementMetricsCreateWithoutAccountInput[] | EngagementMetricsUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: EngagementMetricsCreateOrConnectWithoutAccountInput | EngagementMetricsCreateOrConnectWithoutAccountInput[]
    createMany?: EngagementMetricsCreateManyAccountInputEnvelope
    connect?: EngagementMetricsWhereUniqueInput | EngagementMetricsWhereUniqueInput[]
  }

  export type InfluencerCreateNestedManyWithoutAccountInput = {
    create?: XOR<InfluencerCreateWithoutAccountInput, InfluencerUncheckedCreateWithoutAccountInput> | InfluencerCreateWithoutAccountInput[] | InfluencerUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: InfluencerCreateOrConnectWithoutAccountInput | InfluencerCreateOrConnectWithoutAccountInput[]
    createMany?: InfluencerCreateManyAccountInputEnvelope
    connect?: InfluencerWhereUniqueInput | InfluencerWhereUniqueInput[]
  }

  export type PlatformMetricsUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<PlatformMetricsCreateWithoutAccountInput, PlatformMetricsUncheckedCreateWithoutAccountInput> | PlatformMetricsCreateWithoutAccountInput[] | PlatformMetricsUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PlatformMetricsCreateOrConnectWithoutAccountInput | PlatformMetricsCreateOrConnectWithoutAccountInput[]
    createMany?: PlatformMetricsCreateManyAccountInputEnvelope
    connect?: PlatformMetricsWhereUniqueInput | PlatformMetricsWhereUniqueInput[]
  }

  export type EngagementMetricsUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<EngagementMetricsCreateWithoutAccountInput, EngagementMetricsUncheckedCreateWithoutAccountInput> | EngagementMetricsCreateWithoutAccountInput[] | EngagementMetricsUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: EngagementMetricsCreateOrConnectWithoutAccountInput | EngagementMetricsCreateOrConnectWithoutAccountInput[]
    createMany?: EngagementMetricsCreateManyAccountInputEnvelope
    connect?: EngagementMetricsWhereUniqueInput | EngagementMetricsWhereUniqueInput[]
  }

  export type InfluencerUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<InfluencerCreateWithoutAccountInput, InfluencerUncheckedCreateWithoutAccountInput> | InfluencerCreateWithoutAccountInput[] | InfluencerUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: InfluencerCreateOrConnectWithoutAccountInput | InfluencerCreateOrConnectWithoutAccountInput[]
    createMany?: InfluencerCreateManyAccountInputEnvelope
    connect?: InfluencerWhereUniqueInput | InfluencerWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutSocialAccountsNestedInput = {
    create?: XOR<UserCreateWithoutSocialAccountsInput, UserUncheckedCreateWithoutSocialAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSocialAccountsInput
    upsert?: UserUpsertWithoutSocialAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSocialAccountsInput, UserUpdateWithoutSocialAccountsInput>, UserUncheckedUpdateWithoutSocialAccountsInput>
  }

  export type PlatformMetricsUpdateManyWithoutAccountNestedInput = {
    create?: XOR<PlatformMetricsCreateWithoutAccountInput, PlatformMetricsUncheckedCreateWithoutAccountInput> | PlatformMetricsCreateWithoutAccountInput[] | PlatformMetricsUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PlatformMetricsCreateOrConnectWithoutAccountInput | PlatformMetricsCreateOrConnectWithoutAccountInput[]
    upsert?: PlatformMetricsUpsertWithWhereUniqueWithoutAccountInput | PlatformMetricsUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: PlatformMetricsCreateManyAccountInputEnvelope
    set?: PlatformMetricsWhereUniqueInput | PlatformMetricsWhereUniqueInput[]
    disconnect?: PlatformMetricsWhereUniqueInput | PlatformMetricsWhereUniqueInput[]
    delete?: PlatformMetricsWhereUniqueInput | PlatformMetricsWhereUniqueInput[]
    connect?: PlatformMetricsWhereUniqueInput | PlatformMetricsWhereUniqueInput[]
    update?: PlatformMetricsUpdateWithWhereUniqueWithoutAccountInput | PlatformMetricsUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: PlatformMetricsUpdateManyWithWhereWithoutAccountInput | PlatformMetricsUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: PlatformMetricsScalarWhereInput | PlatformMetricsScalarWhereInput[]
  }

  export type EngagementMetricsUpdateManyWithoutAccountNestedInput = {
    create?: XOR<EngagementMetricsCreateWithoutAccountInput, EngagementMetricsUncheckedCreateWithoutAccountInput> | EngagementMetricsCreateWithoutAccountInput[] | EngagementMetricsUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: EngagementMetricsCreateOrConnectWithoutAccountInput | EngagementMetricsCreateOrConnectWithoutAccountInput[]
    upsert?: EngagementMetricsUpsertWithWhereUniqueWithoutAccountInput | EngagementMetricsUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: EngagementMetricsCreateManyAccountInputEnvelope
    set?: EngagementMetricsWhereUniqueInput | EngagementMetricsWhereUniqueInput[]
    disconnect?: EngagementMetricsWhereUniqueInput | EngagementMetricsWhereUniqueInput[]
    delete?: EngagementMetricsWhereUniqueInput | EngagementMetricsWhereUniqueInput[]
    connect?: EngagementMetricsWhereUniqueInput | EngagementMetricsWhereUniqueInput[]
    update?: EngagementMetricsUpdateWithWhereUniqueWithoutAccountInput | EngagementMetricsUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: EngagementMetricsUpdateManyWithWhereWithoutAccountInput | EngagementMetricsUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: EngagementMetricsScalarWhereInput | EngagementMetricsScalarWhereInput[]
  }

  export type InfluencerUpdateManyWithoutAccountNestedInput = {
    create?: XOR<InfluencerCreateWithoutAccountInput, InfluencerUncheckedCreateWithoutAccountInput> | InfluencerCreateWithoutAccountInput[] | InfluencerUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: InfluencerCreateOrConnectWithoutAccountInput | InfluencerCreateOrConnectWithoutAccountInput[]
    upsert?: InfluencerUpsertWithWhereUniqueWithoutAccountInput | InfluencerUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: InfluencerCreateManyAccountInputEnvelope
    set?: InfluencerWhereUniqueInput | InfluencerWhereUniqueInput[]
    disconnect?: InfluencerWhereUniqueInput | InfluencerWhereUniqueInput[]
    delete?: InfluencerWhereUniqueInput | InfluencerWhereUniqueInput[]
    connect?: InfluencerWhereUniqueInput | InfluencerWhereUniqueInput[]
    update?: InfluencerUpdateWithWhereUniqueWithoutAccountInput | InfluencerUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: InfluencerUpdateManyWithWhereWithoutAccountInput | InfluencerUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: InfluencerScalarWhereInput | InfluencerScalarWhereInput[]
  }

  export type PlatformMetricsUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<PlatformMetricsCreateWithoutAccountInput, PlatformMetricsUncheckedCreateWithoutAccountInput> | PlatformMetricsCreateWithoutAccountInput[] | PlatformMetricsUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PlatformMetricsCreateOrConnectWithoutAccountInput | PlatformMetricsCreateOrConnectWithoutAccountInput[]
    upsert?: PlatformMetricsUpsertWithWhereUniqueWithoutAccountInput | PlatformMetricsUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: PlatformMetricsCreateManyAccountInputEnvelope
    set?: PlatformMetricsWhereUniqueInput | PlatformMetricsWhereUniqueInput[]
    disconnect?: PlatformMetricsWhereUniqueInput | PlatformMetricsWhereUniqueInput[]
    delete?: PlatformMetricsWhereUniqueInput | PlatformMetricsWhereUniqueInput[]
    connect?: PlatformMetricsWhereUniqueInput | PlatformMetricsWhereUniqueInput[]
    update?: PlatformMetricsUpdateWithWhereUniqueWithoutAccountInput | PlatformMetricsUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: PlatformMetricsUpdateManyWithWhereWithoutAccountInput | PlatformMetricsUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: PlatformMetricsScalarWhereInput | PlatformMetricsScalarWhereInput[]
  }

  export type EngagementMetricsUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<EngagementMetricsCreateWithoutAccountInput, EngagementMetricsUncheckedCreateWithoutAccountInput> | EngagementMetricsCreateWithoutAccountInput[] | EngagementMetricsUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: EngagementMetricsCreateOrConnectWithoutAccountInput | EngagementMetricsCreateOrConnectWithoutAccountInput[]
    upsert?: EngagementMetricsUpsertWithWhereUniqueWithoutAccountInput | EngagementMetricsUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: EngagementMetricsCreateManyAccountInputEnvelope
    set?: EngagementMetricsWhereUniqueInput | EngagementMetricsWhereUniqueInput[]
    disconnect?: EngagementMetricsWhereUniqueInput | EngagementMetricsWhereUniqueInput[]
    delete?: EngagementMetricsWhereUniqueInput | EngagementMetricsWhereUniqueInput[]
    connect?: EngagementMetricsWhereUniqueInput | EngagementMetricsWhereUniqueInput[]
    update?: EngagementMetricsUpdateWithWhereUniqueWithoutAccountInput | EngagementMetricsUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: EngagementMetricsUpdateManyWithWhereWithoutAccountInput | EngagementMetricsUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: EngagementMetricsScalarWhereInput | EngagementMetricsScalarWhereInput[]
  }

  export type InfluencerUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<InfluencerCreateWithoutAccountInput, InfluencerUncheckedCreateWithoutAccountInput> | InfluencerCreateWithoutAccountInput[] | InfluencerUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: InfluencerCreateOrConnectWithoutAccountInput | InfluencerCreateOrConnectWithoutAccountInput[]
    upsert?: InfluencerUpsertWithWhereUniqueWithoutAccountInput | InfluencerUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: InfluencerCreateManyAccountInputEnvelope
    set?: InfluencerWhereUniqueInput | InfluencerWhereUniqueInput[]
    disconnect?: InfluencerWhereUniqueInput | InfluencerWhereUniqueInput[]
    delete?: InfluencerWhereUniqueInput | InfluencerWhereUniqueInput[]
    connect?: InfluencerWhereUniqueInput | InfluencerWhereUniqueInput[]
    update?: InfluencerUpdateWithWhereUniqueWithoutAccountInput | InfluencerUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: InfluencerUpdateManyWithWhereWithoutAccountInput | InfluencerUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: InfluencerScalarWhereInput | InfluencerScalarWhereInput[]
  }

  export type SocialMediaAccountCreateNestedOneWithoutPlatformMetricsInput = {
    create?: XOR<SocialMediaAccountCreateWithoutPlatformMetricsInput, SocialMediaAccountUncheckedCreateWithoutPlatformMetricsInput>
    connectOrCreate?: SocialMediaAccountCreateOrConnectWithoutPlatformMetricsInput
    connect?: SocialMediaAccountWhereUniqueInput
  }

  export type SocialMediaAccountUpdateOneRequiredWithoutPlatformMetricsNestedInput = {
    create?: XOR<SocialMediaAccountCreateWithoutPlatformMetricsInput, SocialMediaAccountUncheckedCreateWithoutPlatformMetricsInput>
    connectOrCreate?: SocialMediaAccountCreateOrConnectWithoutPlatformMetricsInput
    upsert?: SocialMediaAccountUpsertWithoutPlatformMetricsInput
    connect?: SocialMediaAccountWhereUniqueInput
    update?: XOR<XOR<SocialMediaAccountUpdateToOneWithWhereWithoutPlatformMetricsInput, SocialMediaAccountUpdateWithoutPlatformMetricsInput>, SocialMediaAccountUncheckedUpdateWithoutPlatformMetricsInput>
  }

  export type SocialMediaAccountCreateNestedOneWithoutEngagementMetricsInput = {
    create?: XOR<SocialMediaAccountCreateWithoutEngagementMetricsInput, SocialMediaAccountUncheckedCreateWithoutEngagementMetricsInput>
    connectOrCreate?: SocialMediaAccountCreateOrConnectWithoutEngagementMetricsInput
    connect?: SocialMediaAccountWhereUniqueInput
  }

  export type SocialMediaAccountUpdateOneRequiredWithoutEngagementMetricsNestedInput = {
    create?: XOR<SocialMediaAccountCreateWithoutEngagementMetricsInput, SocialMediaAccountUncheckedCreateWithoutEngagementMetricsInput>
    connectOrCreate?: SocialMediaAccountCreateOrConnectWithoutEngagementMetricsInput
    upsert?: SocialMediaAccountUpsertWithoutEngagementMetricsInput
    connect?: SocialMediaAccountWhereUniqueInput
    update?: XOR<XOR<SocialMediaAccountUpdateToOneWithWhereWithoutEngagementMetricsInput, SocialMediaAccountUpdateWithoutEngagementMetricsInput>, SocialMediaAccountUncheckedUpdateWithoutEngagementMetricsInput>
  }

  export type UserCreateNestedOneWithoutInfluencersInput = {
    create?: XOR<UserCreateWithoutInfluencersInput, UserUncheckedCreateWithoutInfluencersInput>
    connectOrCreate?: UserCreateOrConnectWithoutInfluencersInput
    connect?: UserWhereUniqueInput
  }

  export type SocialMediaAccountCreateNestedOneWithoutInfluencersInput = {
    create?: XOR<SocialMediaAccountCreateWithoutInfluencersInput, SocialMediaAccountUncheckedCreateWithoutInfluencersInput>
    connectOrCreate?: SocialMediaAccountCreateOrConnectWithoutInfluencersInput
    connect?: SocialMediaAccountWhereUniqueInput
  }

  export type InfluencerCampaignsCreateNestedManyWithoutInfluencerInput = {
    create?: XOR<InfluencerCampaignsCreateWithoutInfluencerInput, InfluencerCampaignsUncheckedCreateWithoutInfluencerInput> | InfluencerCampaignsCreateWithoutInfluencerInput[] | InfluencerCampaignsUncheckedCreateWithoutInfluencerInput[]
    connectOrCreate?: InfluencerCampaignsCreateOrConnectWithoutInfluencerInput | InfluencerCampaignsCreateOrConnectWithoutInfluencerInput[]
    createMany?: InfluencerCampaignsCreateManyInfluencerInputEnvelope
    connect?: InfluencerCampaignsWhereUniqueInput | InfluencerCampaignsWhereUniqueInput[]
  }

  export type InfluencerCampaignsUncheckedCreateNestedManyWithoutInfluencerInput = {
    create?: XOR<InfluencerCampaignsCreateWithoutInfluencerInput, InfluencerCampaignsUncheckedCreateWithoutInfluencerInput> | InfluencerCampaignsCreateWithoutInfluencerInput[] | InfluencerCampaignsUncheckedCreateWithoutInfluencerInput[]
    connectOrCreate?: InfluencerCampaignsCreateOrConnectWithoutInfluencerInput | InfluencerCampaignsCreateOrConnectWithoutInfluencerInput[]
    createMany?: InfluencerCampaignsCreateManyInfluencerInputEnvelope
    connect?: InfluencerCampaignsWhereUniqueInput | InfluencerCampaignsWhereUniqueInput[]
  }

  export type EnumInfluencerStatusFieldUpdateOperationsInput = {
    set?: $Enums.InfluencerStatus
  }

  export type UserUpdateOneRequiredWithoutInfluencersNestedInput = {
    create?: XOR<UserCreateWithoutInfluencersInput, UserUncheckedCreateWithoutInfluencersInput>
    connectOrCreate?: UserCreateOrConnectWithoutInfluencersInput
    upsert?: UserUpsertWithoutInfluencersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInfluencersInput, UserUpdateWithoutInfluencersInput>, UserUncheckedUpdateWithoutInfluencersInput>
  }

  export type SocialMediaAccountUpdateOneRequiredWithoutInfluencersNestedInput = {
    create?: XOR<SocialMediaAccountCreateWithoutInfluencersInput, SocialMediaAccountUncheckedCreateWithoutInfluencersInput>
    connectOrCreate?: SocialMediaAccountCreateOrConnectWithoutInfluencersInput
    upsert?: SocialMediaAccountUpsertWithoutInfluencersInput
    connect?: SocialMediaAccountWhereUniqueInput
    update?: XOR<XOR<SocialMediaAccountUpdateToOneWithWhereWithoutInfluencersInput, SocialMediaAccountUpdateWithoutInfluencersInput>, SocialMediaAccountUncheckedUpdateWithoutInfluencersInput>
  }

  export type InfluencerCampaignsUpdateManyWithoutInfluencerNestedInput = {
    create?: XOR<InfluencerCampaignsCreateWithoutInfluencerInput, InfluencerCampaignsUncheckedCreateWithoutInfluencerInput> | InfluencerCampaignsCreateWithoutInfluencerInput[] | InfluencerCampaignsUncheckedCreateWithoutInfluencerInput[]
    connectOrCreate?: InfluencerCampaignsCreateOrConnectWithoutInfluencerInput | InfluencerCampaignsCreateOrConnectWithoutInfluencerInput[]
    upsert?: InfluencerCampaignsUpsertWithWhereUniqueWithoutInfluencerInput | InfluencerCampaignsUpsertWithWhereUniqueWithoutInfluencerInput[]
    createMany?: InfluencerCampaignsCreateManyInfluencerInputEnvelope
    set?: InfluencerCampaignsWhereUniqueInput | InfluencerCampaignsWhereUniqueInput[]
    disconnect?: InfluencerCampaignsWhereUniqueInput | InfluencerCampaignsWhereUniqueInput[]
    delete?: InfluencerCampaignsWhereUniqueInput | InfluencerCampaignsWhereUniqueInput[]
    connect?: InfluencerCampaignsWhereUniqueInput | InfluencerCampaignsWhereUniqueInput[]
    update?: InfluencerCampaignsUpdateWithWhereUniqueWithoutInfluencerInput | InfluencerCampaignsUpdateWithWhereUniqueWithoutInfluencerInput[]
    updateMany?: InfluencerCampaignsUpdateManyWithWhereWithoutInfluencerInput | InfluencerCampaignsUpdateManyWithWhereWithoutInfluencerInput[]
    deleteMany?: InfluencerCampaignsScalarWhereInput | InfluencerCampaignsScalarWhereInput[]
  }

  export type InfluencerCampaignsUncheckedUpdateManyWithoutInfluencerNestedInput = {
    create?: XOR<InfluencerCampaignsCreateWithoutInfluencerInput, InfluencerCampaignsUncheckedCreateWithoutInfluencerInput> | InfluencerCampaignsCreateWithoutInfluencerInput[] | InfluencerCampaignsUncheckedCreateWithoutInfluencerInput[]
    connectOrCreate?: InfluencerCampaignsCreateOrConnectWithoutInfluencerInput | InfluencerCampaignsCreateOrConnectWithoutInfluencerInput[]
    upsert?: InfluencerCampaignsUpsertWithWhereUniqueWithoutInfluencerInput | InfluencerCampaignsUpsertWithWhereUniqueWithoutInfluencerInput[]
    createMany?: InfluencerCampaignsCreateManyInfluencerInputEnvelope
    set?: InfluencerCampaignsWhereUniqueInput | InfluencerCampaignsWhereUniqueInput[]
    disconnect?: InfluencerCampaignsWhereUniqueInput | InfluencerCampaignsWhereUniqueInput[]
    delete?: InfluencerCampaignsWhereUniqueInput | InfluencerCampaignsWhereUniqueInput[]
    connect?: InfluencerCampaignsWhereUniqueInput | InfluencerCampaignsWhereUniqueInput[]
    update?: InfluencerCampaignsUpdateWithWhereUniqueWithoutInfluencerInput | InfluencerCampaignsUpdateWithWhereUniqueWithoutInfluencerInput[]
    updateMany?: InfluencerCampaignsUpdateManyWithWhereWithoutInfluencerInput | InfluencerCampaignsUpdateManyWithWhereWithoutInfluencerInput[]
    deleteMany?: InfluencerCampaignsScalarWhereInput | InfluencerCampaignsScalarWhereInput[]
  }

  export type InfluencerCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<InfluencerCreateWithoutCampaignsInput, InfluencerUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: InfluencerCreateOrConnectWithoutCampaignsInput
    connect?: InfluencerWhereUniqueInput
  }

  export type EnumInfluencerCampaignStatusFieldUpdateOperationsInput = {
    set?: $Enums.InfluencerCampaignStatus
  }

  export type InfluencerUpdateOneRequiredWithoutCampaignsNestedInput = {
    create?: XOR<InfluencerCreateWithoutCampaignsInput, InfluencerUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: InfluencerCreateOrConnectWithoutCampaignsInput
    upsert?: InfluencerUpsertWithoutCampaignsInput
    connect?: InfluencerWhereUniqueInput
    update?: XOR<XOR<InfluencerUpdateToOneWithWhereWithoutCampaignsInput, InfluencerUpdateWithoutCampaignsInput>, InfluencerUncheckedUpdateWithoutCampaignsInput>
  }

  export type UserCreateNestedOneWithoutClinicsInput = {
    create?: XOR<UserCreateWithoutClinicsInput, UserUncheckedCreateWithoutClinicsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClinicsInput
    connect?: UserWhereUniqueInput
  }

  export type ScheduleCreateNestedManyWithoutClinicInput = {
    create?: XOR<ScheduleCreateWithoutClinicInput, ScheduleUncheckedCreateWithoutClinicInput> | ScheduleCreateWithoutClinicInput[] | ScheduleUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutClinicInput | ScheduleCreateOrConnectWithoutClinicInput[]
    createMany?: ScheduleCreateManyClinicInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type CampaignCreateNestedManyWithoutClinicInput = {
    create?: XOR<CampaignCreateWithoutClinicInput, CampaignUncheckedCreateWithoutClinicInput> | CampaignCreateWithoutClinicInput[] | CampaignUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutClinicInput | CampaignCreateOrConnectWithoutClinicInput[]
    createMany?: CampaignCreateManyClinicInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type ScheduleUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<ScheduleCreateWithoutClinicInput, ScheduleUncheckedCreateWithoutClinicInput> | ScheduleCreateWithoutClinicInput[] | ScheduleUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutClinicInput | ScheduleCreateOrConnectWithoutClinicInput[]
    createMany?: ScheduleCreateManyClinicInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<CampaignCreateWithoutClinicInput, CampaignUncheckedCreateWithoutClinicInput> | CampaignCreateWithoutClinicInput[] | CampaignUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutClinicInput | CampaignCreateOrConnectWithoutClinicInput[]
    createMany?: CampaignCreateManyClinicInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutClinicsNestedInput = {
    create?: XOR<UserCreateWithoutClinicsInput, UserUncheckedCreateWithoutClinicsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClinicsInput
    upsert?: UserUpsertWithoutClinicsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClinicsInput, UserUpdateWithoutClinicsInput>, UserUncheckedUpdateWithoutClinicsInput>
  }

  export type ScheduleUpdateManyWithoutClinicNestedInput = {
    create?: XOR<ScheduleCreateWithoutClinicInput, ScheduleUncheckedCreateWithoutClinicInput> | ScheduleCreateWithoutClinicInput[] | ScheduleUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutClinicInput | ScheduleCreateOrConnectWithoutClinicInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutClinicInput | ScheduleUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: ScheduleCreateManyClinicInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutClinicInput | ScheduleUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutClinicInput | ScheduleUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type CampaignUpdateManyWithoutClinicNestedInput = {
    create?: XOR<CampaignCreateWithoutClinicInput, CampaignUncheckedCreateWithoutClinicInput> | CampaignCreateWithoutClinicInput[] | CampaignUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutClinicInput | CampaignCreateOrConnectWithoutClinicInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutClinicInput | CampaignUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: CampaignCreateManyClinicInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutClinicInput | CampaignUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutClinicInput | CampaignUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type ScheduleUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<ScheduleCreateWithoutClinicInput, ScheduleUncheckedCreateWithoutClinicInput> | ScheduleCreateWithoutClinicInput[] | ScheduleUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutClinicInput | ScheduleCreateOrConnectWithoutClinicInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutClinicInput | ScheduleUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: ScheduleCreateManyClinicInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutClinicInput | ScheduleUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutClinicInput | ScheduleUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<CampaignCreateWithoutClinicInput, CampaignUncheckedCreateWithoutClinicInput> | CampaignCreateWithoutClinicInput[] | CampaignUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutClinicInput | CampaignCreateOrConnectWithoutClinicInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutClinicInput | CampaignUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: CampaignCreateManyClinicInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutClinicInput | CampaignUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutClinicInput | CampaignUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutProductsInput = {
    create?: XOR<UserCreateWithoutProductsInput, UserUncheckedCreateWithoutProductsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductsInput
    connect?: UserWhereUniqueInput
  }

  export type ScheduleCreateNestedManyWithoutProductInput = {
    create?: XOR<ScheduleCreateWithoutProductInput, ScheduleUncheckedCreateWithoutProductInput> | ScheduleCreateWithoutProductInput[] | ScheduleUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutProductInput | ScheduleCreateOrConnectWithoutProductInput[]
    createMany?: ScheduleCreateManyProductInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type CampaignCreateNestedManyWithoutProductInput = {
    create?: XOR<CampaignCreateWithoutProductInput, CampaignUncheckedCreateWithoutProductInput> | CampaignCreateWithoutProductInput[] | CampaignUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutProductInput | CampaignCreateOrConnectWithoutProductInput[]
    createMany?: CampaignCreateManyProductInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type ScheduleUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ScheduleCreateWithoutProductInput, ScheduleUncheckedCreateWithoutProductInput> | ScheduleCreateWithoutProductInput[] | ScheduleUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutProductInput | ScheduleCreateOrConnectWithoutProductInput[]
    createMany?: ScheduleCreateManyProductInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type CampaignUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<CampaignCreateWithoutProductInput, CampaignUncheckedCreateWithoutProductInput> | CampaignCreateWithoutProductInput[] | CampaignUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutProductInput | CampaignCreateOrConnectWithoutProductInput[]
    createMany?: CampaignCreateManyProductInputEnvelope
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<UserCreateWithoutProductsInput, UserUncheckedCreateWithoutProductsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductsInput
    upsert?: UserUpsertWithoutProductsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProductsInput, UserUpdateWithoutProductsInput>, UserUncheckedUpdateWithoutProductsInput>
  }

  export type ScheduleUpdateManyWithoutProductNestedInput = {
    create?: XOR<ScheduleCreateWithoutProductInput, ScheduleUncheckedCreateWithoutProductInput> | ScheduleCreateWithoutProductInput[] | ScheduleUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutProductInput | ScheduleCreateOrConnectWithoutProductInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutProductInput | ScheduleUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ScheduleCreateManyProductInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutProductInput | ScheduleUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutProductInput | ScheduleUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type CampaignUpdateManyWithoutProductNestedInput = {
    create?: XOR<CampaignCreateWithoutProductInput, CampaignUncheckedCreateWithoutProductInput> | CampaignCreateWithoutProductInput[] | CampaignUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutProductInput | CampaignCreateOrConnectWithoutProductInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutProductInput | CampaignUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CampaignCreateManyProductInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutProductInput | CampaignUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutProductInput | CampaignUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type ScheduleUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ScheduleCreateWithoutProductInput, ScheduleUncheckedCreateWithoutProductInput> | ScheduleCreateWithoutProductInput[] | ScheduleUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutProductInput | ScheduleCreateOrConnectWithoutProductInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutProductInput | ScheduleUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ScheduleCreateManyProductInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutProductInput | ScheduleUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutProductInput | ScheduleUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type CampaignUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<CampaignCreateWithoutProductInput, CampaignUncheckedCreateWithoutProductInput> | CampaignCreateWithoutProductInput[] | CampaignUncheckedCreateWithoutProductInput[]
    connectOrCreate?: CampaignCreateOrConnectWithoutProductInput | CampaignCreateOrConnectWithoutProductInput[]
    upsert?: CampaignUpsertWithWhereUniqueWithoutProductInput | CampaignUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: CampaignCreateManyProductInputEnvelope
    set?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    disconnect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    delete?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    connect?: CampaignWhereUniqueInput | CampaignWhereUniqueInput[]
    update?: CampaignUpdateWithWhereUniqueWithoutProductInput | CampaignUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: CampaignUpdateManyWithWhereWithoutProductInput | CampaignUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
  }

  export type EnumIncomeCategoryFieldUpdateOperationsInput = {
    set?: $Enums.IncomeCategory
  }

  export type UserCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type InvoiceCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type UserUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    upsert?: UserUpsertWithoutPaymentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentsInput, UserUpdateWithoutPaymentsInput>, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    upsert?: InvoiceUpsertWithoutPaymentsInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutPaymentsInput, InvoiceUpdateWithoutPaymentsInput>, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesInput
    connect?: UserWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type EnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceStatus
  }

  export type UserUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesInput
    upsert?: UserUpsertWithoutInvoicesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvoicesInput, UserUpdateWithoutInvoicesInput>, UserUncheckedUpdateWithoutInvoicesInput>
  }

  export type PaymentUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type TagsOnCampaignsCreateNestedManyWithoutTagInput = {
    create?: XOR<TagsOnCampaignsCreateWithoutTagInput, TagsOnCampaignsUncheckedCreateWithoutTagInput> | TagsOnCampaignsCreateWithoutTagInput[] | TagsOnCampaignsUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TagsOnCampaignsCreateOrConnectWithoutTagInput | TagsOnCampaignsCreateOrConnectWithoutTagInput[]
    createMany?: TagsOnCampaignsCreateManyTagInputEnvelope
    connect?: TagsOnCampaignsWhereUniqueInput | TagsOnCampaignsWhereUniqueInput[]
  }

  export type TagsOnCampaignsUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<TagsOnCampaignsCreateWithoutTagInput, TagsOnCampaignsUncheckedCreateWithoutTagInput> | TagsOnCampaignsCreateWithoutTagInput[] | TagsOnCampaignsUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TagsOnCampaignsCreateOrConnectWithoutTagInput | TagsOnCampaignsCreateOrConnectWithoutTagInput[]
    createMany?: TagsOnCampaignsCreateManyTagInputEnvelope
    connect?: TagsOnCampaignsWhereUniqueInput | TagsOnCampaignsWhereUniqueInput[]
  }

  export type TagsOnCampaignsUpdateManyWithoutTagNestedInput = {
    create?: XOR<TagsOnCampaignsCreateWithoutTagInput, TagsOnCampaignsUncheckedCreateWithoutTagInput> | TagsOnCampaignsCreateWithoutTagInput[] | TagsOnCampaignsUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TagsOnCampaignsCreateOrConnectWithoutTagInput | TagsOnCampaignsCreateOrConnectWithoutTagInput[]
    upsert?: TagsOnCampaignsUpsertWithWhereUniqueWithoutTagInput | TagsOnCampaignsUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: TagsOnCampaignsCreateManyTagInputEnvelope
    set?: TagsOnCampaignsWhereUniqueInput | TagsOnCampaignsWhereUniqueInput[]
    disconnect?: TagsOnCampaignsWhereUniqueInput | TagsOnCampaignsWhereUniqueInput[]
    delete?: TagsOnCampaignsWhereUniqueInput | TagsOnCampaignsWhereUniqueInput[]
    connect?: TagsOnCampaignsWhereUniqueInput | TagsOnCampaignsWhereUniqueInput[]
    update?: TagsOnCampaignsUpdateWithWhereUniqueWithoutTagInput | TagsOnCampaignsUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: TagsOnCampaignsUpdateManyWithWhereWithoutTagInput | TagsOnCampaignsUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: TagsOnCampaignsScalarWhereInput | TagsOnCampaignsScalarWhereInput[]
  }

  export type TagsOnCampaignsUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<TagsOnCampaignsCreateWithoutTagInput, TagsOnCampaignsUncheckedCreateWithoutTagInput> | TagsOnCampaignsCreateWithoutTagInput[] | TagsOnCampaignsUncheckedCreateWithoutTagInput[]
    connectOrCreate?: TagsOnCampaignsCreateOrConnectWithoutTagInput | TagsOnCampaignsCreateOrConnectWithoutTagInput[]
    upsert?: TagsOnCampaignsUpsertWithWhereUniqueWithoutTagInput | TagsOnCampaignsUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: TagsOnCampaignsCreateManyTagInputEnvelope
    set?: TagsOnCampaignsWhereUniqueInput | TagsOnCampaignsWhereUniqueInput[]
    disconnect?: TagsOnCampaignsWhereUniqueInput | TagsOnCampaignsWhereUniqueInput[]
    delete?: TagsOnCampaignsWhereUniqueInput | TagsOnCampaignsWhereUniqueInput[]
    connect?: TagsOnCampaignsWhereUniqueInput | TagsOnCampaignsWhereUniqueInput[]
    update?: TagsOnCampaignsUpdateWithWhereUniqueWithoutTagInput | TagsOnCampaignsUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: TagsOnCampaignsUpdateManyWithWhereWithoutTagInput | TagsOnCampaignsUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: TagsOnCampaignsScalarWhereInput | TagsOnCampaignsScalarWhereInput[]
  }

  export type TagCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<TagCreateWithoutCampaignsInput, TagUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: TagCreateOrConnectWithoutCampaignsInput
    connect?: TagWhereUniqueInput
  }

  export type CampaignCreateNestedOneWithoutTagsInput = {
    create?: XOR<CampaignCreateWithoutTagsInput, CampaignUncheckedCreateWithoutTagsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutTagsInput
    connect?: CampaignWhereUniqueInput
  }

  export type TagUpdateOneRequiredWithoutCampaignsNestedInput = {
    create?: XOR<TagCreateWithoutCampaignsInput, TagUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: TagCreateOrConnectWithoutCampaignsInput
    upsert?: TagUpsertWithoutCampaignsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutCampaignsInput, TagUpdateWithoutCampaignsInput>, TagUncheckedUpdateWithoutCampaignsInput>
  }

  export type CampaignUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<CampaignCreateWithoutTagsInput, CampaignUncheckedCreateWithoutTagsInput>
    connectOrCreate?: CampaignCreateOrConnectWithoutTagsInput
    upsert?: CampaignUpsertWithoutTagsInput
    connect?: CampaignWhereUniqueInput
    update?: XOR<XOR<CampaignUpdateToOneWithWhereWithoutTagsInput, CampaignUpdateWithoutTagsInput>, CampaignUncheckedUpdateWithoutTagsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumCampaignStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusFilter<$PrismaModel> | $Enums.CampaignStatus
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumBudgetTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetType | EnumBudgetTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.BudgetType[] | ListEnumBudgetTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BudgetType[] | ListEnumBudgetTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBudgetTypeNullableFilter<$PrismaModel> | $Enums.BudgetType | null
  }

  export type NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignStatus | EnumCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignStatus[] | ListEnumCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignStatusWithAggregatesFilter<$PrismaModel> | $Enums.CampaignStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignStatusFilter<$PrismaModel>
    _max?: NestedEnumCampaignStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumBudgetTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetType | EnumBudgetTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.BudgetType[] | ListEnumBudgetTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BudgetType[] | ListEnumBudgetTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBudgetTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.BudgetType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumBudgetTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumBudgetTypeNullableFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumAdSetStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AdSetStatus | EnumAdSetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdSetStatus[] | ListEnumAdSetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdSetStatus[] | ListEnumAdSetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdSetStatusFilter<$PrismaModel> | $Enums.AdSetStatus
  }

  export type NestedEnumAdSetStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdSetStatus | EnumAdSetStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdSetStatus[] | ListEnumAdSetStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdSetStatus[] | ListEnumAdSetStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdSetStatusWithAggregatesFilter<$PrismaModel> | $Enums.AdSetStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdSetStatusFilter<$PrismaModel>
    _max?: NestedEnumAdSetStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumAdStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AdStatus | EnumAdStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdStatus[] | ListEnumAdStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdStatus[] | ListEnumAdStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdStatusFilter<$PrismaModel> | $Enums.AdStatus
  }

  export type NestedEnumCreativeTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CreativeType | EnumCreativeTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.CreativeType[] | ListEnumCreativeTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CreativeType[] | ListEnumCreativeTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCreativeTypeNullableFilter<$PrismaModel> | $Enums.CreativeType | null
  }

  export type NestedEnumAdStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdStatus | EnumAdStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdStatus[] | ListEnumAdStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdStatus[] | ListEnumAdStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdStatusWithAggregatesFilter<$PrismaModel> | $Enums.AdStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdStatusFilter<$PrismaModel>
    _max?: NestedEnumAdStatusFilter<$PrismaModel>
  }

  export type NestedEnumCreativeTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CreativeType | EnumCreativeTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.CreativeType[] | ListEnumCreativeTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CreativeType[] | ListEnumCreativeTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCreativeTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.CreativeType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCreativeTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumCreativeTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumScheduleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleStatus | EnumScheduleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduleStatus[] | ListEnumScheduleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduleStatus[] | ListEnumScheduleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduleStatusFilter<$PrismaModel> | $Enums.ScheduleStatus
  }

  export type NestedEnumSchedulePriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.SchedulePriority | EnumSchedulePriorityFieldRefInput<$PrismaModel>
    in?: $Enums.SchedulePriority[] | ListEnumSchedulePriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SchedulePriority[] | ListEnumSchedulePriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumSchedulePriorityFilter<$PrismaModel> | $Enums.SchedulePriority
  }

  export type NestedEnumScheduleCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleCategory | EnumScheduleCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.ScheduleCategory[] | ListEnumScheduleCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ScheduleCategory[] | ListEnumScheduleCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumScheduleCategoryNullableFilter<$PrismaModel> | $Enums.ScheduleCategory | null
  }

  export type NestedEnumRecurrencePatternNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurrencePattern | EnumRecurrencePatternFieldRefInput<$PrismaModel> | null
    in?: $Enums.RecurrencePattern[] | ListEnumRecurrencePatternFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RecurrencePattern[] | ListEnumRecurrencePatternFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRecurrencePatternNullableFilter<$PrismaModel> | $Enums.RecurrencePattern | null
  }

  export type NestedEnumScheduleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleStatus | EnumScheduleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduleStatus[] | ListEnumScheduleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduleStatus[] | ListEnumScheduleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduleStatusWithAggregatesFilter<$PrismaModel> | $Enums.ScheduleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScheduleStatusFilter<$PrismaModel>
    _max?: NestedEnumScheduleStatusFilter<$PrismaModel>
  }

  export type NestedEnumSchedulePriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SchedulePriority | EnumSchedulePriorityFieldRefInput<$PrismaModel>
    in?: $Enums.SchedulePriority[] | ListEnumSchedulePriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.SchedulePriority[] | ListEnumSchedulePriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumSchedulePriorityWithAggregatesFilter<$PrismaModel> | $Enums.SchedulePriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSchedulePriorityFilter<$PrismaModel>
    _max?: NestedEnumSchedulePriorityFilter<$PrismaModel>
  }

  export type NestedEnumScheduleCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleCategory | EnumScheduleCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.ScheduleCategory[] | ListEnumScheduleCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ScheduleCategory[] | ListEnumScheduleCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumScheduleCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.ScheduleCategory | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumScheduleCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumScheduleCategoryNullableFilter<$PrismaModel>
  }

  export type NestedEnumRecurrencePatternNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecurrencePattern | EnumRecurrencePatternFieldRefInput<$PrismaModel> | null
    in?: $Enums.RecurrencePattern[] | ListEnumRecurrencePatternFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RecurrencePattern[] | ListEnumRecurrencePatternFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRecurrencePatternNullableWithAggregatesFilter<$PrismaModel> | $Enums.RecurrencePattern | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRecurrencePatternNullableFilter<$PrismaModel>
    _max?: NestedEnumRecurrencePatternNullableFilter<$PrismaModel>
  }

  export type NestedEnumCampaignObjectiveFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignObjective | EnumCampaignObjectiveFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignObjective[] | ListEnumCampaignObjectiveFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignObjective[] | ListEnumCampaignObjectiveFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignObjectiveFilter<$PrismaModel> | $Enums.CampaignObjective
  }

  export type NestedEnumBudgetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetType | EnumBudgetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BudgetType[] | ListEnumBudgetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BudgetType[] | ListEnumBudgetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBudgetTypeFilter<$PrismaModel> | $Enums.BudgetType
  }

  export type NestedEnumGenderTargetNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.GenderTarget | EnumGenderTargetFieldRefInput<$PrismaModel> | null
    in?: $Enums.GenderTarget[] | ListEnumGenderTargetFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.GenderTarget[] | ListEnumGenderTargetFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderTargetNullableFilter<$PrismaModel> | $Enums.GenderTarget | null
  }

  export type NestedEnumCampaignObjectiveWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CampaignObjective | EnumCampaignObjectiveFieldRefInput<$PrismaModel>
    in?: $Enums.CampaignObjective[] | ListEnumCampaignObjectiveFieldRefInput<$PrismaModel>
    notIn?: $Enums.CampaignObjective[] | ListEnumCampaignObjectiveFieldRefInput<$PrismaModel>
    not?: NestedEnumCampaignObjectiveWithAggregatesFilter<$PrismaModel> | $Enums.CampaignObjective
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCampaignObjectiveFilter<$PrismaModel>
    _max?: NestedEnumCampaignObjectiveFilter<$PrismaModel>
  }

  export type NestedEnumBudgetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BudgetType | EnumBudgetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BudgetType[] | ListEnumBudgetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BudgetType[] | ListEnumBudgetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBudgetTypeWithAggregatesFilter<$PrismaModel> | $Enums.BudgetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBudgetTypeFilter<$PrismaModel>
    _max?: NestedEnumBudgetTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumGenderTargetNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GenderTarget | EnumGenderTargetFieldRefInput<$PrismaModel> | null
    in?: $Enums.GenderTarget[] | ListEnumGenderTargetFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.GenderTarget[] | ListEnumGenderTargetFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderTargetNullableWithAggregatesFilter<$PrismaModel> | $Enums.GenderTarget | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderTargetNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderTargetNullableFilter<$PrismaModel>
  }

  export type NestedEnumPlatformTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PlatformType | EnumPlatformTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlatformType[] | ListEnumPlatformTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlatformType[] | ListEnumPlatformTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlatformTypeFilter<$PrismaModel> | $Enums.PlatformType
  }

  export type NestedEnumPlannerItemStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PlannerItemStatus | EnumPlannerItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PlannerItemStatus[] | ListEnumPlannerItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlannerItemStatus[] | ListEnumPlannerItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPlannerItemStatusFilter<$PrismaModel> | $Enums.PlannerItemStatus
  }

  export type NestedEnumPlatformTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlatformType | EnumPlatformTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlatformType[] | ListEnumPlatformTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlatformType[] | ListEnumPlatformTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlatformTypeWithAggregatesFilter<$PrismaModel> | $Enums.PlatformType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlatformTypeFilter<$PrismaModel>
    _max?: NestedEnumPlatformTypeFilter<$PrismaModel>
  }

  export type NestedEnumPlannerItemStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlannerItemStatus | EnumPlannerItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PlannerItemStatus[] | ListEnumPlannerItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlannerItemStatus[] | ListEnumPlannerItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPlannerItemStatusWithAggregatesFilter<$PrismaModel> | $Enums.PlannerItemStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlannerItemStatusFilter<$PrismaModel>
    _max?: NestedEnumPlannerItemStatusFilter<$PrismaModel>
  }

  export type NestedEnumInfluencerStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InfluencerStatus | EnumInfluencerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InfluencerStatus[] | ListEnumInfluencerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InfluencerStatus[] | ListEnumInfluencerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInfluencerStatusFilter<$PrismaModel> | $Enums.InfluencerStatus
  }

  export type NestedEnumInfluencerStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InfluencerStatus | EnumInfluencerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InfluencerStatus[] | ListEnumInfluencerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InfluencerStatus[] | ListEnumInfluencerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInfluencerStatusWithAggregatesFilter<$PrismaModel> | $Enums.InfluencerStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInfluencerStatusFilter<$PrismaModel>
    _max?: NestedEnumInfluencerStatusFilter<$PrismaModel>
  }

  export type NestedEnumInfluencerCampaignStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InfluencerCampaignStatus | EnumInfluencerCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InfluencerCampaignStatus[] | ListEnumInfluencerCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InfluencerCampaignStatus[] | ListEnumInfluencerCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInfluencerCampaignStatusFilter<$PrismaModel> | $Enums.InfluencerCampaignStatus
  }

  export type NestedEnumInfluencerCampaignStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InfluencerCampaignStatus | EnumInfluencerCampaignStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InfluencerCampaignStatus[] | ListEnumInfluencerCampaignStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InfluencerCampaignStatus[] | ListEnumInfluencerCampaignStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInfluencerCampaignStatusWithAggregatesFilter<$PrismaModel> | $Enums.InfluencerCampaignStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInfluencerCampaignStatusFilter<$PrismaModel>
    _max?: NestedEnumInfluencerCampaignStatusFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumIncomeCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.IncomeCategory | EnumIncomeCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.IncomeCategory[] | ListEnumIncomeCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncomeCategory[] | ListEnumIncomeCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumIncomeCategoryFilter<$PrismaModel> | $Enums.IncomeCategory
  }

  export type NestedEnumIncomeCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IncomeCategory | EnumIncomeCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.IncomeCategory[] | ListEnumIncomeCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.IncomeCategory[] | ListEnumIncomeCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumIncomeCategoryWithAggregatesFilter<$PrismaModel> | $Enums.IncomeCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIncomeCategoryFilter<$PrismaModel>
    _max?: NestedEnumIncomeCategoryFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type MetaAccountCreateWithoutUserInput = {
    id?: string
    metaAccountId: string
    accessToken: string
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    businessName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignCreateNestedManyWithoutMetaAccountInput
    adSets?: AdSetCreateNestedManyWithoutMetaAccountInput
    ads?: AdCreateNestedManyWithoutMetaAccountInput
    adAccounts?: AdAccountCreateNestedManyWithoutMetaAccountInput
  }

  export type MetaAccountUncheckedCreateWithoutUserInput = {
    id?: string
    metaAccountId: string
    accessToken: string
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    businessName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignUncheckedCreateNestedManyWithoutMetaAccountInput
    adSets?: AdSetUncheckedCreateNestedManyWithoutMetaAccountInput
    ads?: AdUncheckedCreateNestedManyWithoutMetaAccountInput
    adAccounts?: AdAccountUncheckedCreateNestedManyWithoutMetaAccountInput
  }

  export type MetaAccountCreateOrConnectWithoutUserInput = {
    where: MetaAccountWhereUniqueInput
    create: XOR<MetaAccountCreateWithoutUserInput, MetaAccountUncheckedCreateWithoutUserInput>
  }

  export type MetaAccountCreateManyUserInputEnvelope = {
    data: MetaAccountCreateManyUserInput | MetaAccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SocialMediaAccountCreateWithoutUserInput = {
    id?: string
    platform: $Enums.PlatformType
    accountName: string
    accountId?: string | null
    followers?: number
    accessToken?: string | null
    tokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    platformMetrics?: PlatformMetricsCreateNestedManyWithoutAccountInput
    engagementMetrics?: EngagementMetricsCreateNestedManyWithoutAccountInput
    influencers?: InfluencerCreateNestedManyWithoutAccountInput
  }

  export type SocialMediaAccountUncheckedCreateWithoutUserInput = {
    id?: string
    platform: $Enums.PlatformType
    accountName: string
    accountId?: string | null
    followers?: number
    accessToken?: string | null
    tokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    platformMetrics?: PlatformMetricsUncheckedCreateNestedManyWithoutAccountInput
    engagementMetrics?: EngagementMetricsUncheckedCreateNestedManyWithoutAccountInput
    influencers?: InfluencerUncheckedCreateNestedManyWithoutAccountInput
  }

  export type SocialMediaAccountCreateOrConnectWithoutUserInput = {
    where: SocialMediaAccountWhereUniqueInput
    create: XOR<SocialMediaAccountCreateWithoutUserInput, SocialMediaAccountUncheckedCreateWithoutUserInput>
  }

  export type SocialMediaAccountCreateManyUserInputEnvelope = {
    data: SocialMediaAccountCreateManyUserInput | SocialMediaAccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CampaignCreateWithoutUserInput = {
    id?: string
    campaignId?: string | null
    name: string
    objective: string
    status: $Enums.CampaignStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metaAccount?: MetaAccountCreateNestedOneWithoutCampaignsInput
    adAccount?: AdAccountCreateNestedOneWithoutCampaignsInput
    adSets?: AdSetCreateNestedManyWithoutCampaignInput
    tags?: TagsOnCampaignsCreateNestedManyWithoutCampaignInput
    metrics?: CampaignMetricsCreateNestedManyWithoutCampaignInput
    clinic?: ClinicCreateNestedOneWithoutCampaignsInput
    product?: ProductCreateNestedOneWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateWithoutUserInput = {
    id?: string
    metaAccountId?: string | null
    adAccountId?: string | null
    campaignId?: string | null
    name: string
    objective: string
    status: $Enums.CampaignStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinicId?: string | null
    productId?: string | null
    adSets?: AdSetUncheckedCreateNestedManyWithoutCampaignInput
    tags?: TagsOnCampaignsUncheckedCreateNestedManyWithoutCampaignInput
    metrics?: CampaignMetricsUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutUserInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput>
  }

  export type CampaignCreateManyUserInputEnvelope = {
    data: CampaignCreateManyUserInput | CampaignCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AdSetCreateWithoutUserInput = {
    id?: string
    adSetId?: string | null
    name: string
    status: $Enums.AdSetStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    bidStrategy?: string | null
    bidAmount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targeting?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutAdSetsInput
    metaAccount?: MetaAccountCreateNestedOneWithoutAdSetsInput
    ads?: AdCreateNestedManyWithoutAdSetInput
    metrics?: AdSetMetricsCreateNestedManyWithoutAdSetInput
  }

  export type AdSetUncheckedCreateWithoutUserInput = {
    id?: string
    campaignId: string
    metaAccountId?: string | null
    adSetId?: string | null
    name: string
    status: $Enums.AdSetStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    bidStrategy?: string | null
    bidAmount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targeting?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ads?: AdUncheckedCreateNestedManyWithoutAdSetInput
    metrics?: AdSetMetricsUncheckedCreateNestedManyWithoutAdSetInput
  }

  export type AdSetCreateOrConnectWithoutUserInput = {
    where: AdSetWhereUniqueInput
    create: XOR<AdSetCreateWithoutUserInput, AdSetUncheckedCreateWithoutUserInput>
  }

  export type AdSetCreateManyUserInputEnvelope = {
    data: AdSetCreateManyUserInput | AdSetCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AdCreateWithoutUserInput = {
    id?: string
    adId?: string | null
    name: string
    status: $Enums.AdStatus
    headline?: string | null
    description?: string | null
    creativeType?: $Enums.CreativeType | null
    imageUrl?: string | null
    videoUrl?: string | null
    destinationUrl?: string | null
    callToAction?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adSet: AdSetCreateNestedOneWithoutAdsInput
    metaAccount?: MetaAccountCreateNestedOneWithoutAdsInput
    metrics?: AdMetricsCreateNestedManyWithoutAdInput
    schedules?: ScheduleCreateNestedManyWithoutAdInput
  }

  export type AdUncheckedCreateWithoutUserInput = {
    id?: string
    adSetId: string
    metaAccountId?: string | null
    adId?: string | null
    name: string
    status: $Enums.AdStatus
    headline?: string | null
    description?: string | null
    creativeType?: $Enums.CreativeType | null
    imageUrl?: string | null
    videoUrl?: string | null
    destinationUrl?: string | null
    callToAction?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metrics?: AdMetricsUncheckedCreateNestedManyWithoutAdInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutAdInput
  }

  export type AdCreateOrConnectWithoutUserInput = {
    where: AdWhereUniqueInput
    create: XOR<AdCreateWithoutUserInput, AdUncheckedCreateWithoutUserInput>
  }

  export type AdCreateManyUserInputEnvelope = {
    data: AdCreateManyUserInput | AdCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ScheduleCreateWithoutUserInput = {
    id?: string
    title: string
    startDate: Date | string
    endDate: Date | string
    status: $Enums.ScheduleStatus
    priority?: $Enums.SchedulePriority
    category?: $Enums.ScheduleCategory | null
    recurrence?: $Enums.RecurrencePattern | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ad?: AdCreateNestedOneWithoutSchedulesInput
    clinic?: ClinicCreateNestedOneWithoutSchedulesInput
    product?: ProductCreateNestedOneWithoutSchedulesInput
  }

  export type ScheduleUncheckedCreateWithoutUserInput = {
    id?: string
    adId?: string | null
    title: string
    startDate: Date | string
    endDate: Date | string
    status: $Enums.ScheduleStatus
    priority?: $Enums.SchedulePriority
    category?: $Enums.ScheduleCategory | null
    clinicId?: string | null
    productId?: string | null
    recurrence?: $Enums.RecurrencePattern | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleCreateOrConnectWithoutUserInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutUserInput, ScheduleUncheckedCreateWithoutUserInput>
  }

  export type ScheduleCreateManyUserInputEnvelope = {
    data: ScheduleCreateManyUserInput | ScheduleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutUserInput = {
    id?: string
    amount: number
    currency?: string
    status: $Enums.PaymentStatus
    method: $Enums.PaymentMethod
    description?: string | null
    transactionId?: string | null
    receiptUrl?: string | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice?: InvoiceCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutUserInput = {
    id?: string
    amount: number
    currency?: string
    status: $Enums.PaymentStatus
    method: $Enums.PaymentMethod
    description?: string | null
    transactionId?: string | null
    receiptUrl?: string | null
    invoiceId?: string | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutUserInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentCreateManyUserInputEnvelope = {
    data: PaymentCreateManyUserInput | PaymentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutUserInput = {
    id?: string
    invoiceNumber: string
    amount: number
    currency?: string
    status: $Enums.InvoiceStatus
    dueDate: Date | string
    issueDate?: Date | string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutUserInput = {
    id?: string
    invoiceNumber: string
    amount: number
    currency?: string
    status: $Enums.InvoiceStatus
    dueDate: Date | string
    issueDate?: Date | string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutUserInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput>
  }

  export type InvoiceCreateManyUserInputEnvelope = {
    data: InvoiceCreateManyUserInput | InvoiceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InfluencerCreateWithoutUserInput = {
    id?: string
    name: string
    contactInfo?: string | null
    reach?: number
    engagementRate?: number | null
    niche?: string | null
    cost?: number | null
    status?: $Enums.InfluencerStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: SocialMediaAccountCreateNestedOneWithoutInfluencersInput
    campaigns?: InfluencerCampaignsCreateNestedManyWithoutInfluencerInput
  }

  export type InfluencerUncheckedCreateWithoutUserInput = {
    id?: string
    accountId: string
    name: string
    contactInfo?: string | null
    reach?: number
    engagementRate?: number | null
    niche?: string | null
    cost?: number | null
    status?: $Enums.InfluencerStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: InfluencerCampaignsUncheckedCreateNestedManyWithoutInfluencerInput
  }

  export type InfluencerCreateOrConnectWithoutUserInput = {
    where: InfluencerWhereUniqueInput
    create: XOR<InfluencerCreateWithoutUserInput, InfluencerUncheckedCreateWithoutUserInput>
  }

  export type InfluencerCreateManyUserInputEnvelope = {
    data: InfluencerCreateManyUserInput | InfluencerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ClinicCreateWithoutUserInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    featured?: boolean
    logoUrl?: string | null
    rating?: number | null
    reviewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleCreateNestedManyWithoutClinicInput
    campaigns?: CampaignCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    featured?: boolean
    logoUrl?: string | null
    rating?: number | null
    reviewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleUncheckedCreateNestedManyWithoutClinicInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutUserInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutUserInput, ClinicUncheckedCreateWithoutUserInput>
  }

  export type ClinicCreateManyUserInputEnvelope = {
    data: ClinicCreateManyUserInput | ClinicCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    price?: number | null
    sku?: string | null
    imageUrl?: string | null
    featured?: boolean
    category?: string | null
    stock?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleCreateNestedManyWithoutProductInput
    campaigns?: CampaignCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    price?: number | null
    sku?: string | null
    imageUrl?: string | null
    featured?: boolean
    category?: string | null
    stock?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleUncheckedCreateNestedManyWithoutProductInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutUserInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutUserInput, ProductUncheckedCreateWithoutUserInput>
  }

  export type ProductCreateManyUserInputEnvelope = {
    data: ProductCreateManyUserInput | ProductCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MetaAccountUpsertWithWhereUniqueWithoutUserInput = {
    where: MetaAccountWhereUniqueInput
    update: XOR<MetaAccountUpdateWithoutUserInput, MetaAccountUncheckedUpdateWithoutUserInput>
    create: XOR<MetaAccountCreateWithoutUserInput, MetaAccountUncheckedCreateWithoutUserInput>
  }

  export type MetaAccountUpdateWithWhereUniqueWithoutUserInput = {
    where: MetaAccountWhereUniqueInput
    data: XOR<MetaAccountUpdateWithoutUserInput, MetaAccountUncheckedUpdateWithoutUserInput>
  }

  export type MetaAccountUpdateManyWithWhereWithoutUserInput = {
    where: MetaAccountScalarWhereInput
    data: XOR<MetaAccountUpdateManyMutationInput, MetaAccountUncheckedUpdateManyWithoutUserInput>
  }

  export type MetaAccountScalarWhereInput = {
    AND?: MetaAccountScalarWhereInput | MetaAccountScalarWhereInput[]
    OR?: MetaAccountScalarWhereInput[]
    NOT?: MetaAccountScalarWhereInput | MetaAccountScalarWhereInput[]
    id?: StringFilter<"MetaAccount"> | string
    userId?: StringFilter<"MetaAccount"> | string
    metaAccountId?: StringFilter<"MetaAccount"> | string
    accessToken?: StringFilter<"MetaAccount"> | string
    refreshToken?: StringNullableFilter<"MetaAccount"> | string | null
    tokenExpiresAt?: DateTimeNullableFilter<"MetaAccount"> | Date | string | null
    businessName?: StringNullableFilter<"MetaAccount"> | string | null
    createdAt?: DateTimeFilter<"MetaAccount"> | Date | string
    updatedAt?: DateTimeFilter<"MetaAccount"> | Date | string
  }

  export type SocialMediaAccountUpsertWithWhereUniqueWithoutUserInput = {
    where: SocialMediaAccountWhereUniqueInput
    update: XOR<SocialMediaAccountUpdateWithoutUserInput, SocialMediaAccountUncheckedUpdateWithoutUserInput>
    create: XOR<SocialMediaAccountCreateWithoutUserInput, SocialMediaAccountUncheckedCreateWithoutUserInput>
  }

  export type SocialMediaAccountUpdateWithWhereUniqueWithoutUserInput = {
    where: SocialMediaAccountWhereUniqueInput
    data: XOR<SocialMediaAccountUpdateWithoutUserInput, SocialMediaAccountUncheckedUpdateWithoutUserInput>
  }

  export type SocialMediaAccountUpdateManyWithWhereWithoutUserInput = {
    where: SocialMediaAccountScalarWhereInput
    data: XOR<SocialMediaAccountUpdateManyMutationInput, SocialMediaAccountUncheckedUpdateManyWithoutUserInput>
  }

  export type SocialMediaAccountScalarWhereInput = {
    AND?: SocialMediaAccountScalarWhereInput | SocialMediaAccountScalarWhereInput[]
    OR?: SocialMediaAccountScalarWhereInput[]
    NOT?: SocialMediaAccountScalarWhereInput | SocialMediaAccountScalarWhereInput[]
    id?: StringFilter<"SocialMediaAccount"> | string
    userId?: StringFilter<"SocialMediaAccount"> | string
    platform?: EnumPlatformTypeFilter<"SocialMediaAccount"> | $Enums.PlatformType
    accountName?: StringFilter<"SocialMediaAccount"> | string
    accountId?: StringNullableFilter<"SocialMediaAccount"> | string | null
    followers?: IntFilter<"SocialMediaAccount"> | number
    accessToken?: StringNullableFilter<"SocialMediaAccount"> | string | null
    tokenExpiresAt?: DateTimeNullableFilter<"SocialMediaAccount"> | Date | string | null
    createdAt?: DateTimeFilter<"SocialMediaAccount"> | Date | string
    updatedAt?: DateTimeFilter<"SocialMediaAccount"> | Date | string
  }

  export type CampaignUpsertWithWhereUniqueWithoutUserInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutUserInput, CampaignUncheckedUpdateWithoutUserInput>
    create: XOR<CampaignCreateWithoutUserInput, CampaignUncheckedCreateWithoutUserInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutUserInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutUserInput, CampaignUncheckedUpdateWithoutUserInput>
  }

  export type CampaignUpdateManyWithWhereWithoutUserInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutUserInput>
  }

  export type CampaignScalarWhereInput = {
    AND?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    OR?: CampaignScalarWhereInput[]
    NOT?: CampaignScalarWhereInput | CampaignScalarWhereInput[]
    id?: StringFilter<"Campaign"> | string
    userId?: StringFilter<"Campaign"> | string
    metaAccountId?: StringNullableFilter<"Campaign"> | string | null
    adAccountId?: StringNullableFilter<"Campaign"> | string | null
    campaignId?: StringNullableFilter<"Campaign"> | string | null
    name?: StringFilter<"Campaign"> | string
    objective?: StringFilter<"Campaign"> | string
    status?: EnumCampaignStatusFilter<"Campaign"> | $Enums.CampaignStatus
    budget?: FloatNullableFilter<"Campaign"> | number | null
    budgetType?: EnumBudgetTypeNullableFilter<"Campaign"> | $Enums.BudgetType | null
    startDate?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Campaign"> | Date | string | null
    createdAt?: DateTimeFilter<"Campaign"> | Date | string
    updatedAt?: DateTimeFilter<"Campaign"> | Date | string
    clinicId?: StringNullableFilter<"Campaign"> | string | null
    productId?: StringNullableFilter<"Campaign"> | string | null
  }

  export type AdSetUpsertWithWhereUniqueWithoutUserInput = {
    where: AdSetWhereUniqueInput
    update: XOR<AdSetUpdateWithoutUserInput, AdSetUncheckedUpdateWithoutUserInput>
    create: XOR<AdSetCreateWithoutUserInput, AdSetUncheckedCreateWithoutUserInput>
  }

  export type AdSetUpdateWithWhereUniqueWithoutUserInput = {
    where: AdSetWhereUniqueInput
    data: XOR<AdSetUpdateWithoutUserInput, AdSetUncheckedUpdateWithoutUserInput>
  }

  export type AdSetUpdateManyWithWhereWithoutUserInput = {
    where: AdSetScalarWhereInput
    data: XOR<AdSetUpdateManyMutationInput, AdSetUncheckedUpdateManyWithoutUserInput>
  }

  export type AdSetScalarWhereInput = {
    AND?: AdSetScalarWhereInput | AdSetScalarWhereInput[]
    OR?: AdSetScalarWhereInput[]
    NOT?: AdSetScalarWhereInput | AdSetScalarWhereInput[]
    id?: StringFilter<"AdSet"> | string
    userId?: StringFilter<"AdSet"> | string
    campaignId?: StringFilter<"AdSet"> | string
    metaAccountId?: StringNullableFilter<"AdSet"> | string | null
    adSetId?: StringNullableFilter<"AdSet"> | string | null
    name?: StringFilter<"AdSet"> | string
    status?: EnumAdSetStatusFilter<"AdSet"> | $Enums.AdSetStatus
    budget?: FloatNullableFilter<"AdSet"> | number | null
    budgetType?: EnumBudgetTypeNullableFilter<"AdSet"> | $Enums.BudgetType | null
    bidStrategy?: StringNullableFilter<"AdSet"> | string | null
    bidAmount?: FloatNullableFilter<"AdSet"> | number | null
    startDate?: DateTimeNullableFilter<"AdSet"> | Date | string | null
    endDate?: DateTimeNullableFilter<"AdSet"> | Date | string | null
    targeting?: JsonNullableFilter<"AdSet">
    createdAt?: DateTimeFilter<"AdSet"> | Date | string
    updatedAt?: DateTimeFilter<"AdSet"> | Date | string
  }

  export type AdUpsertWithWhereUniqueWithoutUserInput = {
    where: AdWhereUniqueInput
    update: XOR<AdUpdateWithoutUserInput, AdUncheckedUpdateWithoutUserInput>
    create: XOR<AdCreateWithoutUserInput, AdUncheckedCreateWithoutUserInput>
  }

  export type AdUpdateWithWhereUniqueWithoutUserInput = {
    where: AdWhereUniqueInput
    data: XOR<AdUpdateWithoutUserInput, AdUncheckedUpdateWithoutUserInput>
  }

  export type AdUpdateManyWithWhereWithoutUserInput = {
    where: AdScalarWhereInput
    data: XOR<AdUpdateManyMutationInput, AdUncheckedUpdateManyWithoutUserInput>
  }

  export type AdScalarWhereInput = {
    AND?: AdScalarWhereInput | AdScalarWhereInput[]
    OR?: AdScalarWhereInput[]
    NOT?: AdScalarWhereInput | AdScalarWhereInput[]
    id?: StringFilter<"Ad"> | string
    userId?: StringFilter<"Ad"> | string
    adSetId?: StringFilter<"Ad"> | string
    metaAccountId?: StringNullableFilter<"Ad"> | string | null
    adId?: StringNullableFilter<"Ad"> | string | null
    name?: StringFilter<"Ad"> | string
    status?: EnumAdStatusFilter<"Ad"> | $Enums.AdStatus
    headline?: StringNullableFilter<"Ad"> | string | null
    description?: StringNullableFilter<"Ad"> | string | null
    creativeType?: EnumCreativeTypeNullableFilter<"Ad"> | $Enums.CreativeType | null
    imageUrl?: StringNullableFilter<"Ad"> | string | null
    videoUrl?: StringNullableFilter<"Ad"> | string | null
    destinationUrl?: StringNullableFilter<"Ad"> | string | null
    callToAction?: StringNullableFilter<"Ad"> | string | null
    createdAt?: DateTimeFilter<"Ad"> | Date | string
    updatedAt?: DateTimeFilter<"Ad"> | Date | string
  }

  export type ScheduleUpsertWithWhereUniqueWithoutUserInput = {
    where: ScheduleWhereUniqueInput
    update: XOR<ScheduleUpdateWithoutUserInput, ScheduleUncheckedUpdateWithoutUserInput>
    create: XOR<ScheduleCreateWithoutUserInput, ScheduleUncheckedCreateWithoutUserInput>
  }

  export type ScheduleUpdateWithWhereUniqueWithoutUserInput = {
    where: ScheduleWhereUniqueInput
    data: XOR<ScheduleUpdateWithoutUserInput, ScheduleUncheckedUpdateWithoutUserInput>
  }

  export type ScheduleUpdateManyWithWhereWithoutUserInput = {
    where: ScheduleScalarWhereInput
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyWithoutUserInput>
  }

  export type ScheduleScalarWhereInput = {
    AND?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
    OR?: ScheduleScalarWhereInput[]
    NOT?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
    id?: StringFilter<"Schedule"> | string
    userId?: StringFilter<"Schedule"> | string
    adId?: StringNullableFilter<"Schedule"> | string | null
    title?: StringFilter<"Schedule"> | string
    startDate?: DateTimeFilter<"Schedule"> | Date | string
    endDate?: DateTimeFilter<"Schedule"> | Date | string
    status?: EnumScheduleStatusFilter<"Schedule"> | $Enums.ScheduleStatus
    priority?: EnumSchedulePriorityFilter<"Schedule"> | $Enums.SchedulePriority
    category?: EnumScheduleCategoryNullableFilter<"Schedule"> | $Enums.ScheduleCategory | null
    clinicId?: StringNullableFilter<"Schedule"> | string | null
    productId?: StringNullableFilter<"Schedule"> | string | null
    recurrence?: EnumRecurrencePatternNullableFilter<"Schedule"> | $Enums.RecurrencePattern | null
    notes?: StringNullableFilter<"Schedule"> | string | null
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
  }

  export type PaymentUpdateManyWithWhereWithoutUserInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutUserInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    description?: StringNullableFilter<"Payment"> | string | null
    transactionId?: StringNullableFilter<"Payment"> | string | null
    receiptUrl?: StringNullableFilter<"Payment"> | string | null
    invoiceId?: StringNullableFilter<"Payment"> | string | null
    date?: DateTimeFilter<"Payment"> | Date | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutUserInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutUserInput, InvoiceUncheckedUpdateWithoutUserInput>
    create: XOR<InvoiceCreateWithoutUserInput, InvoiceUncheckedCreateWithoutUserInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutUserInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutUserInput, InvoiceUncheckedUpdateWithoutUserInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutUserInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutUserInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    userId?: StringFilter<"Invoice"> | string
    invoiceNumber?: StringFilter<"Invoice"> | string
    amount?: FloatFilter<"Invoice"> | number
    currency?: StringFilter<"Invoice"> | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    issueDate?: DateTimeFilter<"Invoice"> | Date | string
    description?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type InfluencerUpsertWithWhereUniqueWithoutUserInput = {
    where: InfluencerWhereUniqueInput
    update: XOR<InfluencerUpdateWithoutUserInput, InfluencerUncheckedUpdateWithoutUserInput>
    create: XOR<InfluencerCreateWithoutUserInput, InfluencerUncheckedCreateWithoutUserInput>
  }

  export type InfluencerUpdateWithWhereUniqueWithoutUserInput = {
    where: InfluencerWhereUniqueInput
    data: XOR<InfluencerUpdateWithoutUserInput, InfluencerUncheckedUpdateWithoutUserInput>
  }

  export type InfluencerUpdateManyWithWhereWithoutUserInput = {
    where: InfluencerScalarWhereInput
    data: XOR<InfluencerUpdateManyMutationInput, InfluencerUncheckedUpdateManyWithoutUserInput>
  }

  export type InfluencerScalarWhereInput = {
    AND?: InfluencerScalarWhereInput | InfluencerScalarWhereInput[]
    OR?: InfluencerScalarWhereInput[]
    NOT?: InfluencerScalarWhereInput | InfluencerScalarWhereInput[]
    id?: StringFilter<"Influencer"> | string
    userId?: StringFilter<"Influencer"> | string
    accountId?: StringFilter<"Influencer"> | string
    name?: StringFilter<"Influencer"> | string
    contactInfo?: StringNullableFilter<"Influencer"> | string | null
    reach?: IntFilter<"Influencer"> | number
    engagementRate?: FloatNullableFilter<"Influencer"> | number | null
    niche?: StringNullableFilter<"Influencer"> | string | null
    cost?: FloatNullableFilter<"Influencer"> | number | null
    status?: EnumInfluencerStatusFilter<"Influencer"> | $Enums.InfluencerStatus
    notes?: StringNullableFilter<"Influencer"> | string | null
    createdAt?: DateTimeFilter<"Influencer"> | Date | string
    updatedAt?: DateTimeFilter<"Influencer"> | Date | string
  }

  export type ClinicUpsertWithWhereUniqueWithoutUserInput = {
    where: ClinicWhereUniqueInput
    update: XOR<ClinicUpdateWithoutUserInput, ClinicUncheckedUpdateWithoutUserInput>
    create: XOR<ClinicCreateWithoutUserInput, ClinicUncheckedCreateWithoutUserInput>
  }

  export type ClinicUpdateWithWhereUniqueWithoutUserInput = {
    where: ClinicWhereUniqueInput
    data: XOR<ClinicUpdateWithoutUserInput, ClinicUncheckedUpdateWithoutUserInput>
  }

  export type ClinicUpdateManyWithWhereWithoutUserInput = {
    where: ClinicScalarWhereInput
    data: XOR<ClinicUpdateManyMutationInput, ClinicUncheckedUpdateManyWithoutUserInput>
  }

  export type ClinicScalarWhereInput = {
    AND?: ClinicScalarWhereInput | ClinicScalarWhereInput[]
    OR?: ClinicScalarWhereInput[]
    NOT?: ClinicScalarWhereInput | ClinicScalarWhereInput[]
    id?: StringFilter<"Clinic"> | string
    userId?: StringFilter<"Clinic"> | string
    name?: StringFilter<"Clinic"> | string
    address?: StringNullableFilter<"Clinic"> | string | null
    city?: StringNullableFilter<"Clinic"> | string | null
    phone?: StringNullableFilter<"Clinic"> | string | null
    email?: StringNullableFilter<"Clinic"> | string | null
    website?: StringNullableFilter<"Clinic"> | string | null
    description?: StringNullableFilter<"Clinic"> | string | null
    featured?: BoolFilter<"Clinic"> | boolean
    logoUrl?: StringNullableFilter<"Clinic"> | string | null
    rating?: FloatNullableFilter<"Clinic"> | number | null
    reviewCount?: IntFilter<"Clinic"> | number
    createdAt?: DateTimeFilter<"Clinic"> | Date | string
    updatedAt?: DateTimeFilter<"Clinic"> | Date | string
  }

  export type ProductUpsertWithWhereUniqueWithoutUserInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutUserInput, ProductUncheckedUpdateWithoutUserInput>
    create: XOR<ProductCreateWithoutUserInput, ProductUncheckedCreateWithoutUserInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutUserInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutUserInput, ProductUncheckedUpdateWithoutUserInput>
  }

  export type ProductUpdateManyWithWhereWithoutUserInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutUserInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    userId?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    price?: FloatNullableFilter<"Product"> | number | null
    sku?: StringNullableFilter<"Product"> | string | null
    imageUrl?: StringNullableFilter<"Product"> | string | null
    featured?: BoolFilter<"Product"> | boolean
    category?: StringNullableFilter<"Product"> | string | null
    stock?: IntNullableFilter<"Product"> | number | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type UserCreateWithoutMetaAccountsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    socialAccounts?: SocialMediaAccountCreateNestedManyWithoutUserInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    adsets?: AdSetCreateNestedManyWithoutUserInput
    ads?: AdCreateNestedManyWithoutUserInput
    schedules?: ScheduleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    influencers?: InfluencerCreateNestedManyWithoutUserInput
    clinics?: ClinicCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMetaAccountsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    socialAccounts?: SocialMediaAccountUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    adsets?: AdSetUncheckedCreateNestedManyWithoutUserInput
    ads?: AdUncheckedCreateNestedManyWithoutUserInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    influencers?: InfluencerUncheckedCreateNestedManyWithoutUserInput
    clinics?: ClinicUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMetaAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMetaAccountsInput, UserUncheckedCreateWithoutMetaAccountsInput>
  }

  export type CampaignCreateWithoutMetaAccountInput = {
    id?: string
    campaignId?: string | null
    name: string
    objective: string
    status: $Enums.CampaignStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCampaignsInput
    adAccount?: AdAccountCreateNestedOneWithoutCampaignsInput
    adSets?: AdSetCreateNestedManyWithoutCampaignInput
    tags?: TagsOnCampaignsCreateNestedManyWithoutCampaignInput
    metrics?: CampaignMetricsCreateNestedManyWithoutCampaignInput
    clinic?: ClinicCreateNestedOneWithoutCampaignsInput
    product?: ProductCreateNestedOneWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateWithoutMetaAccountInput = {
    id?: string
    userId: string
    adAccountId?: string | null
    campaignId?: string | null
    name: string
    objective: string
    status: $Enums.CampaignStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinicId?: string | null
    productId?: string | null
    adSets?: AdSetUncheckedCreateNestedManyWithoutCampaignInput
    tags?: TagsOnCampaignsUncheckedCreateNestedManyWithoutCampaignInput
    metrics?: CampaignMetricsUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutMetaAccountInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutMetaAccountInput, CampaignUncheckedCreateWithoutMetaAccountInput>
  }

  export type CampaignCreateManyMetaAccountInputEnvelope = {
    data: CampaignCreateManyMetaAccountInput | CampaignCreateManyMetaAccountInput[]
    skipDuplicates?: boolean
  }

  export type AdSetCreateWithoutMetaAccountInput = {
    id?: string
    adSetId?: string | null
    name: string
    status: $Enums.AdSetStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    bidStrategy?: string | null
    bidAmount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targeting?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAdsetsInput
    campaign: CampaignCreateNestedOneWithoutAdSetsInput
    ads?: AdCreateNestedManyWithoutAdSetInput
    metrics?: AdSetMetricsCreateNestedManyWithoutAdSetInput
  }

  export type AdSetUncheckedCreateWithoutMetaAccountInput = {
    id?: string
    userId: string
    campaignId: string
    adSetId?: string | null
    name: string
    status: $Enums.AdSetStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    bidStrategy?: string | null
    bidAmount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targeting?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ads?: AdUncheckedCreateNestedManyWithoutAdSetInput
    metrics?: AdSetMetricsUncheckedCreateNestedManyWithoutAdSetInput
  }

  export type AdSetCreateOrConnectWithoutMetaAccountInput = {
    where: AdSetWhereUniqueInput
    create: XOR<AdSetCreateWithoutMetaAccountInput, AdSetUncheckedCreateWithoutMetaAccountInput>
  }

  export type AdSetCreateManyMetaAccountInputEnvelope = {
    data: AdSetCreateManyMetaAccountInput | AdSetCreateManyMetaAccountInput[]
    skipDuplicates?: boolean
  }

  export type AdCreateWithoutMetaAccountInput = {
    id?: string
    adId?: string | null
    name: string
    status: $Enums.AdStatus
    headline?: string | null
    description?: string | null
    creativeType?: $Enums.CreativeType | null
    imageUrl?: string | null
    videoUrl?: string | null
    destinationUrl?: string | null
    callToAction?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAdsInput
    adSet: AdSetCreateNestedOneWithoutAdsInput
    metrics?: AdMetricsCreateNestedManyWithoutAdInput
    schedules?: ScheduleCreateNestedManyWithoutAdInput
  }

  export type AdUncheckedCreateWithoutMetaAccountInput = {
    id?: string
    userId: string
    adSetId: string
    adId?: string | null
    name: string
    status: $Enums.AdStatus
    headline?: string | null
    description?: string | null
    creativeType?: $Enums.CreativeType | null
    imageUrl?: string | null
    videoUrl?: string | null
    destinationUrl?: string | null
    callToAction?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metrics?: AdMetricsUncheckedCreateNestedManyWithoutAdInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutAdInput
  }

  export type AdCreateOrConnectWithoutMetaAccountInput = {
    where: AdWhereUniqueInput
    create: XOR<AdCreateWithoutMetaAccountInput, AdUncheckedCreateWithoutMetaAccountInput>
  }

  export type AdCreateManyMetaAccountInputEnvelope = {
    data: AdCreateManyMetaAccountInput | AdCreateManyMetaAccountInput[]
    skipDuplicates?: boolean
  }

  export type AdAccountCreateWithoutMetaAccountInput = {
    id?: string
    adAccountId: string
    name: string
    currency: string
    timezone: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignCreateNestedManyWithoutAdAccountInput
  }

  export type AdAccountUncheckedCreateWithoutMetaAccountInput = {
    id?: string
    adAccountId: string
    name: string
    currency: string
    timezone: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignUncheckedCreateNestedManyWithoutAdAccountInput
  }

  export type AdAccountCreateOrConnectWithoutMetaAccountInput = {
    where: AdAccountWhereUniqueInput
    create: XOR<AdAccountCreateWithoutMetaAccountInput, AdAccountUncheckedCreateWithoutMetaAccountInput>
  }

  export type AdAccountCreateManyMetaAccountInputEnvelope = {
    data: AdAccountCreateManyMetaAccountInput | AdAccountCreateManyMetaAccountInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutMetaAccountsInput = {
    update: XOR<UserUpdateWithoutMetaAccountsInput, UserUncheckedUpdateWithoutMetaAccountsInput>
    create: XOR<UserCreateWithoutMetaAccountsInput, UserUncheckedCreateWithoutMetaAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMetaAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMetaAccountsInput, UserUncheckedUpdateWithoutMetaAccountsInput>
  }

  export type UserUpdateWithoutMetaAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    socialAccounts?: SocialMediaAccountUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    adsets?: AdSetUpdateManyWithoutUserNestedInput
    ads?: AdUpdateManyWithoutUserNestedInput
    schedules?: ScheduleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    influencers?: InfluencerUpdateManyWithoutUserNestedInput
    clinics?: ClinicUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMetaAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    socialAccounts?: SocialMediaAccountUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    adsets?: AdSetUncheckedUpdateManyWithoutUserNestedInput
    ads?: AdUncheckedUpdateManyWithoutUserNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    influencers?: InfluencerUncheckedUpdateManyWithoutUserNestedInput
    clinics?: ClinicUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CampaignUpsertWithWhereUniqueWithoutMetaAccountInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutMetaAccountInput, CampaignUncheckedUpdateWithoutMetaAccountInput>
    create: XOR<CampaignCreateWithoutMetaAccountInput, CampaignUncheckedCreateWithoutMetaAccountInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutMetaAccountInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutMetaAccountInput, CampaignUncheckedUpdateWithoutMetaAccountInput>
  }

  export type CampaignUpdateManyWithWhereWithoutMetaAccountInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutMetaAccountInput>
  }

  export type AdSetUpsertWithWhereUniqueWithoutMetaAccountInput = {
    where: AdSetWhereUniqueInput
    update: XOR<AdSetUpdateWithoutMetaAccountInput, AdSetUncheckedUpdateWithoutMetaAccountInput>
    create: XOR<AdSetCreateWithoutMetaAccountInput, AdSetUncheckedCreateWithoutMetaAccountInput>
  }

  export type AdSetUpdateWithWhereUniqueWithoutMetaAccountInput = {
    where: AdSetWhereUniqueInput
    data: XOR<AdSetUpdateWithoutMetaAccountInput, AdSetUncheckedUpdateWithoutMetaAccountInput>
  }

  export type AdSetUpdateManyWithWhereWithoutMetaAccountInput = {
    where: AdSetScalarWhereInput
    data: XOR<AdSetUpdateManyMutationInput, AdSetUncheckedUpdateManyWithoutMetaAccountInput>
  }

  export type AdUpsertWithWhereUniqueWithoutMetaAccountInput = {
    where: AdWhereUniqueInput
    update: XOR<AdUpdateWithoutMetaAccountInput, AdUncheckedUpdateWithoutMetaAccountInput>
    create: XOR<AdCreateWithoutMetaAccountInput, AdUncheckedCreateWithoutMetaAccountInput>
  }

  export type AdUpdateWithWhereUniqueWithoutMetaAccountInput = {
    where: AdWhereUniqueInput
    data: XOR<AdUpdateWithoutMetaAccountInput, AdUncheckedUpdateWithoutMetaAccountInput>
  }

  export type AdUpdateManyWithWhereWithoutMetaAccountInput = {
    where: AdScalarWhereInput
    data: XOR<AdUpdateManyMutationInput, AdUncheckedUpdateManyWithoutMetaAccountInput>
  }

  export type AdAccountUpsertWithWhereUniqueWithoutMetaAccountInput = {
    where: AdAccountWhereUniqueInput
    update: XOR<AdAccountUpdateWithoutMetaAccountInput, AdAccountUncheckedUpdateWithoutMetaAccountInput>
    create: XOR<AdAccountCreateWithoutMetaAccountInput, AdAccountUncheckedCreateWithoutMetaAccountInput>
  }

  export type AdAccountUpdateWithWhereUniqueWithoutMetaAccountInput = {
    where: AdAccountWhereUniqueInput
    data: XOR<AdAccountUpdateWithoutMetaAccountInput, AdAccountUncheckedUpdateWithoutMetaAccountInput>
  }

  export type AdAccountUpdateManyWithWhereWithoutMetaAccountInput = {
    where: AdAccountScalarWhereInput
    data: XOR<AdAccountUpdateManyMutationInput, AdAccountUncheckedUpdateManyWithoutMetaAccountInput>
  }

  export type AdAccountScalarWhereInput = {
    AND?: AdAccountScalarWhereInput | AdAccountScalarWhereInput[]
    OR?: AdAccountScalarWhereInput[]
    NOT?: AdAccountScalarWhereInput | AdAccountScalarWhereInput[]
    id?: StringFilter<"AdAccount"> | string
    metaAccountId?: StringFilter<"AdAccount"> | string
    adAccountId?: StringFilter<"AdAccount"> | string
    name?: StringFilter<"AdAccount"> | string
    currency?: StringFilter<"AdAccount"> | string
    timezone?: StringFilter<"AdAccount"> | string
    status?: StringFilter<"AdAccount"> | string
    createdAt?: DateTimeFilter<"AdAccount"> | Date | string
    updatedAt?: DateTimeFilter<"AdAccount"> | Date | string
  }

  export type MetaAccountCreateWithoutAdAccountsInput = {
    id?: string
    metaAccountId: string
    accessToken: string
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    businessName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMetaAccountsInput
    campaigns?: CampaignCreateNestedManyWithoutMetaAccountInput
    adSets?: AdSetCreateNestedManyWithoutMetaAccountInput
    ads?: AdCreateNestedManyWithoutMetaAccountInput
  }

  export type MetaAccountUncheckedCreateWithoutAdAccountsInput = {
    id?: string
    userId: string
    metaAccountId: string
    accessToken: string
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    businessName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignUncheckedCreateNestedManyWithoutMetaAccountInput
    adSets?: AdSetUncheckedCreateNestedManyWithoutMetaAccountInput
    ads?: AdUncheckedCreateNestedManyWithoutMetaAccountInput
  }

  export type MetaAccountCreateOrConnectWithoutAdAccountsInput = {
    where: MetaAccountWhereUniqueInput
    create: XOR<MetaAccountCreateWithoutAdAccountsInput, MetaAccountUncheckedCreateWithoutAdAccountsInput>
  }

  export type CampaignCreateWithoutAdAccountInput = {
    id?: string
    campaignId?: string | null
    name: string
    objective: string
    status: $Enums.CampaignStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCampaignsInput
    metaAccount?: MetaAccountCreateNestedOneWithoutCampaignsInput
    adSets?: AdSetCreateNestedManyWithoutCampaignInput
    tags?: TagsOnCampaignsCreateNestedManyWithoutCampaignInput
    metrics?: CampaignMetricsCreateNestedManyWithoutCampaignInput
    clinic?: ClinicCreateNestedOneWithoutCampaignsInput
    product?: ProductCreateNestedOneWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateWithoutAdAccountInput = {
    id?: string
    userId: string
    metaAccountId?: string | null
    campaignId?: string | null
    name: string
    objective: string
    status: $Enums.CampaignStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinicId?: string | null
    productId?: string | null
    adSets?: AdSetUncheckedCreateNestedManyWithoutCampaignInput
    tags?: TagsOnCampaignsUncheckedCreateNestedManyWithoutCampaignInput
    metrics?: CampaignMetricsUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutAdAccountInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutAdAccountInput, CampaignUncheckedCreateWithoutAdAccountInput>
  }

  export type CampaignCreateManyAdAccountInputEnvelope = {
    data: CampaignCreateManyAdAccountInput | CampaignCreateManyAdAccountInput[]
    skipDuplicates?: boolean
  }

  export type MetaAccountUpsertWithoutAdAccountsInput = {
    update: XOR<MetaAccountUpdateWithoutAdAccountsInput, MetaAccountUncheckedUpdateWithoutAdAccountsInput>
    create: XOR<MetaAccountCreateWithoutAdAccountsInput, MetaAccountUncheckedCreateWithoutAdAccountsInput>
    where?: MetaAccountWhereInput
  }

  export type MetaAccountUpdateToOneWithWhereWithoutAdAccountsInput = {
    where?: MetaAccountWhereInput
    data: XOR<MetaAccountUpdateWithoutAdAccountsInput, MetaAccountUncheckedUpdateWithoutAdAccountsInput>
  }

  export type MetaAccountUpdateWithoutAdAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    metaAccountId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMetaAccountsNestedInput
    campaigns?: CampaignUpdateManyWithoutMetaAccountNestedInput
    adSets?: AdSetUpdateManyWithoutMetaAccountNestedInput
    ads?: AdUpdateManyWithoutMetaAccountNestedInput
  }

  export type MetaAccountUncheckedUpdateWithoutAdAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    metaAccountId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUncheckedUpdateManyWithoutMetaAccountNestedInput
    adSets?: AdSetUncheckedUpdateManyWithoutMetaAccountNestedInput
    ads?: AdUncheckedUpdateManyWithoutMetaAccountNestedInput
  }

  export type CampaignUpsertWithWhereUniqueWithoutAdAccountInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutAdAccountInput, CampaignUncheckedUpdateWithoutAdAccountInput>
    create: XOR<CampaignCreateWithoutAdAccountInput, CampaignUncheckedCreateWithoutAdAccountInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutAdAccountInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutAdAccountInput, CampaignUncheckedUpdateWithoutAdAccountInput>
  }

  export type CampaignUpdateManyWithWhereWithoutAdAccountInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutAdAccountInput>
  }

  export type UserCreateWithoutCampaignsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    metaAccounts?: MetaAccountCreateNestedManyWithoutUserInput
    socialAccounts?: SocialMediaAccountCreateNestedManyWithoutUserInput
    adsets?: AdSetCreateNestedManyWithoutUserInput
    ads?: AdCreateNestedManyWithoutUserInput
    schedules?: ScheduleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    influencers?: InfluencerCreateNestedManyWithoutUserInput
    clinics?: ClinicCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCampaignsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    metaAccounts?: MetaAccountUncheckedCreateNestedManyWithoutUserInput
    socialAccounts?: SocialMediaAccountUncheckedCreateNestedManyWithoutUserInput
    adsets?: AdSetUncheckedCreateNestedManyWithoutUserInput
    ads?: AdUncheckedCreateNestedManyWithoutUserInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    influencers?: InfluencerUncheckedCreateNestedManyWithoutUserInput
    clinics?: ClinicUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCampaignsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCampaignsInput, UserUncheckedCreateWithoutCampaignsInput>
  }

  export type MetaAccountCreateWithoutCampaignsInput = {
    id?: string
    metaAccountId: string
    accessToken: string
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    businessName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMetaAccountsInput
    adSets?: AdSetCreateNestedManyWithoutMetaAccountInput
    ads?: AdCreateNestedManyWithoutMetaAccountInput
    adAccounts?: AdAccountCreateNestedManyWithoutMetaAccountInput
  }

  export type MetaAccountUncheckedCreateWithoutCampaignsInput = {
    id?: string
    userId: string
    metaAccountId: string
    accessToken: string
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    businessName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    adSets?: AdSetUncheckedCreateNestedManyWithoutMetaAccountInput
    ads?: AdUncheckedCreateNestedManyWithoutMetaAccountInput
    adAccounts?: AdAccountUncheckedCreateNestedManyWithoutMetaAccountInput
  }

  export type MetaAccountCreateOrConnectWithoutCampaignsInput = {
    where: MetaAccountWhereUniqueInput
    create: XOR<MetaAccountCreateWithoutCampaignsInput, MetaAccountUncheckedCreateWithoutCampaignsInput>
  }

  export type AdAccountCreateWithoutCampaignsInput = {
    id?: string
    adAccountId: string
    name: string
    currency: string
    timezone: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    metaAccount: MetaAccountCreateNestedOneWithoutAdAccountsInput
  }

  export type AdAccountUncheckedCreateWithoutCampaignsInput = {
    id?: string
    metaAccountId: string
    adAccountId: string
    name: string
    currency: string
    timezone: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdAccountCreateOrConnectWithoutCampaignsInput = {
    where: AdAccountWhereUniqueInput
    create: XOR<AdAccountCreateWithoutCampaignsInput, AdAccountUncheckedCreateWithoutCampaignsInput>
  }

  export type AdSetCreateWithoutCampaignInput = {
    id?: string
    adSetId?: string | null
    name: string
    status: $Enums.AdSetStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    bidStrategy?: string | null
    bidAmount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targeting?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAdsetsInput
    metaAccount?: MetaAccountCreateNestedOneWithoutAdSetsInput
    ads?: AdCreateNestedManyWithoutAdSetInput
    metrics?: AdSetMetricsCreateNestedManyWithoutAdSetInput
  }

  export type AdSetUncheckedCreateWithoutCampaignInput = {
    id?: string
    userId: string
    metaAccountId?: string | null
    adSetId?: string | null
    name: string
    status: $Enums.AdSetStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    bidStrategy?: string | null
    bidAmount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targeting?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ads?: AdUncheckedCreateNestedManyWithoutAdSetInput
    metrics?: AdSetMetricsUncheckedCreateNestedManyWithoutAdSetInput
  }

  export type AdSetCreateOrConnectWithoutCampaignInput = {
    where: AdSetWhereUniqueInput
    create: XOR<AdSetCreateWithoutCampaignInput, AdSetUncheckedCreateWithoutCampaignInput>
  }

  export type AdSetCreateManyCampaignInputEnvelope = {
    data: AdSetCreateManyCampaignInput | AdSetCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type TagsOnCampaignsCreateWithoutCampaignInput = {
    assignedAt?: Date | string
    tag: TagCreateNestedOneWithoutCampaignsInput
  }

  export type TagsOnCampaignsUncheckedCreateWithoutCampaignInput = {
    tagId: string
    assignedAt?: Date | string
  }

  export type TagsOnCampaignsCreateOrConnectWithoutCampaignInput = {
    where: TagsOnCampaignsWhereUniqueInput
    create: XOR<TagsOnCampaignsCreateWithoutCampaignInput, TagsOnCampaignsUncheckedCreateWithoutCampaignInput>
  }

  export type TagsOnCampaignsCreateManyCampaignInputEnvelope = {
    data: TagsOnCampaignsCreateManyCampaignInput | TagsOnCampaignsCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type CampaignMetricsCreateWithoutCampaignInput = {
    id?: string
    date: Date | string
    impressions?: number
    clicks?: number
    reach?: number
    spend?: number
    conversions?: number
    costPerResult?: number | null
    ctr?: number | null
    cpc?: number | null
    cpm?: number | null
    frequency?: number | null
  }

  export type CampaignMetricsUncheckedCreateWithoutCampaignInput = {
    id?: string
    date: Date | string
    impressions?: number
    clicks?: number
    reach?: number
    spend?: number
    conversions?: number
    costPerResult?: number | null
    ctr?: number | null
    cpc?: number | null
    cpm?: number | null
    frequency?: number | null
  }

  export type CampaignMetricsCreateOrConnectWithoutCampaignInput = {
    where: CampaignMetricsWhereUniqueInput
    create: XOR<CampaignMetricsCreateWithoutCampaignInput, CampaignMetricsUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignMetricsCreateManyCampaignInputEnvelope = {
    data: CampaignMetricsCreateManyCampaignInput | CampaignMetricsCreateManyCampaignInput[]
    skipDuplicates?: boolean
  }

  export type ClinicCreateWithoutCampaignsInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    featured?: boolean
    logoUrl?: string | null
    rating?: number | null
    reviewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClinicsInput
    schedules?: ScheduleCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutCampaignsInput = {
    id?: string
    userId: string
    name: string
    address?: string | null
    city?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    featured?: boolean
    logoUrl?: string | null
    rating?: number | null
    reviewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutCampaignsInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutCampaignsInput, ClinicUncheckedCreateWithoutCampaignsInput>
  }

  export type ProductCreateWithoutCampaignsInput = {
    id?: string
    name: string
    description?: string | null
    price?: number | null
    sku?: string | null
    imageUrl?: string | null
    featured?: boolean
    category?: string | null
    stock?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProductsInput
    schedules?: ScheduleCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCampaignsInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    price?: number | null
    sku?: string | null
    imageUrl?: string | null
    featured?: boolean
    category?: string | null
    stock?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCampaignsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCampaignsInput, ProductUncheckedCreateWithoutCampaignsInput>
  }

  export type UserUpsertWithoutCampaignsInput = {
    update: XOR<UserUpdateWithoutCampaignsInput, UserUncheckedUpdateWithoutCampaignsInput>
    create: XOR<UserCreateWithoutCampaignsInput, UserUncheckedCreateWithoutCampaignsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCampaignsInput, UserUncheckedUpdateWithoutCampaignsInput>
  }

  export type UserUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaAccounts?: MetaAccountUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialMediaAccountUpdateManyWithoutUserNestedInput
    adsets?: AdSetUpdateManyWithoutUserNestedInput
    ads?: AdUpdateManyWithoutUserNestedInput
    schedules?: ScheduleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    influencers?: InfluencerUpdateManyWithoutUserNestedInput
    clinics?: ClinicUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaAccounts?: MetaAccountUncheckedUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialMediaAccountUncheckedUpdateManyWithoutUserNestedInput
    adsets?: AdSetUncheckedUpdateManyWithoutUserNestedInput
    ads?: AdUncheckedUpdateManyWithoutUserNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    influencers?: InfluencerUncheckedUpdateManyWithoutUserNestedInput
    clinics?: ClinicUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MetaAccountUpsertWithoutCampaignsInput = {
    update: XOR<MetaAccountUpdateWithoutCampaignsInput, MetaAccountUncheckedUpdateWithoutCampaignsInput>
    create: XOR<MetaAccountCreateWithoutCampaignsInput, MetaAccountUncheckedCreateWithoutCampaignsInput>
    where?: MetaAccountWhereInput
  }

  export type MetaAccountUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: MetaAccountWhereInput
    data: XOR<MetaAccountUpdateWithoutCampaignsInput, MetaAccountUncheckedUpdateWithoutCampaignsInput>
  }

  export type MetaAccountUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    metaAccountId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMetaAccountsNestedInput
    adSets?: AdSetUpdateManyWithoutMetaAccountNestedInput
    ads?: AdUpdateManyWithoutMetaAccountNestedInput
    adAccounts?: AdAccountUpdateManyWithoutMetaAccountNestedInput
  }

  export type MetaAccountUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    metaAccountId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adSets?: AdSetUncheckedUpdateManyWithoutMetaAccountNestedInput
    ads?: AdUncheckedUpdateManyWithoutMetaAccountNestedInput
    adAccounts?: AdAccountUncheckedUpdateManyWithoutMetaAccountNestedInput
  }

  export type AdAccountUpsertWithoutCampaignsInput = {
    update: XOR<AdAccountUpdateWithoutCampaignsInput, AdAccountUncheckedUpdateWithoutCampaignsInput>
    create: XOR<AdAccountCreateWithoutCampaignsInput, AdAccountUncheckedCreateWithoutCampaignsInput>
    where?: AdAccountWhereInput
  }

  export type AdAccountUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: AdAccountWhereInput
    data: XOR<AdAccountUpdateWithoutCampaignsInput, AdAccountUncheckedUpdateWithoutCampaignsInput>
  }

  export type AdAccountUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    adAccountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaAccount?: MetaAccountUpdateOneRequiredWithoutAdAccountsNestedInput
  }

  export type AdAccountUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    metaAccountId?: StringFieldUpdateOperationsInput | string
    adAccountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdSetUpsertWithWhereUniqueWithoutCampaignInput = {
    where: AdSetWhereUniqueInput
    update: XOR<AdSetUpdateWithoutCampaignInput, AdSetUncheckedUpdateWithoutCampaignInput>
    create: XOR<AdSetCreateWithoutCampaignInput, AdSetUncheckedCreateWithoutCampaignInput>
  }

  export type AdSetUpdateWithWhereUniqueWithoutCampaignInput = {
    where: AdSetWhereUniqueInput
    data: XOR<AdSetUpdateWithoutCampaignInput, AdSetUncheckedUpdateWithoutCampaignInput>
  }

  export type AdSetUpdateManyWithWhereWithoutCampaignInput = {
    where: AdSetScalarWhereInput
    data: XOR<AdSetUpdateManyMutationInput, AdSetUncheckedUpdateManyWithoutCampaignInput>
  }

  export type TagsOnCampaignsUpsertWithWhereUniqueWithoutCampaignInput = {
    where: TagsOnCampaignsWhereUniqueInput
    update: XOR<TagsOnCampaignsUpdateWithoutCampaignInput, TagsOnCampaignsUncheckedUpdateWithoutCampaignInput>
    create: XOR<TagsOnCampaignsCreateWithoutCampaignInput, TagsOnCampaignsUncheckedCreateWithoutCampaignInput>
  }

  export type TagsOnCampaignsUpdateWithWhereUniqueWithoutCampaignInput = {
    where: TagsOnCampaignsWhereUniqueInput
    data: XOR<TagsOnCampaignsUpdateWithoutCampaignInput, TagsOnCampaignsUncheckedUpdateWithoutCampaignInput>
  }

  export type TagsOnCampaignsUpdateManyWithWhereWithoutCampaignInput = {
    where: TagsOnCampaignsScalarWhereInput
    data: XOR<TagsOnCampaignsUpdateManyMutationInput, TagsOnCampaignsUncheckedUpdateManyWithoutCampaignInput>
  }

  export type TagsOnCampaignsScalarWhereInput = {
    AND?: TagsOnCampaignsScalarWhereInput | TagsOnCampaignsScalarWhereInput[]
    OR?: TagsOnCampaignsScalarWhereInput[]
    NOT?: TagsOnCampaignsScalarWhereInput | TagsOnCampaignsScalarWhereInput[]
    tagId?: StringFilter<"TagsOnCampaigns"> | string
    campaignId?: StringFilter<"TagsOnCampaigns"> | string
    assignedAt?: DateTimeFilter<"TagsOnCampaigns"> | Date | string
  }

  export type CampaignMetricsUpsertWithWhereUniqueWithoutCampaignInput = {
    where: CampaignMetricsWhereUniqueInput
    update: XOR<CampaignMetricsUpdateWithoutCampaignInput, CampaignMetricsUncheckedUpdateWithoutCampaignInput>
    create: XOR<CampaignMetricsCreateWithoutCampaignInput, CampaignMetricsUncheckedCreateWithoutCampaignInput>
  }

  export type CampaignMetricsUpdateWithWhereUniqueWithoutCampaignInput = {
    where: CampaignMetricsWhereUniqueInput
    data: XOR<CampaignMetricsUpdateWithoutCampaignInput, CampaignMetricsUncheckedUpdateWithoutCampaignInput>
  }

  export type CampaignMetricsUpdateManyWithWhereWithoutCampaignInput = {
    where: CampaignMetricsScalarWhereInput
    data: XOR<CampaignMetricsUpdateManyMutationInput, CampaignMetricsUncheckedUpdateManyWithoutCampaignInput>
  }

  export type CampaignMetricsScalarWhereInput = {
    AND?: CampaignMetricsScalarWhereInput | CampaignMetricsScalarWhereInput[]
    OR?: CampaignMetricsScalarWhereInput[]
    NOT?: CampaignMetricsScalarWhereInput | CampaignMetricsScalarWhereInput[]
    id?: StringFilter<"CampaignMetrics"> | string
    campaignId?: StringFilter<"CampaignMetrics"> | string
    date?: DateTimeFilter<"CampaignMetrics"> | Date | string
    impressions?: IntFilter<"CampaignMetrics"> | number
    clicks?: IntFilter<"CampaignMetrics"> | number
    reach?: IntFilter<"CampaignMetrics"> | number
    spend?: FloatFilter<"CampaignMetrics"> | number
    conversions?: IntFilter<"CampaignMetrics"> | number
    costPerResult?: FloatNullableFilter<"CampaignMetrics"> | number | null
    ctr?: FloatNullableFilter<"CampaignMetrics"> | number | null
    cpc?: FloatNullableFilter<"CampaignMetrics"> | number | null
    cpm?: FloatNullableFilter<"CampaignMetrics"> | number | null
    frequency?: FloatNullableFilter<"CampaignMetrics"> | number | null
  }

  export type ClinicUpsertWithoutCampaignsInput = {
    update: XOR<ClinicUpdateWithoutCampaignsInput, ClinicUncheckedUpdateWithoutCampaignsInput>
    create: XOR<ClinicCreateWithoutCampaignsInput, ClinicUncheckedCreateWithoutCampaignsInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutCampaignsInput, ClinicUncheckedUpdateWithoutCampaignsInput>
  }

  export type ClinicUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClinicsNestedInput
    schedules?: ScheduleUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type ProductUpsertWithoutCampaignsInput = {
    update: XOR<ProductUpdateWithoutCampaignsInput, ProductUncheckedUpdateWithoutCampaignsInput>
    create: XOR<ProductCreateWithoutCampaignsInput, ProductUncheckedCreateWithoutCampaignsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutCampaignsInput, ProductUncheckedUpdateWithoutCampaignsInput>
  }

  export type ProductUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProductsNestedInput
    schedules?: ScheduleUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUncheckedUpdateManyWithoutProductNestedInput
  }

  export type CampaignCreateWithoutMetricsInput = {
    id?: string
    campaignId?: string | null
    name: string
    objective: string
    status: $Enums.CampaignStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCampaignsInput
    metaAccount?: MetaAccountCreateNestedOneWithoutCampaignsInput
    adAccount?: AdAccountCreateNestedOneWithoutCampaignsInput
    adSets?: AdSetCreateNestedManyWithoutCampaignInput
    tags?: TagsOnCampaignsCreateNestedManyWithoutCampaignInput
    clinic?: ClinicCreateNestedOneWithoutCampaignsInput
    product?: ProductCreateNestedOneWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateWithoutMetricsInput = {
    id?: string
    userId: string
    metaAccountId?: string | null
    adAccountId?: string | null
    campaignId?: string | null
    name: string
    objective: string
    status: $Enums.CampaignStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinicId?: string | null
    productId?: string | null
    adSets?: AdSetUncheckedCreateNestedManyWithoutCampaignInput
    tags?: TagsOnCampaignsUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutMetricsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutMetricsInput, CampaignUncheckedCreateWithoutMetricsInput>
  }

  export type CampaignUpsertWithoutMetricsInput = {
    update: XOR<CampaignUpdateWithoutMetricsInput, CampaignUncheckedUpdateWithoutMetricsInput>
    create: XOR<CampaignCreateWithoutMetricsInput, CampaignUncheckedCreateWithoutMetricsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutMetricsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutMetricsInput, CampaignUncheckedUpdateWithoutMetricsInput>
  }

  export type CampaignUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCampaignsNestedInput
    metaAccount?: MetaAccountUpdateOneWithoutCampaignsNestedInput
    adAccount?: AdAccountUpdateOneWithoutCampaignsNestedInput
    adSets?: AdSetUpdateManyWithoutCampaignNestedInput
    tags?: TagsOnCampaignsUpdateManyWithoutCampaignNestedInput
    clinic?: ClinicUpdateOneWithoutCampaignsNestedInput
    product?: ProductUpdateOneWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    metaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    adAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    adSets?: AdSetUncheckedUpdateManyWithoutCampaignNestedInput
    tags?: TagsOnCampaignsUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type UserCreateWithoutAdsetsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    metaAccounts?: MetaAccountCreateNestedManyWithoutUserInput
    socialAccounts?: SocialMediaAccountCreateNestedManyWithoutUserInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    ads?: AdCreateNestedManyWithoutUserInput
    schedules?: ScheduleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    influencers?: InfluencerCreateNestedManyWithoutUserInput
    clinics?: ClinicCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdsetsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    metaAccounts?: MetaAccountUncheckedCreateNestedManyWithoutUserInput
    socialAccounts?: SocialMediaAccountUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    ads?: AdUncheckedCreateNestedManyWithoutUserInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    influencers?: InfluencerUncheckedCreateNestedManyWithoutUserInput
    clinics?: ClinicUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdsetsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdsetsInput, UserUncheckedCreateWithoutAdsetsInput>
  }

  export type CampaignCreateWithoutAdSetsInput = {
    id?: string
    campaignId?: string | null
    name: string
    objective: string
    status: $Enums.CampaignStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCampaignsInput
    metaAccount?: MetaAccountCreateNestedOneWithoutCampaignsInput
    adAccount?: AdAccountCreateNestedOneWithoutCampaignsInput
    tags?: TagsOnCampaignsCreateNestedManyWithoutCampaignInput
    metrics?: CampaignMetricsCreateNestedManyWithoutCampaignInput
    clinic?: ClinicCreateNestedOneWithoutCampaignsInput
    product?: ProductCreateNestedOneWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateWithoutAdSetsInput = {
    id?: string
    userId: string
    metaAccountId?: string | null
    adAccountId?: string | null
    campaignId?: string | null
    name: string
    objective: string
    status: $Enums.CampaignStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinicId?: string | null
    productId?: string | null
    tags?: TagsOnCampaignsUncheckedCreateNestedManyWithoutCampaignInput
    metrics?: CampaignMetricsUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutAdSetsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutAdSetsInput, CampaignUncheckedCreateWithoutAdSetsInput>
  }

  export type MetaAccountCreateWithoutAdSetsInput = {
    id?: string
    metaAccountId: string
    accessToken: string
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    businessName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMetaAccountsInput
    campaigns?: CampaignCreateNestedManyWithoutMetaAccountInput
    ads?: AdCreateNestedManyWithoutMetaAccountInput
    adAccounts?: AdAccountCreateNestedManyWithoutMetaAccountInput
  }

  export type MetaAccountUncheckedCreateWithoutAdSetsInput = {
    id?: string
    userId: string
    metaAccountId: string
    accessToken: string
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    businessName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignUncheckedCreateNestedManyWithoutMetaAccountInput
    ads?: AdUncheckedCreateNestedManyWithoutMetaAccountInput
    adAccounts?: AdAccountUncheckedCreateNestedManyWithoutMetaAccountInput
  }

  export type MetaAccountCreateOrConnectWithoutAdSetsInput = {
    where: MetaAccountWhereUniqueInput
    create: XOR<MetaAccountCreateWithoutAdSetsInput, MetaAccountUncheckedCreateWithoutAdSetsInput>
  }

  export type AdCreateWithoutAdSetInput = {
    id?: string
    adId?: string | null
    name: string
    status: $Enums.AdStatus
    headline?: string | null
    description?: string | null
    creativeType?: $Enums.CreativeType | null
    imageUrl?: string | null
    videoUrl?: string | null
    destinationUrl?: string | null
    callToAction?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAdsInput
    metaAccount?: MetaAccountCreateNestedOneWithoutAdsInput
    metrics?: AdMetricsCreateNestedManyWithoutAdInput
    schedules?: ScheduleCreateNestedManyWithoutAdInput
  }

  export type AdUncheckedCreateWithoutAdSetInput = {
    id?: string
    userId: string
    metaAccountId?: string | null
    adId?: string | null
    name: string
    status: $Enums.AdStatus
    headline?: string | null
    description?: string | null
    creativeType?: $Enums.CreativeType | null
    imageUrl?: string | null
    videoUrl?: string | null
    destinationUrl?: string | null
    callToAction?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metrics?: AdMetricsUncheckedCreateNestedManyWithoutAdInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutAdInput
  }

  export type AdCreateOrConnectWithoutAdSetInput = {
    where: AdWhereUniqueInput
    create: XOR<AdCreateWithoutAdSetInput, AdUncheckedCreateWithoutAdSetInput>
  }

  export type AdCreateManyAdSetInputEnvelope = {
    data: AdCreateManyAdSetInput | AdCreateManyAdSetInput[]
    skipDuplicates?: boolean
  }

  export type AdSetMetricsCreateWithoutAdSetInput = {
    id?: string
    date: Date | string
    impressions?: number
    clicks?: number
    reach?: number
    spend?: number
    conversions?: number
    costPerResult?: number | null
    ctr?: number | null
    cpc?: number | null
    cpm?: number | null
    frequency?: number | null
  }

  export type AdSetMetricsUncheckedCreateWithoutAdSetInput = {
    id?: string
    date: Date | string
    impressions?: number
    clicks?: number
    reach?: number
    spend?: number
    conversions?: number
    costPerResult?: number | null
    ctr?: number | null
    cpc?: number | null
    cpm?: number | null
    frequency?: number | null
  }

  export type AdSetMetricsCreateOrConnectWithoutAdSetInput = {
    where: AdSetMetricsWhereUniqueInput
    create: XOR<AdSetMetricsCreateWithoutAdSetInput, AdSetMetricsUncheckedCreateWithoutAdSetInput>
  }

  export type AdSetMetricsCreateManyAdSetInputEnvelope = {
    data: AdSetMetricsCreateManyAdSetInput | AdSetMetricsCreateManyAdSetInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAdsetsInput = {
    update: XOR<UserUpdateWithoutAdsetsInput, UserUncheckedUpdateWithoutAdsetsInput>
    create: XOR<UserCreateWithoutAdsetsInput, UserUncheckedCreateWithoutAdsetsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdsetsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdsetsInput, UserUncheckedUpdateWithoutAdsetsInput>
  }

  export type UserUpdateWithoutAdsetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaAccounts?: MetaAccountUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialMediaAccountUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    ads?: AdUpdateManyWithoutUserNestedInput
    schedules?: ScheduleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    influencers?: InfluencerUpdateManyWithoutUserNestedInput
    clinics?: ClinicUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdsetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaAccounts?: MetaAccountUncheckedUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialMediaAccountUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    ads?: AdUncheckedUpdateManyWithoutUserNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    influencers?: InfluencerUncheckedUpdateManyWithoutUserNestedInput
    clinics?: ClinicUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CampaignUpsertWithoutAdSetsInput = {
    update: XOR<CampaignUpdateWithoutAdSetsInput, CampaignUncheckedUpdateWithoutAdSetsInput>
    create: XOR<CampaignCreateWithoutAdSetsInput, CampaignUncheckedCreateWithoutAdSetsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutAdSetsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutAdSetsInput, CampaignUncheckedUpdateWithoutAdSetsInput>
  }

  export type CampaignUpdateWithoutAdSetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCampaignsNestedInput
    metaAccount?: MetaAccountUpdateOneWithoutCampaignsNestedInput
    adAccount?: AdAccountUpdateOneWithoutCampaignsNestedInput
    tags?: TagsOnCampaignsUpdateManyWithoutCampaignNestedInput
    metrics?: CampaignMetricsUpdateManyWithoutCampaignNestedInput
    clinic?: ClinicUpdateOneWithoutCampaignsNestedInput
    product?: ProductUpdateOneWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateWithoutAdSetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    metaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    adAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: TagsOnCampaignsUncheckedUpdateManyWithoutCampaignNestedInput
    metrics?: CampaignMetricsUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type MetaAccountUpsertWithoutAdSetsInput = {
    update: XOR<MetaAccountUpdateWithoutAdSetsInput, MetaAccountUncheckedUpdateWithoutAdSetsInput>
    create: XOR<MetaAccountCreateWithoutAdSetsInput, MetaAccountUncheckedCreateWithoutAdSetsInput>
    where?: MetaAccountWhereInput
  }

  export type MetaAccountUpdateToOneWithWhereWithoutAdSetsInput = {
    where?: MetaAccountWhereInput
    data: XOR<MetaAccountUpdateWithoutAdSetsInput, MetaAccountUncheckedUpdateWithoutAdSetsInput>
  }

  export type MetaAccountUpdateWithoutAdSetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    metaAccountId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMetaAccountsNestedInput
    campaigns?: CampaignUpdateManyWithoutMetaAccountNestedInput
    ads?: AdUpdateManyWithoutMetaAccountNestedInput
    adAccounts?: AdAccountUpdateManyWithoutMetaAccountNestedInput
  }

  export type MetaAccountUncheckedUpdateWithoutAdSetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    metaAccountId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUncheckedUpdateManyWithoutMetaAccountNestedInput
    ads?: AdUncheckedUpdateManyWithoutMetaAccountNestedInput
    adAccounts?: AdAccountUncheckedUpdateManyWithoutMetaAccountNestedInput
  }

  export type AdUpsertWithWhereUniqueWithoutAdSetInput = {
    where: AdWhereUniqueInput
    update: XOR<AdUpdateWithoutAdSetInput, AdUncheckedUpdateWithoutAdSetInput>
    create: XOR<AdCreateWithoutAdSetInput, AdUncheckedCreateWithoutAdSetInput>
  }

  export type AdUpdateWithWhereUniqueWithoutAdSetInput = {
    where: AdWhereUniqueInput
    data: XOR<AdUpdateWithoutAdSetInput, AdUncheckedUpdateWithoutAdSetInput>
  }

  export type AdUpdateManyWithWhereWithoutAdSetInput = {
    where: AdScalarWhereInput
    data: XOR<AdUpdateManyMutationInput, AdUncheckedUpdateManyWithoutAdSetInput>
  }

  export type AdSetMetricsUpsertWithWhereUniqueWithoutAdSetInput = {
    where: AdSetMetricsWhereUniqueInput
    update: XOR<AdSetMetricsUpdateWithoutAdSetInput, AdSetMetricsUncheckedUpdateWithoutAdSetInput>
    create: XOR<AdSetMetricsCreateWithoutAdSetInput, AdSetMetricsUncheckedCreateWithoutAdSetInput>
  }

  export type AdSetMetricsUpdateWithWhereUniqueWithoutAdSetInput = {
    where: AdSetMetricsWhereUniqueInput
    data: XOR<AdSetMetricsUpdateWithoutAdSetInput, AdSetMetricsUncheckedUpdateWithoutAdSetInput>
  }

  export type AdSetMetricsUpdateManyWithWhereWithoutAdSetInput = {
    where: AdSetMetricsScalarWhereInput
    data: XOR<AdSetMetricsUpdateManyMutationInput, AdSetMetricsUncheckedUpdateManyWithoutAdSetInput>
  }

  export type AdSetMetricsScalarWhereInput = {
    AND?: AdSetMetricsScalarWhereInput | AdSetMetricsScalarWhereInput[]
    OR?: AdSetMetricsScalarWhereInput[]
    NOT?: AdSetMetricsScalarWhereInput | AdSetMetricsScalarWhereInput[]
    id?: StringFilter<"AdSetMetrics"> | string
    adSetId?: StringFilter<"AdSetMetrics"> | string
    date?: DateTimeFilter<"AdSetMetrics"> | Date | string
    impressions?: IntFilter<"AdSetMetrics"> | number
    clicks?: IntFilter<"AdSetMetrics"> | number
    reach?: IntFilter<"AdSetMetrics"> | number
    spend?: FloatFilter<"AdSetMetrics"> | number
    conversions?: IntFilter<"AdSetMetrics"> | number
    costPerResult?: FloatNullableFilter<"AdSetMetrics"> | number | null
    ctr?: FloatNullableFilter<"AdSetMetrics"> | number | null
    cpc?: FloatNullableFilter<"AdSetMetrics"> | number | null
    cpm?: FloatNullableFilter<"AdSetMetrics"> | number | null
    frequency?: FloatNullableFilter<"AdSetMetrics"> | number | null
  }

  export type AdSetCreateWithoutMetricsInput = {
    id?: string
    adSetId?: string | null
    name: string
    status: $Enums.AdSetStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    bidStrategy?: string | null
    bidAmount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targeting?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAdsetsInput
    campaign: CampaignCreateNestedOneWithoutAdSetsInput
    metaAccount?: MetaAccountCreateNestedOneWithoutAdSetsInput
    ads?: AdCreateNestedManyWithoutAdSetInput
  }

  export type AdSetUncheckedCreateWithoutMetricsInput = {
    id?: string
    userId: string
    campaignId: string
    metaAccountId?: string | null
    adSetId?: string | null
    name: string
    status: $Enums.AdSetStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    bidStrategy?: string | null
    bidAmount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targeting?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ads?: AdUncheckedCreateNestedManyWithoutAdSetInput
  }

  export type AdSetCreateOrConnectWithoutMetricsInput = {
    where: AdSetWhereUniqueInput
    create: XOR<AdSetCreateWithoutMetricsInput, AdSetUncheckedCreateWithoutMetricsInput>
  }

  export type AdSetUpsertWithoutMetricsInput = {
    update: XOR<AdSetUpdateWithoutMetricsInput, AdSetUncheckedUpdateWithoutMetricsInput>
    create: XOR<AdSetCreateWithoutMetricsInput, AdSetUncheckedCreateWithoutMetricsInput>
    where?: AdSetWhereInput
  }

  export type AdSetUpdateToOneWithWhereWithoutMetricsInput = {
    where?: AdSetWhereInput
    data: XOR<AdSetUpdateWithoutMetricsInput, AdSetUncheckedUpdateWithoutMetricsInput>
  }

  export type AdSetUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    adSetId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAdSetStatusFieldUpdateOperationsInput | $Enums.AdSetStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    bidStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    bidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targeting?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdsetsNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutAdSetsNestedInput
    metaAccount?: MetaAccountUpdateOneWithoutAdSetsNestedInput
    ads?: AdUpdateManyWithoutAdSetNestedInput
  }

  export type AdSetUncheckedUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    metaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    adSetId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAdSetStatusFieldUpdateOperationsInput | $Enums.AdSetStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    bidStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    bidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targeting?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ads?: AdUncheckedUpdateManyWithoutAdSetNestedInput
  }

  export type UserCreateWithoutAdsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    metaAccounts?: MetaAccountCreateNestedManyWithoutUserInput
    socialAccounts?: SocialMediaAccountCreateNestedManyWithoutUserInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    adsets?: AdSetCreateNestedManyWithoutUserInput
    schedules?: ScheduleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    influencers?: InfluencerCreateNestedManyWithoutUserInput
    clinics?: ClinicCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    metaAccounts?: MetaAccountUncheckedCreateNestedManyWithoutUserInput
    socialAccounts?: SocialMediaAccountUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    adsets?: AdSetUncheckedCreateNestedManyWithoutUserInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    influencers?: InfluencerUncheckedCreateNestedManyWithoutUserInput
    clinics?: ClinicUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdsInput, UserUncheckedCreateWithoutAdsInput>
  }

  export type AdSetCreateWithoutAdsInput = {
    id?: string
    adSetId?: string | null
    name: string
    status: $Enums.AdSetStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    bidStrategy?: string | null
    bidAmount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targeting?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAdsetsInput
    campaign: CampaignCreateNestedOneWithoutAdSetsInput
    metaAccount?: MetaAccountCreateNestedOneWithoutAdSetsInput
    metrics?: AdSetMetricsCreateNestedManyWithoutAdSetInput
  }

  export type AdSetUncheckedCreateWithoutAdsInput = {
    id?: string
    userId: string
    campaignId: string
    metaAccountId?: string | null
    adSetId?: string | null
    name: string
    status: $Enums.AdSetStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    bidStrategy?: string | null
    bidAmount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targeting?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    metrics?: AdSetMetricsUncheckedCreateNestedManyWithoutAdSetInput
  }

  export type AdSetCreateOrConnectWithoutAdsInput = {
    where: AdSetWhereUniqueInput
    create: XOR<AdSetCreateWithoutAdsInput, AdSetUncheckedCreateWithoutAdsInput>
  }

  export type MetaAccountCreateWithoutAdsInput = {
    id?: string
    metaAccountId: string
    accessToken: string
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    businessName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMetaAccountsInput
    campaigns?: CampaignCreateNestedManyWithoutMetaAccountInput
    adSets?: AdSetCreateNestedManyWithoutMetaAccountInput
    adAccounts?: AdAccountCreateNestedManyWithoutMetaAccountInput
  }

  export type MetaAccountUncheckedCreateWithoutAdsInput = {
    id?: string
    userId: string
    metaAccountId: string
    accessToken: string
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    businessName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignUncheckedCreateNestedManyWithoutMetaAccountInput
    adSets?: AdSetUncheckedCreateNestedManyWithoutMetaAccountInput
    adAccounts?: AdAccountUncheckedCreateNestedManyWithoutMetaAccountInput
  }

  export type MetaAccountCreateOrConnectWithoutAdsInput = {
    where: MetaAccountWhereUniqueInput
    create: XOR<MetaAccountCreateWithoutAdsInput, MetaAccountUncheckedCreateWithoutAdsInput>
  }

  export type AdMetricsCreateWithoutAdInput = {
    id?: string
    date: Date | string
    impressions?: number
    clicks?: number
    reach?: number
    spend?: number
    conversions?: number
    costPerResult?: number | null
    ctr?: number | null
    cpc?: number | null
    cpm?: number | null
    frequency?: number | null
    engagements?: number
    shares?: number
    comments?: number
    saves?: number
  }

  export type AdMetricsUncheckedCreateWithoutAdInput = {
    id?: string
    date: Date | string
    impressions?: number
    clicks?: number
    reach?: number
    spend?: number
    conversions?: number
    costPerResult?: number | null
    ctr?: number | null
    cpc?: number | null
    cpm?: number | null
    frequency?: number | null
    engagements?: number
    shares?: number
    comments?: number
    saves?: number
  }

  export type AdMetricsCreateOrConnectWithoutAdInput = {
    where: AdMetricsWhereUniqueInput
    create: XOR<AdMetricsCreateWithoutAdInput, AdMetricsUncheckedCreateWithoutAdInput>
  }

  export type AdMetricsCreateManyAdInputEnvelope = {
    data: AdMetricsCreateManyAdInput | AdMetricsCreateManyAdInput[]
    skipDuplicates?: boolean
  }

  export type ScheduleCreateWithoutAdInput = {
    id?: string
    title: string
    startDate: Date | string
    endDate: Date | string
    status: $Enums.ScheduleStatus
    priority?: $Enums.SchedulePriority
    category?: $Enums.ScheduleCategory | null
    recurrence?: $Enums.RecurrencePattern | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSchedulesInput
    clinic?: ClinicCreateNestedOneWithoutSchedulesInput
    product?: ProductCreateNestedOneWithoutSchedulesInput
  }

  export type ScheduleUncheckedCreateWithoutAdInput = {
    id?: string
    userId: string
    title: string
    startDate: Date | string
    endDate: Date | string
    status: $Enums.ScheduleStatus
    priority?: $Enums.SchedulePriority
    category?: $Enums.ScheduleCategory | null
    clinicId?: string | null
    productId?: string | null
    recurrence?: $Enums.RecurrencePattern | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleCreateOrConnectWithoutAdInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutAdInput, ScheduleUncheckedCreateWithoutAdInput>
  }

  export type ScheduleCreateManyAdInputEnvelope = {
    data: ScheduleCreateManyAdInput | ScheduleCreateManyAdInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAdsInput = {
    update: XOR<UserUpdateWithoutAdsInput, UserUncheckedUpdateWithoutAdsInput>
    create: XOR<UserCreateWithoutAdsInput, UserUncheckedCreateWithoutAdsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdsInput, UserUncheckedUpdateWithoutAdsInput>
  }

  export type UserUpdateWithoutAdsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaAccounts?: MetaAccountUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialMediaAccountUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    adsets?: AdSetUpdateManyWithoutUserNestedInput
    schedules?: ScheduleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    influencers?: InfluencerUpdateManyWithoutUserNestedInput
    clinics?: ClinicUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaAccounts?: MetaAccountUncheckedUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialMediaAccountUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    adsets?: AdSetUncheckedUpdateManyWithoutUserNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    influencers?: InfluencerUncheckedUpdateManyWithoutUserNestedInput
    clinics?: ClinicUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AdSetUpsertWithoutAdsInput = {
    update: XOR<AdSetUpdateWithoutAdsInput, AdSetUncheckedUpdateWithoutAdsInput>
    create: XOR<AdSetCreateWithoutAdsInput, AdSetUncheckedCreateWithoutAdsInput>
    where?: AdSetWhereInput
  }

  export type AdSetUpdateToOneWithWhereWithoutAdsInput = {
    where?: AdSetWhereInput
    data: XOR<AdSetUpdateWithoutAdsInput, AdSetUncheckedUpdateWithoutAdsInput>
  }

  export type AdSetUpdateWithoutAdsInput = {
    id?: StringFieldUpdateOperationsInput | string
    adSetId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAdSetStatusFieldUpdateOperationsInput | $Enums.AdSetStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    bidStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    bidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targeting?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdsetsNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutAdSetsNestedInput
    metaAccount?: MetaAccountUpdateOneWithoutAdSetsNestedInput
    metrics?: AdSetMetricsUpdateManyWithoutAdSetNestedInput
  }

  export type AdSetUncheckedUpdateWithoutAdsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    metaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    adSetId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAdSetStatusFieldUpdateOperationsInput | $Enums.AdSetStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    bidStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    bidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targeting?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: AdSetMetricsUncheckedUpdateManyWithoutAdSetNestedInput
  }

  export type MetaAccountUpsertWithoutAdsInput = {
    update: XOR<MetaAccountUpdateWithoutAdsInput, MetaAccountUncheckedUpdateWithoutAdsInput>
    create: XOR<MetaAccountCreateWithoutAdsInput, MetaAccountUncheckedCreateWithoutAdsInput>
    where?: MetaAccountWhereInput
  }

  export type MetaAccountUpdateToOneWithWhereWithoutAdsInput = {
    where?: MetaAccountWhereInput
    data: XOR<MetaAccountUpdateWithoutAdsInput, MetaAccountUncheckedUpdateWithoutAdsInput>
  }

  export type MetaAccountUpdateWithoutAdsInput = {
    id?: StringFieldUpdateOperationsInput | string
    metaAccountId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMetaAccountsNestedInput
    campaigns?: CampaignUpdateManyWithoutMetaAccountNestedInput
    adSets?: AdSetUpdateManyWithoutMetaAccountNestedInput
    adAccounts?: AdAccountUpdateManyWithoutMetaAccountNestedInput
  }

  export type MetaAccountUncheckedUpdateWithoutAdsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    metaAccountId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUncheckedUpdateManyWithoutMetaAccountNestedInput
    adSets?: AdSetUncheckedUpdateManyWithoutMetaAccountNestedInput
    adAccounts?: AdAccountUncheckedUpdateManyWithoutMetaAccountNestedInput
  }

  export type AdMetricsUpsertWithWhereUniqueWithoutAdInput = {
    where: AdMetricsWhereUniqueInput
    update: XOR<AdMetricsUpdateWithoutAdInput, AdMetricsUncheckedUpdateWithoutAdInput>
    create: XOR<AdMetricsCreateWithoutAdInput, AdMetricsUncheckedCreateWithoutAdInput>
  }

  export type AdMetricsUpdateWithWhereUniqueWithoutAdInput = {
    where: AdMetricsWhereUniqueInput
    data: XOR<AdMetricsUpdateWithoutAdInput, AdMetricsUncheckedUpdateWithoutAdInput>
  }

  export type AdMetricsUpdateManyWithWhereWithoutAdInput = {
    where: AdMetricsScalarWhereInput
    data: XOR<AdMetricsUpdateManyMutationInput, AdMetricsUncheckedUpdateManyWithoutAdInput>
  }

  export type AdMetricsScalarWhereInput = {
    AND?: AdMetricsScalarWhereInput | AdMetricsScalarWhereInput[]
    OR?: AdMetricsScalarWhereInput[]
    NOT?: AdMetricsScalarWhereInput | AdMetricsScalarWhereInput[]
    id?: StringFilter<"AdMetrics"> | string
    adId?: StringFilter<"AdMetrics"> | string
    date?: DateTimeFilter<"AdMetrics"> | Date | string
    impressions?: IntFilter<"AdMetrics"> | number
    clicks?: IntFilter<"AdMetrics"> | number
    reach?: IntFilter<"AdMetrics"> | number
    spend?: FloatFilter<"AdMetrics"> | number
    conversions?: IntFilter<"AdMetrics"> | number
    costPerResult?: FloatNullableFilter<"AdMetrics"> | number | null
    ctr?: FloatNullableFilter<"AdMetrics"> | number | null
    cpc?: FloatNullableFilter<"AdMetrics"> | number | null
    cpm?: FloatNullableFilter<"AdMetrics"> | number | null
    frequency?: FloatNullableFilter<"AdMetrics"> | number | null
    engagements?: IntFilter<"AdMetrics"> | number
    shares?: IntFilter<"AdMetrics"> | number
    comments?: IntFilter<"AdMetrics"> | number
    saves?: IntFilter<"AdMetrics"> | number
  }

  export type ScheduleUpsertWithWhereUniqueWithoutAdInput = {
    where: ScheduleWhereUniqueInput
    update: XOR<ScheduleUpdateWithoutAdInput, ScheduleUncheckedUpdateWithoutAdInput>
    create: XOR<ScheduleCreateWithoutAdInput, ScheduleUncheckedCreateWithoutAdInput>
  }

  export type ScheduleUpdateWithWhereUniqueWithoutAdInput = {
    where: ScheduleWhereUniqueInput
    data: XOR<ScheduleUpdateWithoutAdInput, ScheduleUncheckedUpdateWithoutAdInput>
  }

  export type ScheduleUpdateManyWithWhereWithoutAdInput = {
    where: ScheduleScalarWhereInput
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyWithoutAdInput>
  }

  export type AdCreateWithoutMetricsInput = {
    id?: string
    adId?: string | null
    name: string
    status: $Enums.AdStatus
    headline?: string | null
    description?: string | null
    creativeType?: $Enums.CreativeType | null
    imageUrl?: string | null
    videoUrl?: string | null
    destinationUrl?: string | null
    callToAction?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAdsInput
    adSet: AdSetCreateNestedOneWithoutAdsInput
    metaAccount?: MetaAccountCreateNestedOneWithoutAdsInput
    schedules?: ScheduleCreateNestedManyWithoutAdInput
  }

  export type AdUncheckedCreateWithoutMetricsInput = {
    id?: string
    userId: string
    adSetId: string
    metaAccountId?: string | null
    adId?: string | null
    name: string
    status: $Enums.AdStatus
    headline?: string | null
    description?: string | null
    creativeType?: $Enums.CreativeType | null
    imageUrl?: string | null
    videoUrl?: string | null
    destinationUrl?: string | null
    callToAction?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleUncheckedCreateNestedManyWithoutAdInput
  }

  export type AdCreateOrConnectWithoutMetricsInput = {
    where: AdWhereUniqueInput
    create: XOR<AdCreateWithoutMetricsInput, AdUncheckedCreateWithoutMetricsInput>
  }

  export type AdUpsertWithoutMetricsInput = {
    update: XOR<AdUpdateWithoutMetricsInput, AdUncheckedUpdateWithoutMetricsInput>
    create: XOR<AdCreateWithoutMetricsInput, AdUncheckedCreateWithoutMetricsInput>
    where?: AdWhereInput
  }

  export type AdUpdateToOneWithWhereWithoutMetricsInput = {
    where?: AdWhereInput
    data: XOR<AdUpdateWithoutMetricsInput, AdUncheckedUpdateWithoutMetricsInput>
  }

  export type AdUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    adId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAdStatusFieldUpdateOperationsInput | $Enums.AdStatus
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creativeType?: NullableEnumCreativeTypeFieldUpdateOperationsInput | $Enums.CreativeType | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    destinationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    callToAction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdsNestedInput
    adSet?: AdSetUpdateOneRequiredWithoutAdsNestedInput
    metaAccount?: MetaAccountUpdateOneWithoutAdsNestedInput
    schedules?: ScheduleUpdateManyWithoutAdNestedInput
  }

  export type AdUncheckedUpdateWithoutMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    adSetId?: StringFieldUpdateOperationsInput | string
    metaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    adId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAdStatusFieldUpdateOperationsInput | $Enums.AdStatus
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creativeType?: NullableEnumCreativeTypeFieldUpdateOperationsInput | $Enums.CreativeType | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    destinationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    callToAction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUncheckedUpdateManyWithoutAdNestedInput
  }

  export type UserCreateWithoutSchedulesInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    metaAccounts?: MetaAccountCreateNestedManyWithoutUserInput
    socialAccounts?: SocialMediaAccountCreateNestedManyWithoutUserInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    adsets?: AdSetCreateNestedManyWithoutUserInput
    ads?: AdCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    influencers?: InfluencerCreateNestedManyWithoutUserInput
    clinics?: ClinicCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSchedulesInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    metaAccounts?: MetaAccountUncheckedCreateNestedManyWithoutUserInput
    socialAccounts?: SocialMediaAccountUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    adsets?: AdSetUncheckedCreateNestedManyWithoutUserInput
    ads?: AdUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    influencers?: InfluencerUncheckedCreateNestedManyWithoutUserInput
    clinics?: ClinicUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSchedulesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSchedulesInput, UserUncheckedCreateWithoutSchedulesInput>
  }

  export type AdCreateWithoutSchedulesInput = {
    id?: string
    adId?: string | null
    name: string
    status: $Enums.AdStatus
    headline?: string | null
    description?: string | null
    creativeType?: $Enums.CreativeType | null
    imageUrl?: string | null
    videoUrl?: string | null
    destinationUrl?: string | null
    callToAction?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAdsInput
    adSet: AdSetCreateNestedOneWithoutAdsInput
    metaAccount?: MetaAccountCreateNestedOneWithoutAdsInput
    metrics?: AdMetricsCreateNestedManyWithoutAdInput
  }

  export type AdUncheckedCreateWithoutSchedulesInput = {
    id?: string
    userId: string
    adSetId: string
    metaAccountId?: string | null
    adId?: string | null
    name: string
    status: $Enums.AdStatus
    headline?: string | null
    description?: string | null
    creativeType?: $Enums.CreativeType | null
    imageUrl?: string | null
    videoUrl?: string | null
    destinationUrl?: string | null
    callToAction?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metrics?: AdMetricsUncheckedCreateNestedManyWithoutAdInput
  }

  export type AdCreateOrConnectWithoutSchedulesInput = {
    where: AdWhereUniqueInput
    create: XOR<AdCreateWithoutSchedulesInput, AdUncheckedCreateWithoutSchedulesInput>
  }

  export type ClinicCreateWithoutSchedulesInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    featured?: boolean
    logoUrl?: string | null
    rating?: number | null
    reviewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutClinicsInput
    campaigns?: CampaignCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutSchedulesInput = {
    id?: string
    userId: string
    name: string
    address?: string | null
    city?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    featured?: boolean
    logoUrl?: string | null
    rating?: number | null
    reviewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutSchedulesInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutSchedulesInput, ClinicUncheckedCreateWithoutSchedulesInput>
  }

  export type ProductCreateWithoutSchedulesInput = {
    id?: string
    name: string
    description?: string | null
    price?: number | null
    sku?: string | null
    imageUrl?: string | null
    featured?: boolean
    category?: string | null
    stock?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProductsInput
    campaigns?: CampaignCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSchedulesInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    price?: number | null
    sku?: string | null
    imageUrl?: string | null
    featured?: boolean
    category?: string | null
    stock?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: CampaignUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSchedulesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSchedulesInput, ProductUncheckedCreateWithoutSchedulesInput>
  }

  export type UserUpsertWithoutSchedulesInput = {
    update: XOR<UserUpdateWithoutSchedulesInput, UserUncheckedUpdateWithoutSchedulesInput>
    create: XOR<UserCreateWithoutSchedulesInput, UserUncheckedCreateWithoutSchedulesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSchedulesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSchedulesInput, UserUncheckedUpdateWithoutSchedulesInput>
  }

  export type UserUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaAccounts?: MetaAccountUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialMediaAccountUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    adsets?: AdSetUpdateManyWithoutUserNestedInput
    ads?: AdUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    influencers?: InfluencerUpdateManyWithoutUserNestedInput
    clinics?: ClinicUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaAccounts?: MetaAccountUncheckedUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialMediaAccountUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    adsets?: AdSetUncheckedUpdateManyWithoutUserNestedInput
    ads?: AdUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    influencers?: InfluencerUncheckedUpdateManyWithoutUserNestedInput
    clinics?: ClinicUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AdUpsertWithoutSchedulesInput = {
    update: XOR<AdUpdateWithoutSchedulesInput, AdUncheckedUpdateWithoutSchedulesInput>
    create: XOR<AdCreateWithoutSchedulesInput, AdUncheckedCreateWithoutSchedulesInput>
    where?: AdWhereInput
  }

  export type AdUpdateToOneWithWhereWithoutSchedulesInput = {
    where?: AdWhereInput
    data: XOR<AdUpdateWithoutSchedulesInput, AdUncheckedUpdateWithoutSchedulesInput>
  }

  export type AdUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    adId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAdStatusFieldUpdateOperationsInput | $Enums.AdStatus
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creativeType?: NullableEnumCreativeTypeFieldUpdateOperationsInput | $Enums.CreativeType | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    destinationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    callToAction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdsNestedInput
    adSet?: AdSetUpdateOneRequiredWithoutAdsNestedInput
    metaAccount?: MetaAccountUpdateOneWithoutAdsNestedInput
    metrics?: AdMetricsUpdateManyWithoutAdNestedInput
  }

  export type AdUncheckedUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    adSetId?: StringFieldUpdateOperationsInput | string
    metaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    adId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAdStatusFieldUpdateOperationsInput | $Enums.AdStatus
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creativeType?: NullableEnumCreativeTypeFieldUpdateOperationsInput | $Enums.CreativeType | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    destinationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    callToAction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: AdMetricsUncheckedUpdateManyWithoutAdNestedInput
  }

  export type ClinicUpsertWithoutSchedulesInput = {
    update: XOR<ClinicUpdateWithoutSchedulesInput, ClinicUncheckedUpdateWithoutSchedulesInput>
    create: XOR<ClinicCreateWithoutSchedulesInput, ClinicUncheckedCreateWithoutSchedulesInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutSchedulesInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutSchedulesInput, ClinicUncheckedUpdateWithoutSchedulesInput>
  }

  export type ClinicUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutClinicsNestedInput
    campaigns?: CampaignUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type ProductUpsertWithoutSchedulesInput = {
    update: XOR<ProductUpdateWithoutSchedulesInput, ProductUncheckedUpdateWithoutSchedulesInput>
    create: XOR<ProductCreateWithoutSchedulesInput, ProductUncheckedCreateWithoutSchedulesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutSchedulesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutSchedulesInput, ProductUncheckedUpdateWithoutSchedulesInput>
  }

  export type ProductUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProductsNestedInput
    campaigns?: CampaignUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUncheckedUpdateManyWithoutProductNestedInput
  }

  export type PlannerItemCreateWithoutPlannerInput = {
    id?: string
    title: string
    description?: string | null
    platform: $Enums.PlatformType
    format?: string | null
    budget?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: $Enums.PlannerItemStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlannerItemUncheckedCreateWithoutPlannerInput = {
    id?: string
    title: string
    description?: string | null
    platform: $Enums.PlatformType
    format?: string | null
    budget?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: $Enums.PlannerItemStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlannerItemCreateOrConnectWithoutPlannerInput = {
    where: PlannerItemWhereUniqueInput
    create: XOR<PlannerItemCreateWithoutPlannerInput, PlannerItemUncheckedCreateWithoutPlannerInput>
  }

  export type PlannerItemCreateManyPlannerInputEnvelope = {
    data: PlannerItemCreateManyPlannerInput | PlannerItemCreateManyPlannerInput[]
    skipDuplicates?: boolean
  }

  export type PlannerItemUpsertWithWhereUniqueWithoutPlannerInput = {
    where: PlannerItemWhereUniqueInput
    update: XOR<PlannerItemUpdateWithoutPlannerInput, PlannerItemUncheckedUpdateWithoutPlannerInput>
    create: XOR<PlannerItemCreateWithoutPlannerInput, PlannerItemUncheckedCreateWithoutPlannerInput>
  }

  export type PlannerItemUpdateWithWhereUniqueWithoutPlannerInput = {
    where: PlannerItemWhereUniqueInput
    data: XOR<PlannerItemUpdateWithoutPlannerInput, PlannerItemUncheckedUpdateWithoutPlannerInput>
  }

  export type PlannerItemUpdateManyWithWhereWithoutPlannerInput = {
    where: PlannerItemScalarWhereInput
    data: XOR<PlannerItemUpdateManyMutationInput, PlannerItemUncheckedUpdateManyWithoutPlannerInput>
  }

  export type PlannerItemScalarWhereInput = {
    AND?: PlannerItemScalarWhereInput | PlannerItemScalarWhereInput[]
    OR?: PlannerItemScalarWhereInput[]
    NOT?: PlannerItemScalarWhereInput | PlannerItemScalarWhereInput[]
    id?: StringFilter<"PlannerItem"> | string
    plannerId?: StringFilter<"PlannerItem"> | string
    title?: StringFilter<"PlannerItem"> | string
    description?: StringNullableFilter<"PlannerItem"> | string | null
    platform?: EnumPlatformTypeFilter<"PlannerItem"> | $Enums.PlatformType
    format?: StringNullableFilter<"PlannerItem"> | string | null
    budget?: FloatNullableFilter<"PlannerItem"> | number | null
    startDate?: DateTimeNullableFilter<"PlannerItem"> | Date | string | null
    endDate?: DateTimeNullableFilter<"PlannerItem"> | Date | string | null
    status?: EnumPlannerItemStatusFilter<"PlannerItem"> | $Enums.PlannerItemStatus
    createdAt?: DateTimeFilter<"PlannerItem"> | Date | string
    updatedAt?: DateTimeFilter<"PlannerItem"> | Date | string
  }

  export type AdsPlannerCreateWithoutPlanItemsInput = {
    id?: string
    name: string
    description?: string | null
    objective: $Enums.CampaignObjective
    budgetType: $Enums.BudgetType
    budgetAmount: number
    whatsappNumber?: string | null
    startDate: Date | string
    endDate: Date | string
    location?: string | null
    minAge?: number | null
    maxAge?: number | null
    gender?: $Enums.GenderTarget | null
    detailTargeting?: string | null
    videoUrl?: string | null
    websiteUrl?: string | null
    primaryText?: string | null
    headline?: string | null
    ctaName?: string | null
    ctaText?: string | null
    preFilledMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdsPlannerUncheckedCreateWithoutPlanItemsInput = {
    id?: string
    name: string
    description?: string | null
    objective: $Enums.CampaignObjective
    budgetType: $Enums.BudgetType
    budgetAmount: number
    whatsappNumber?: string | null
    startDate: Date | string
    endDate: Date | string
    location?: string | null
    minAge?: number | null
    maxAge?: number | null
    gender?: $Enums.GenderTarget | null
    detailTargeting?: string | null
    videoUrl?: string | null
    websiteUrl?: string | null
    primaryText?: string | null
    headline?: string | null
    ctaName?: string | null
    ctaText?: string | null
    preFilledMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdsPlannerCreateOrConnectWithoutPlanItemsInput = {
    where: AdsPlannerWhereUniqueInput
    create: XOR<AdsPlannerCreateWithoutPlanItemsInput, AdsPlannerUncheckedCreateWithoutPlanItemsInput>
  }

  export type AdsPlannerUpsertWithoutPlanItemsInput = {
    update: XOR<AdsPlannerUpdateWithoutPlanItemsInput, AdsPlannerUncheckedUpdateWithoutPlanItemsInput>
    create: XOR<AdsPlannerCreateWithoutPlanItemsInput, AdsPlannerUncheckedCreateWithoutPlanItemsInput>
    where?: AdsPlannerWhereInput
  }

  export type AdsPlannerUpdateToOneWithWhereWithoutPlanItemsInput = {
    where?: AdsPlannerWhereInput
    data: XOR<AdsPlannerUpdateWithoutPlanItemsInput, AdsPlannerUncheckedUpdateWithoutPlanItemsInput>
  }

  export type AdsPlannerUpdateWithoutPlanItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objective?: EnumCampaignObjectiveFieldUpdateOperationsInput | $Enums.CampaignObjective
    budgetType?: EnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType
    budgetAmount?: FloatFieldUpdateOperationsInput | number
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    minAge?: NullableIntFieldUpdateOperationsInput | number | null
    maxAge?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableEnumGenderTargetFieldUpdateOperationsInput | $Enums.GenderTarget | null
    detailTargeting?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryText?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    ctaName?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    preFilledMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdsPlannerUncheckedUpdateWithoutPlanItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    objective?: EnumCampaignObjectiveFieldUpdateOperationsInput | $Enums.CampaignObjective
    budgetType?: EnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType
    budgetAmount?: FloatFieldUpdateOperationsInput | number
    whatsappNumber?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    minAge?: NullableIntFieldUpdateOperationsInput | number | null
    maxAge?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableEnumGenderTargetFieldUpdateOperationsInput | $Enums.GenderTarget | null
    detailTargeting?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryText?: NullableStringFieldUpdateOperationsInput | string | null
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    ctaName?: NullableStringFieldUpdateOperationsInput | string | null
    ctaText?: NullableStringFieldUpdateOperationsInput | string | null
    preFilledMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutSocialAccountsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    metaAccounts?: MetaAccountCreateNestedManyWithoutUserInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    adsets?: AdSetCreateNestedManyWithoutUserInput
    ads?: AdCreateNestedManyWithoutUserInput
    schedules?: ScheduleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    influencers?: InfluencerCreateNestedManyWithoutUserInput
    clinics?: ClinicCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSocialAccountsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    metaAccounts?: MetaAccountUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    adsets?: AdSetUncheckedCreateNestedManyWithoutUserInput
    ads?: AdUncheckedCreateNestedManyWithoutUserInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    influencers?: InfluencerUncheckedCreateNestedManyWithoutUserInput
    clinics?: ClinicUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSocialAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSocialAccountsInput, UserUncheckedCreateWithoutSocialAccountsInput>
  }

  export type PlatformMetricsCreateWithoutAccountInput = {
    id?: string
    date: Date | string
    followers?: number
    following?: number
    posts?: number
    impressions?: number
    reach?: number
    profileViews?: number
    websiteClicks?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformMetricsUncheckedCreateWithoutAccountInput = {
    id?: string
    date: Date | string
    followers?: number
    following?: number
    posts?: number
    impressions?: number
    reach?: number
    profileViews?: number
    websiteClicks?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformMetricsCreateOrConnectWithoutAccountInput = {
    where: PlatformMetricsWhereUniqueInput
    create: XOR<PlatformMetricsCreateWithoutAccountInput, PlatformMetricsUncheckedCreateWithoutAccountInput>
  }

  export type PlatformMetricsCreateManyAccountInputEnvelope = {
    data: PlatformMetricsCreateManyAccountInput | PlatformMetricsCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type EngagementMetricsCreateWithoutAccountInput = {
    id?: string
    date: Date | string
    likes?: number
    comments?: number
    shares?: number
    saves?: number
    clicks?: number
    engagementRate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EngagementMetricsUncheckedCreateWithoutAccountInput = {
    id?: string
    date: Date | string
    likes?: number
    comments?: number
    shares?: number
    saves?: number
    clicks?: number
    engagementRate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EngagementMetricsCreateOrConnectWithoutAccountInput = {
    where: EngagementMetricsWhereUniqueInput
    create: XOR<EngagementMetricsCreateWithoutAccountInput, EngagementMetricsUncheckedCreateWithoutAccountInput>
  }

  export type EngagementMetricsCreateManyAccountInputEnvelope = {
    data: EngagementMetricsCreateManyAccountInput | EngagementMetricsCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type InfluencerCreateWithoutAccountInput = {
    id?: string
    name: string
    contactInfo?: string | null
    reach?: number
    engagementRate?: number | null
    niche?: string | null
    cost?: number | null
    status?: $Enums.InfluencerStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInfluencersInput
    campaigns?: InfluencerCampaignsCreateNestedManyWithoutInfluencerInput
  }

  export type InfluencerUncheckedCreateWithoutAccountInput = {
    id?: string
    userId: string
    name: string
    contactInfo?: string | null
    reach?: number
    engagementRate?: number | null
    niche?: string | null
    cost?: number | null
    status?: $Enums.InfluencerStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaigns?: InfluencerCampaignsUncheckedCreateNestedManyWithoutInfluencerInput
  }

  export type InfluencerCreateOrConnectWithoutAccountInput = {
    where: InfluencerWhereUniqueInput
    create: XOR<InfluencerCreateWithoutAccountInput, InfluencerUncheckedCreateWithoutAccountInput>
  }

  export type InfluencerCreateManyAccountInputEnvelope = {
    data: InfluencerCreateManyAccountInput | InfluencerCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSocialAccountsInput = {
    update: XOR<UserUpdateWithoutSocialAccountsInput, UserUncheckedUpdateWithoutSocialAccountsInput>
    create: XOR<UserCreateWithoutSocialAccountsInput, UserUncheckedCreateWithoutSocialAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSocialAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSocialAccountsInput, UserUncheckedUpdateWithoutSocialAccountsInput>
  }

  export type UserUpdateWithoutSocialAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaAccounts?: MetaAccountUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    adsets?: AdSetUpdateManyWithoutUserNestedInput
    ads?: AdUpdateManyWithoutUserNestedInput
    schedules?: ScheduleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    influencers?: InfluencerUpdateManyWithoutUserNestedInput
    clinics?: ClinicUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSocialAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaAccounts?: MetaAccountUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    adsets?: AdSetUncheckedUpdateManyWithoutUserNestedInput
    ads?: AdUncheckedUpdateManyWithoutUserNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    influencers?: InfluencerUncheckedUpdateManyWithoutUserNestedInput
    clinics?: ClinicUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PlatformMetricsUpsertWithWhereUniqueWithoutAccountInput = {
    where: PlatformMetricsWhereUniqueInput
    update: XOR<PlatformMetricsUpdateWithoutAccountInput, PlatformMetricsUncheckedUpdateWithoutAccountInput>
    create: XOR<PlatformMetricsCreateWithoutAccountInput, PlatformMetricsUncheckedCreateWithoutAccountInput>
  }

  export type PlatformMetricsUpdateWithWhereUniqueWithoutAccountInput = {
    where: PlatformMetricsWhereUniqueInput
    data: XOR<PlatformMetricsUpdateWithoutAccountInput, PlatformMetricsUncheckedUpdateWithoutAccountInput>
  }

  export type PlatformMetricsUpdateManyWithWhereWithoutAccountInput = {
    where: PlatformMetricsScalarWhereInput
    data: XOR<PlatformMetricsUpdateManyMutationInput, PlatformMetricsUncheckedUpdateManyWithoutAccountInput>
  }

  export type PlatformMetricsScalarWhereInput = {
    AND?: PlatformMetricsScalarWhereInput | PlatformMetricsScalarWhereInput[]
    OR?: PlatformMetricsScalarWhereInput[]
    NOT?: PlatformMetricsScalarWhereInput | PlatformMetricsScalarWhereInput[]
    id?: StringFilter<"PlatformMetrics"> | string
    accountId?: StringFilter<"PlatformMetrics"> | string
    date?: DateTimeFilter<"PlatformMetrics"> | Date | string
    followers?: IntFilter<"PlatformMetrics"> | number
    following?: IntFilter<"PlatformMetrics"> | number
    posts?: IntFilter<"PlatformMetrics"> | number
    impressions?: IntFilter<"PlatformMetrics"> | number
    reach?: IntFilter<"PlatformMetrics"> | number
    profileViews?: IntFilter<"PlatformMetrics"> | number
    websiteClicks?: IntFilter<"PlatformMetrics"> | number
    createdAt?: DateTimeFilter<"PlatformMetrics"> | Date | string
    updatedAt?: DateTimeFilter<"PlatformMetrics"> | Date | string
  }

  export type EngagementMetricsUpsertWithWhereUniqueWithoutAccountInput = {
    where: EngagementMetricsWhereUniqueInput
    update: XOR<EngagementMetricsUpdateWithoutAccountInput, EngagementMetricsUncheckedUpdateWithoutAccountInput>
    create: XOR<EngagementMetricsCreateWithoutAccountInput, EngagementMetricsUncheckedCreateWithoutAccountInput>
  }

  export type EngagementMetricsUpdateWithWhereUniqueWithoutAccountInput = {
    where: EngagementMetricsWhereUniqueInput
    data: XOR<EngagementMetricsUpdateWithoutAccountInput, EngagementMetricsUncheckedUpdateWithoutAccountInput>
  }

  export type EngagementMetricsUpdateManyWithWhereWithoutAccountInput = {
    where: EngagementMetricsScalarWhereInput
    data: XOR<EngagementMetricsUpdateManyMutationInput, EngagementMetricsUncheckedUpdateManyWithoutAccountInput>
  }

  export type EngagementMetricsScalarWhereInput = {
    AND?: EngagementMetricsScalarWhereInput | EngagementMetricsScalarWhereInput[]
    OR?: EngagementMetricsScalarWhereInput[]
    NOT?: EngagementMetricsScalarWhereInput | EngagementMetricsScalarWhereInput[]
    id?: StringFilter<"EngagementMetrics"> | string
    accountId?: StringFilter<"EngagementMetrics"> | string
    date?: DateTimeFilter<"EngagementMetrics"> | Date | string
    likes?: IntFilter<"EngagementMetrics"> | number
    comments?: IntFilter<"EngagementMetrics"> | number
    shares?: IntFilter<"EngagementMetrics"> | number
    saves?: IntFilter<"EngagementMetrics"> | number
    clicks?: IntFilter<"EngagementMetrics"> | number
    engagementRate?: FloatNullableFilter<"EngagementMetrics"> | number | null
    createdAt?: DateTimeFilter<"EngagementMetrics"> | Date | string
    updatedAt?: DateTimeFilter<"EngagementMetrics"> | Date | string
  }

  export type InfluencerUpsertWithWhereUniqueWithoutAccountInput = {
    where: InfluencerWhereUniqueInput
    update: XOR<InfluencerUpdateWithoutAccountInput, InfluencerUncheckedUpdateWithoutAccountInput>
    create: XOR<InfluencerCreateWithoutAccountInput, InfluencerUncheckedCreateWithoutAccountInput>
  }

  export type InfluencerUpdateWithWhereUniqueWithoutAccountInput = {
    where: InfluencerWhereUniqueInput
    data: XOR<InfluencerUpdateWithoutAccountInput, InfluencerUncheckedUpdateWithoutAccountInput>
  }

  export type InfluencerUpdateManyWithWhereWithoutAccountInput = {
    where: InfluencerScalarWhereInput
    data: XOR<InfluencerUpdateManyMutationInput, InfluencerUncheckedUpdateManyWithoutAccountInput>
  }

  export type SocialMediaAccountCreateWithoutPlatformMetricsInput = {
    id?: string
    platform: $Enums.PlatformType
    accountName: string
    accountId?: string | null
    followers?: number
    accessToken?: string | null
    tokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSocialAccountsInput
    engagementMetrics?: EngagementMetricsCreateNestedManyWithoutAccountInput
    influencers?: InfluencerCreateNestedManyWithoutAccountInput
  }

  export type SocialMediaAccountUncheckedCreateWithoutPlatformMetricsInput = {
    id?: string
    userId: string
    platform: $Enums.PlatformType
    accountName: string
    accountId?: string | null
    followers?: number
    accessToken?: string | null
    tokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    engagementMetrics?: EngagementMetricsUncheckedCreateNestedManyWithoutAccountInput
    influencers?: InfluencerUncheckedCreateNestedManyWithoutAccountInput
  }

  export type SocialMediaAccountCreateOrConnectWithoutPlatformMetricsInput = {
    where: SocialMediaAccountWhereUniqueInput
    create: XOR<SocialMediaAccountCreateWithoutPlatformMetricsInput, SocialMediaAccountUncheckedCreateWithoutPlatformMetricsInput>
  }

  export type SocialMediaAccountUpsertWithoutPlatformMetricsInput = {
    update: XOR<SocialMediaAccountUpdateWithoutPlatformMetricsInput, SocialMediaAccountUncheckedUpdateWithoutPlatformMetricsInput>
    create: XOR<SocialMediaAccountCreateWithoutPlatformMetricsInput, SocialMediaAccountUncheckedCreateWithoutPlatformMetricsInput>
    where?: SocialMediaAccountWhereInput
  }

  export type SocialMediaAccountUpdateToOneWithWhereWithoutPlatformMetricsInput = {
    where?: SocialMediaAccountWhereInput
    data: XOR<SocialMediaAccountUpdateWithoutPlatformMetricsInput, SocialMediaAccountUncheckedUpdateWithoutPlatformMetricsInput>
  }

  export type SocialMediaAccountUpdateWithoutPlatformMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | $Enums.PlatformType
    accountName?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    followers?: IntFieldUpdateOperationsInput | number
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSocialAccountsNestedInput
    engagementMetrics?: EngagementMetricsUpdateManyWithoutAccountNestedInput
    influencers?: InfluencerUpdateManyWithoutAccountNestedInput
  }

  export type SocialMediaAccountUncheckedUpdateWithoutPlatformMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | $Enums.PlatformType
    accountName?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    followers?: IntFieldUpdateOperationsInput | number
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    engagementMetrics?: EngagementMetricsUncheckedUpdateManyWithoutAccountNestedInput
    influencers?: InfluencerUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type SocialMediaAccountCreateWithoutEngagementMetricsInput = {
    id?: string
    platform: $Enums.PlatformType
    accountName: string
    accountId?: string | null
    followers?: number
    accessToken?: string | null
    tokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSocialAccountsInput
    platformMetrics?: PlatformMetricsCreateNestedManyWithoutAccountInput
    influencers?: InfluencerCreateNestedManyWithoutAccountInput
  }

  export type SocialMediaAccountUncheckedCreateWithoutEngagementMetricsInput = {
    id?: string
    userId: string
    platform: $Enums.PlatformType
    accountName: string
    accountId?: string | null
    followers?: number
    accessToken?: string | null
    tokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    platformMetrics?: PlatformMetricsUncheckedCreateNestedManyWithoutAccountInput
    influencers?: InfluencerUncheckedCreateNestedManyWithoutAccountInput
  }

  export type SocialMediaAccountCreateOrConnectWithoutEngagementMetricsInput = {
    where: SocialMediaAccountWhereUniqueInput
    create: XOR<SocialMediaAccountCreateWithoutEngagementMetricsInput, SocialMediaAccountUncheckedCreateWithoutEngagementMetricsInput>
  }

  export type SocialMediaAccountUpsertWithoutEngagementMetricsInput = {
    update: XOR<SocialMediaAccountUpdateWithoutEngagementMetricsInput, SocialMediaAccountUncheckedUpdateWithoutEngagementMetricsInput>
    create: XOR<SocialMediaAccountCreateWithoutEngagementMetricsInput, SocialMediaAccountUncheckedCreateWithoutEngagementMetricsInput>
    where?: SocialMediaAccountWhereInput
  }

  export type SocialMediaAccountUpdateToOneWithWhereWithoutEngagementMetricsInput = {
    where?: SocialMediaAccountWhereInput
    data: XOR<SocialMediaAccountUpdateWithoutEngagementMetricsInput, SocialMediaAccountUncheckedUpdateWithoutEngagementMetricsInput>
  }

  export type SocialMediaAccountUpdateWithoutEngagementMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | $Enums.PlatformType
    accountName?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    followers?: IntFieldUpdateOperationsInput | number
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSocialAccountsNestedInput
    platformMetrics?: PlatformMetricsUpdateManyWithoutAccountNestedInput
    influencers?: InfluencerUpdateManyWithoutAccountNestedInput
  }

  export type SocialMediaAccountUncheckedUpdateWithoutEngagementMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | $Enums.PlatformType
    accountName?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    followers?: IntFieldUpdateOperationsInput | number
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platformMetrics?: PlatformMetricsUncheckedUpdateManyWithoutAccountNestedInput
    influencers?: InfluencerUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type UserCreateWithoutInfluencersInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    metaAccounts?: MetaAccountCreateNestedManyWithoutUserInput
    socialAccounts?: SocialMediaAccountCreateNestedManyWithoutUserInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    adsets?: AdSetCreateNestedManyWithoutUserInput
    ads?: AdCreateNestedManyWithoutUserInput
    schedules?: ScheduleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    clinics?: ClinicCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInfluencersInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    metaAccounts?: MetaAccountUncheckedCreateNestedManyWithoutUserInput
    socialAccounts?: SocialMediaAccountUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    adsets?: AdSetUncheckedCreateNestedManyWithoutUserInput
    ads?: AdUncheckedCreateNestedManyWithoutUserInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    clinics?: ClinicUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInfluencersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInfluencersInput, UserUncheckedCreateWithoutInfluencersInput>
  }

  export type SocialMediaAccountCreateWithoutInfluencersInput = {
    id?: string
    platform: $Enums.PlatformType
    accountName: string
    accountId?: string | null
    followers?: number
    accessToken?: string | null
    tokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSocialAccountsInput
    platformMetrics?: PlatformMetricsCreateNestedManyWithoutAccountInput
    engagementMetrics?: EngagementMetricsCreateNestedManyWithoutAccountInput
  }

  export type SocialMediaAccountUncheckedCreateWithoutInfluencersInput = {
    id?: string
    userId: string
    platform: $Enums.PlatformType
    accountName: string
    accountId?: string | null
    followers?: number
    accessToken?: string | null
    tokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    platformMetrics?: PlatformMetricsUncheckedCreateNestedManyWithoutAccountInput
    engagementMetrics?: EngagementMetricsUncheckedCreateNestedManyWithoutAccountInput
  }

  export type SocialMediaAccountCreateOrConnectWithoutInfluencersInput = {
    where: SocialMediaAccountWhereUniqueInput
    create: XOR<SocialMediaAccountCreateWithoutInfluencersInput, SocialMediaAccountUncheckedCreateWithoutInfluencersInput>
  }

  export type InfluencerCampaignsCreateWithoutInfluencerInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate?: Date | string | null
    budget: number
    results?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.InfluencerCampaignStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InfluencerCampaignsUncheckedCreateWithoutInfluencerInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate?: Date | string | null
    budget: number
    results?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.InfluencerCampaignStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InfluencerCampaignsCreateOrConnectWithoutInfluencerInput = {
    where: InfluencerCampaignsWhereUniqueInput
    create: XOR<InfluencerCampaignsCreateWithoutInfluencerInput, InfluencerCampaignsUncheckedCreateWithoutInfluencerInput>
  }

  export type InfluencerCampaignsCreateManyInfluencerInputEnvelope = {
    data: InfluencerCampaignsCreateManyInfluencerInput | InfluencerCampaignsCreateManyInfluencerInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutInfluencersInput = {
    update: XOR<UserUpdateWithoutInfluencersInput, UserUncheckedUpdateWithoutInfluencersInput>
    create: XOR<UserCreateWithoutInfluencersInput, UserUncheckedCreateWithoutInfluencersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInfluencersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInfluencersInput, UserUncheckedUpdateWithoutInfluencersInput>
  }

  export type UserUpdateWithoutInfluencersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaAccounts?: MetaAccountUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialMediaAccountUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    adsets?: AdSetUpdateManyWithoutUserNestedInput
    ads?: AdUpdateManyWithoutUserNestedInput
    schedules?: ScheduleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    clinics?: ClinicUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInfluencersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaAccounts?: MetaAccountUncheckedUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialMediaAccountUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    adsets?: AdSetUncheckedUpdateManyWithoutUserNestedInput
    ads?: AdUncheckedUpdateManyWithoutUserNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    clinics?: ClinicUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SocialMediaAccountUpsertWithoutInfluencersInput = {
    update: XOR<SocialMediaAccountUpdateWithoutInfluencersInput, SocialMediaAccountUncheckedUpdateWithoutInfluencersInput>
    create: XOR<SocialMediaAccountCreateWithoutInfluencersInput, SocialMediaAccountUncheckedCreateWithoutInfluencersInput>
    where?: SocialMediaAccountWhereInput
  }

  export type SocialMediaAccountUpdateToOneWithWhereWithoutInfluencersInput = {
    where?: SocialMediaAccountWhereInput
    data: XOR<SocialMediaAccountUpdateWithoutInfluencersInput, SocialMediaAccountUncheckedUpdateWithoutInfluencersInput>
  }

  export type SocialMediaAccountUpdateWithoutInfluencersInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | $Enums.PlatformType
    accountName?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    followers?: IntFieldUpdateOperationsInput | number
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSocialAccountsNestedInput
    platformMetrics?: PlatformMetricsUpdateManyWithoutAccountNestedInput
    engagementMetrics?: EngagementMetricsUpdateManyWithoutAccountNestedInput
  }

  export type SocialMediaAccountUncheckedUpdateWithoutInfluencersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | $Enums.PlatformType
    accountName?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    followers?: IntFieldUpdateOperationsInput | number
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platformMetrics?: PlatformMetricsUncheckedUpdateManyWithoutAccountNestedInput
    engagementMetrics?: EngagementMetricsUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type InfluencerCampaignsUpsertWithWhereUniqueWithoutInfluencerInput = {
    where: InfluencerCampaignsWhereUniqueInput
    update: XOR<InfluencerCampaignsUpdateWithoutInfluencerInput, InfluencerCampaignsUncheckedUpdateWithoutInfluencerInput>
    create: XOR<InfluencerCampaignsCreateWithoutInfluencerInput, InfluencerCampaignsUncheckedCreateWithoutInfluencerInput>
  }

  export type InfluencerCampaignsUpdateWithWhereUniqueWithoutInfluencerInput = {
    where: InfluencerCampaignsWhereUniqueInput
    data: XOR<InfluencerCampaignsUpdateWithoutInfluencerInput, InfluencerCampaignsUncheckedUpdateWithoutInfluencerInput>
  }

  export type InfluencerCampaignsUpdateManyWithWhereWithoutInfluencerInput = {
    where: InfluencerCampaignsScalarWhereInput
    data: XOR<InfluencerCampaignsUpdateManyMutationInput, InfluencerCampaignsUncheckedUpdateManyWithoutInfluencerInput>
  }

  export type InfluencerCampaignsScalarWhereInput = {
    AND?: InfluencerCampaignsScalarWhereInput | InfluencerCampaignsScalarWhereInput[]
    OR?: InfluencerCampaignsScalarWhereInput[]
    NOT?: InfluencerCampaignsScalarWhereInput | InfluencerCampaignsScalarWhereInput[]
    id?: StringFilter<"InfluencerCampaigns"> | string
    influencerId?: StringFilter<"InfluencerCampaigns"> | string
    name?: StringFilter<"InfluencerCampaigns"> | string
    startDate?: DateTimeFilter<"InfluencerCampaigns"> | Date | string
    endDate?: DateTimeNullableFilter<"InfluencerCampaigns"> | Date | string | null
    budget?: FloatFilter<"InfluencerCampaigns"> | number
    results?: JsonNullableFilter<"InfluencerCampaigns">
    status?: EnumInfluencerCampaignStatusFilter<"InfluencerCampaigns"> | $Enums.InfluencerCampaignStatus
    createdAt?: DateTimeFilter<"InfluencerCampaigns"> | Date | string
    updatedAt?: DateTimeFilter<"InfluencerCampaigns"> | Date | string
  }

  export type InfluencerCreateWithoutCampaignsInput = {
    id?: string
    name: string
    contactInfo?: string | null
    reach?: number
    engagementRate?: number | null
    niche?: string | null
    cost?: number | null
    status?: $Enums.InfluencerStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInfluencersInput
    account: SocialMediaAccountCreateNestedOneWithoutInfluencersInput
  }

  export type InfluencerUncheckedCreateWithoutCampaignsInput = {
    id?: string
    userId: string
    accountId: string
    name: string
    contactInfo?: string | null
    reach?: number
    engagementRate?: number | null
    niche?: string | null
    cost?: number | null
    status?: $Enums.InfluencerStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InfluencerCreateOrConnectWithoutCampaignsInput = {
    where: InfluencerWhereUniqueInput
    create: XOR<InfluencerCreateWithoutCampaignsInput, InfluencerUncheckedCreateWithoutCampaignsInput>
  }

  export type InfluencerUpsertWithoutCampaignsInput = {
    update: XOR<InfluencerUpdateWithoutCampaignsInput, InfluencerUncheckedUpdateWithoutCampaignsInput>
    create: XOR<InfluencerCreateWithoutCampaignsInput, InfluencerUncheckedCreateWithoutCampaignsInput>
    where?: InfluencerWhereInput
  }

  export type InfluencerUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: InfluencerWhereInput
    data: XOR<InfluencerUpdateWithoutCampaignsInput, InfluencerUncheckedUpdateWithoutCampaignsInput>
  }

  export type InfluencerUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    reach?: IntFieldUpdateOperationsInput | number
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    niche?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumInfluencerStatusFieldUpdateOperationsInput | $Enums.InfluencerStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInfluencersNestedInput
    account?: SocialMediaAccountUpdateOneRequiredWithoutInfluencersNestedInput
  }

  export type InfluencerUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    reach?: IntFieldUpdateOperationsInput | number
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    niche?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumInfluencerStatusFieldUpdateOperationsInput | $Enums.InfluencerStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutClinicsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    metaAccounts?: MetaAccountCreateNestedManyWithoutUserInput
    socialAccounts?: SocialMediaAccountCreateNestedManyWithoutUserInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    adsets?: AdSetCreateNestedManyWithoutUserInput
    ads?: AdCreateNestedManyWithoutUserInput
    schedules?: ScheduleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    influencers?: InfluencerCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClinicsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    metaAccounts?: MetaAccountUncheckedCreateNestedManyWithoutUserInput
    socialAccounts?: SocialMediaAccountUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    adsets?: AdSetUncheckedCreateNestedManyWithoutUserInput
    ads?: AdUncheckedCreateNestedManyWithoutUserInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    influencers?: InfluencerUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClinicsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClinicsInput, UserUncheckedCreateWithoutClinicsInput>
  }

  export type ScheduleCreateWithoutClinicInput = {
    id?: string
    title: string
    startDate: Date | string
    endDate: Date | string
    status: $Enums.ScheduleStatus
    priority?: $Enums.SchedulePriority
    category?: $Enums.ScheduleCategory | null
    recurrence?: $Enums.RecurrencePattern | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSchedulesInput
    ad?: AdCreateNestedOneWithoutSchedulesInput
    product?: ProductCreateNestedOneWithoutSchedulesInput
  }

  export type ScheduleUncheckedCreateWithoutClinicInput = {
    id?: string
    userId: string
    adId?: string | null
    title: string
    startDate: Date | string
    endDate: Date | string
    status: $Enums.ScheduleStatus
    priority?: $Enums.SchedulePriority
    category?: $Enums.ScheduleCategory | null
    productId?: string | null
    recurrence?: $Enums.RecurrencePattern | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleCreateOrConnectWithoutClinicInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutClinicInput, ScheduleUncheckedCreateWithoutClinicInput>
  }

  export type ScheduleCreateManyClinicInputEnvelope = {
    data: ScheduleCreateManyClinicInput | ScheduleCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type CampaignCreateWithoutClinicInput = {
    id?: string
    campaignId?: string | null
    name: string
    objective: string
    status: $Enums.CampaignStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCampaignsInput
    metaAccount?: MetaAccountCreateNestedOneWithoutCampaignsInput
    adAccount?: AdAccountCreateNestedOneWithoutCampaignsInput
    adSets?: AdSetCreateNestedManyWithoutCampaignInput
    tags?: TagsOnCampaignsCreateNestedManyWithoutCampaignInput
    metrics?: CampaignMetricsCreateNestedManyWithoutCampaignInput
    product?: ProductCreateNestedOneWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateWithoutClinicInput = {
    id?: string
    userId: string
    metaAccountId?: string | null
    adAccountId?: string | null
    campaignId?: string | null
    name: string
    objective: string
    status: $Enums.CampaignStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productId?: string | null
    adSets?: AdSetUncheckedCreateNestedManyWithoutCampaignInput
    tags?: TagsOnCampaignsUncheckedCreateNestedManyWithoutCampaignInput
    metrics?: CampaignMetricsUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutClinicInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutClinicInput, CampaignUncheckedCreateWithoutClinicInput>
  }

  export type CampaignCreateManyClinicInputEnvelope = {
    data: CampaignCreateManyClinicInput | CampaignCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutClinicsInput = {
    update: XOR<UserUpdateWithoutClinicsInput, UserUncheckedUpdateWithoutClinicsInput>
    create: XOR<UserCreateWithoutClinicsInput, UserUncheckedCreateWithoutClinicsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClinicsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClinicsInput, UserUncheckedUpdateWithoutClinicsInput>
  }

  export type UserUpdateWithoutClinicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaAccounts?: MetaAccountUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialMediaAccountUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    adsets?: AdSetUpdateManyWithoutUserNestedInput
    ads?: AdUpdateManyWithoutUserNestedInput
    schedules?: ScheduleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    influencers?: InfluencerUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClinicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaAccounts?: MetaAccountUncheckedUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialMediaAccountUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    adsets?: AdSetUncheckedUpdateManyWithoutUserNestedInput
    ads?: AdUncheckedUpdateManyWithoutUserNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    influencers?: InfluencerUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ScheduleUpsertWithWhereUniqueWithoutClinicInput = {
    where: ScheduleWhereUniqueInput
    update: XOR<ScheduleUpdateWithoutClinicInput, ScheduleUncheckedUpdateWithoutClinicInput>
    create: XOR<ScheduleCreateWithoutClinicInput, ScheduleUncheckedCreateWithoutClinicInput>
  }

  export type ScheduleUpdateWithWhereUniqueWithoutClinicInput = {
    where: ScheduleWhereUniqueInput
    data: XOR<ScheduleUpdateWithoutClinicInput, ScheduleUncheckedUpdateWithoutClinicInput>
  }

  export type ScheduleUpdateManyWithWhereWithoutClinicInput = {
    where: ScheduleScalarWhereInput
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyWithoutClinicInput>
  }

  export type CampaignUpsertWithWhereUniqueWithoutClinicInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutClinicInput, CampaignUncheckedUpdateWithoutClinicInput>
    create: XOR<CampaignCreateWithoutClinicInput, CampaignUncheckedCreateWithoutClinicInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutClinicInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutClinicInput, CampaignUncheckedUpdateWithoutClinicInput>
  }

  export type CampaignUpdateManyWithWhereWithoutClinicInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutClinicInput>
  }

  export type UserCreateWithoutProductsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    metaAccounts?: MetaAccountCreateNestedManyWithoutUserInput
    socialAccounts?: SocialMediaAccountCreateNestedManyWithoutUserInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    adsets?: AdSetCreateNestedManyWithoutUserInput
    ads?: AdCreateNestedManyWithoutUserInput
    schedules?: ScheduleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    influencers?: InfluencerCreateNestedManyWithoutUserInput
    clinics?: ClinicCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProductsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    metaAccounts?: MetaAccountUncheckedCreateNestedManyWithoutUserInput
    socialAccounts?: SocialMediaAccountUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    adsets?: AdSetUncheckedCreateNestedManyWithoutUserInput
    ads?: AdUncheckedCreateNestedManyWithoutUserInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    influencers?: InfluencerUncheckedCreateNestedManyWithoutUserInput
    clinics?: ClinicUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProductsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProductsInput, UserUncheckedCreateWithoutProductsInput>
  }

  export type ScheduleCreateWithoutProductInput = {
    id?: string
    title: string
    startDate: Date | string
    endDate: Date | string
    status: $Enums.ScheduleStatus
    priority?: $Enums.SchedulePriority
    category?: $Enums.ScheduleCategory | null
    recurrence?: $Enums.RecurrencePattern | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSchedulesInput
    ad?: AdCreateNestedOneWithoutSchedulesInput
    clinic?: ClinicCreateNestedOneWithoutSchedulesInput
  }

  export type ScheduleUncheckedCreateWithoutProductInput = {
    id?: string
    userId: string
    adId?: string | null
    title: string
    startDate: Date | string
    endDate: Date | string
    status: $Enums.ScheduleStatus
    priority?: $Enums.SchedulePriority
    category?: $Enums.ScheduleCategory | null
    clinicId?: string | null
    recurrence?: $Enums.RecurrencePattern | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleCreateOrConnectWithoutProductInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutProductInput, ScheduleUncheckedCreateWithoutProductInput>
  }

  export type ScheduleCreateManyProductInputEnvelope = {
    data: ScheduleCreateManyProductInput | ScheduleCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type CampaignCreateWithoutProductInput = {
    id?: string
    campaignId?: string | null
    name: string
    objective: string
    status: $Enums.CampaignStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCampaignsInput
    metaAccount?: MetaAccountCreateNestedOneWithoutCampaignsInput
    adAccount?: AdAccountCreateNestedOneWithoutCampaignsInput
    adSets?: AdSetCreateNestedManyWithoutCampaignInput
    tags?: TagsOnCampaignsCreateNestedManyWithoutCampaignInput
    metrics?: CampaignMetricsCreateNestedManyWithoutCampaignInput
    clinic?: ClinicCreateNestedOneWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateWithoutProductInput = {
    id?: string
    userId: string
    metaAccountId?: string | null
    adAccountId?: string | null
    campaignId?: string | null
    name: string
    objective: string
    status: $Enums.CampaignStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinicId?: string | null
    adSets?: AdSetUncheckedCreateNestedManyWithoutCampaignInput
    tags?: TagsOnCampaignsUncheckedCreateNestedManyWithoutCampaignInput
    metrics?: CampaignMetricsUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutProductInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutProductInput, CampaignUncheckedCreateWithoutProductInput>
  }

  export type CampaignCreateManyProductInputEnvelope = {
    data: CampaignCreateManyProductInput | CampaignCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutProductsInput = {
    update: XOR<UserUpdateWithoutProductsInput, UserUncheckedUpdateWithoutProductsInput>
    create: XOR<UserCreateWithoutProductsInput, UserUncheckedCreateWithoutProductsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProductsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProductsInput, UserUncheckedUpdateWithoutProductsInput>
  }

  export type UserUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaAccounts?: MetaAccountUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialMediaAccountUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    adsets?: AdSetUpdateManyWithoutUserNestedInput
    ads?: AdUpdateManyWithoutUserNestedInput
    schedules?: ScheduleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    influencers?: InfluencerUpdateManyWithoutUserNestedInput
    clinics?: ClinicUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaAccounts?: MetaAccountUncheckedUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialMediaAccountUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    adsets?: AdSetUncheckedUpdateManyWithoutUserNestedInput
    ads?: AdUncheckedUpdateManyWithoutUserNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    influencers?: InfluencerUncheckedUpdateManyWithoutUserNestedInput
    clinics?: ClinicUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ScheduleUpsertWithWhereUniqueWithoutProductInput = {
    where: ScheduleWhereUniqueInput
    update: XOR<ScheduleUpdateWithoutProductInput, ScheduleUncheckedUpdateWithoutProductInput>
    create: XOR<ScheduleCreateWithoutProductInput, ScheduleUncheckedCreateWithoutProductInput>
  }

  export type ScheduleUpdateWithWhereUniqueWithoutProductInput = {
    where: ScheduleWhereUniqueInput
    data: XOR<ScheduleUpdateWithoutProductInput, ScheduleUncheckedUpdateWithoutProductInput>
  }

  export type ScheduleUpdateManyWithWhereWithoutProductInput = {
    where: ScheduleScalarWhereInput
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyWithoutProductInput>
  }

  export type CampaignUpsertWithWhereUniqueWithoutProductInput = {
    where: CampaignWhereUniqueInput
    update: XOR<CampaignUpdateWithoutProductInput, CampaignUncheckedUpdateWithoutProductInput>
    create: XOR<CampaignCreateWithoutProductInput, CampaignUncheckedCreateWithoutProductInput>
  }

  export type CampaignUpdateWithWhereUniqueWithoutProductInput = {
    where: CampaignWhereUniqueInput
    data: XOR<CampaignUpdateWithoutProductInput, CampaignUncheckedUpdateWithoutProductInput>
  }

  export type CampaignUpdateManyWithWhereWithoutProductInput = {
    where: CampaignScalarWhereInput
    data: XOR<CampaignUpdateManyMutationInput, CampaignUncheckedUpdateManyWithoutProductInput>
  }

  export type UserCreateWithoutPaymentsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    metaAccounts?: MetaAccountCreateNestedManyWithoutUserInput
    socialAccounts?: SocialMediaAccountCreateNestedManyWithoutUserInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    adsets?: AdSetCreateNestedManyWithoutUserInput
    ads?: AdCreateNestedManyWithoutUserInput
    schedules?: ScheduleCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    influencers?: InfluencerCreateNestedManyWithoutUserInput
    clinics?: ClinicCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPaymentsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    metaAccounts?: MetaAccountUncheckedCreateNestedManyWithoutUserInput
    socialAccounts?: SocialMediaAccountUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    adsets?: AdSetUncheckedCreateNestedManyWithoutUserInput
    ads?: AdUncheckedCreateNestedManyWithoutUserInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    influencers?: InfluencerUncheckedCreateNestedManyWithoutUserInput
    clinics?: ClinicUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
  }

  export type InvoiceCreateWithoutPaymentsInput = {
    id?: string
    invoiceNumber: string
    amount: number
    currency?: string
    status: $Enums.InvoiceStatus
    dueDate: Date | string
    issueDate?: Date | string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutPaymentsInput = {
    id?: string
    userId: string
    invoiceNumber: string
    amount: number
    currency?: string
    status: $Enums.InvoiceStatus
    dueDate: Date | string
    issueDate?: Date | string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateOrConnectWithoutPaymentsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
  }

  export type UserUpsertWithoutPaymentsInput = {
    update: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaAccounts?: MetaAccountUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialMediaAccountUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    adsets?: AdSetUpdateManyWithoutUserNestedInput
    ads?: AdUpdateManyWithoutUserNestedInput
    schedules?: ScheduleUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    influencers?: InfluencerUpdateManyWithoutUserNestedInput
    clinics?: ClinicUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaAccounts?: MetaAccountUncheckedUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialMediaAccountUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    adsets?: AdSetUncheckedUpdateManyWithoutUserNestedInput
    ads?: AdUncheckedUpdateManyWithoutUserNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    influencers?: InfluencerUncheckedUpdateManyWithoutUserNestedInput
    clinics?: ClinicUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InvoiceUpsertWithoutPaymentsInput = {
    update: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutInvoicesInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    metaAccounts?: MetaAccountCreateNestedManyWithoutUserInput
    socialAccounts?: SocialMediaAccountCreateNestedManyWithoutUserInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    adsets?: AdSetCreateNestedManyWithoutUserInput
    ads?: AdCreateNestedManyWithoutUserInput
    schedules?: ScheduleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    influencers?: InfluencerCreateNestedManyWithoutUserInput
    clinics?: ClinicCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInvoicesInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    metaAccounts?: MetaAccountUncheckedCreateNestedManyWithoutUserInput
    socialAccounts?: SocialMediaAccountUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    adsets?: AdSetUncheckedCreateNestedManyWithoutUserInput
    ads?: AdUncheckedCreateNestedManyWithoutUserInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    influencers?: InfluencerUncheckedCreateNestedManyWithoutUserInput
    clinics?: ClinicUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInvoicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
  }

  export type PaymentCreateWithoutInvoiceInput = {
    id?: string
    amount: number
    currency?: string
    status: $Enums.PaymentStatus
    method: $Enums.PaymentMethod
    description?: string | null
    transactionId?: string | null
    receiptUrl?: string | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutInvoiceInput = {
    id?: string
    userId: string
    amount: number
    currency?: string
    status: $Enums.PaymentStatus
    method: $Enums.PaymentMethod
    description?: string | null
    transactionId?: string | null
    receiptUrl?: string | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentCreateManyInvoiceInputEnvelope = {
    data: PaymentCreateManyInvoiceInput | PaymentCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutInvoicesInput = {
    update: XOR<UserUpdateWithoutInvoicesInput, UserUncheckedUpdateWithoutInvoicesInput>
    create: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvoicesInput, UserUncheckedUpdateWithoutInvoicesInput>
  }

  export type UserUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaAccounts?: MetaAccountUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialMediaAccountUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    adsets?: AdSetUpdateManyWithoutUserNestedInput
    ads?: AdUpdateManyWithoutUserNestedInput
    schedules?: ScheduleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    influencers?: InfluencerUpdateManyWithoutUserNestedInput
    clinics?: ClinicUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaAccounts?: MetaAccountUncheckedUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialMediaAccountUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    adsets?: AdSetUncheckedUpdateManyWithoutUserNestedInput
    ads?: AdUncheckedUpdateManyWithoutUserNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    influencers?: InfluencerUncheckedUpdateManyWithoutUserNestedInput
    clinics?: ClinicUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PaymentUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
  }

  export type PaymentUpdateManyWithWhereWithoutInvoiceInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type TagsOnCampaignsCreateWithoutTagInput = {
    assignedAt?: Date | string
    campaign: CampaignCreateNestedOneWithoutTagsInput
  }

  export type TagsOnCampaignsUncheckedCreateWithoutTagInput = {
    campaignId: string
    assignedAt?: Date | string
  }

  export type TagsOnCampaignsCreateOrConnectWithoutTagInput = {
    where: TagsOnCampaignsWhereUniqueInput
    create: XOR<TagsOnCampaignsCreateWithoutTagInput, TagsOnCampaignsUncheckedCreateWithoutTagInput>
  }

  export type TagsOnCampaignsCreateManyTagInputEnvelope = {
    data: TagsOnCampaignsCreateManyTagInput | TagsOnCampaignsCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type TagsOnCampaignsUpsertWithWhereUniqueWithoutTagInput = {
    where: TagsOnCampaignsWhereUniqueInput
    update: XOR<TagsOnCampaignsUpdateWithoutTagInput, TagsOnCampaignsUncheckedUpdateWithoutTagInput>
    create: XOR<TagsOnCampaignsCreateWithoutTagInput, TagsOnCampaignsUncheckedCreateWithoutTagInput>
  }

  export type TagsOnCampaignsUpdateWithWhereUniqueWithoutTagInput = {
    where: TagsOnCampaignsWhereUniqueInput
    data: XOR<TagsOnCampaignsUpdateWithoutTagInput, TagsOnCampaignsUncheckedUpdateWithoutTagInput>
  }

  export type TagsOnCampaignsUpdateManyWithWhereWithoutTagInput = {
    where: TagsOnCampaignsScalarWhereInput
    data: XOR<TagsOnCampaignsUpdateManyMutationInput, TagsOnCampaignsUncheckedUpdateManyWithoutTagInput>
  }

  export type TagCreateWithoutCampaignsInput = {
    id?: string
    name: string
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUncheckedCreateWithoutCampaignsInput = {
    id?: string
    name: string
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagCreateOrConnectWithoutCampaignsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutCampaignsInput, TagUncheckedCreateWithoutCampaignsInput>
  }

  export type CampaignCreateWithoutTagsInput = {
    id?: string
    campaignId?: string | null
    name: string
    objective: string
    status: $Enums.CampaignStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCampaignsInput
    metaAccount?: MetaAccountCreateNestedOneWithoutCampaignsInput
    adAccount?: AdAccountCreateNestedOneWithoutCampaignsInput
    adSets?: AdSetCreateNestedManyWithoutCampaignInput
    metrics?: CampaignMetricsCreateNestedManyWithoutCampaignInput
    clinic?: ClinicCreateNestedOneWithoutCampaignsInput
    product?: ProductCreateNestedOneWithoutCampaignsInput
  }

  export type CampaignUncheckedCreateWithoutTagsInput = {
    id?: string
    userId: string
    metaAccountId?: string | null
    adAccountId?: string | null
    campaignId?: string | null
    name: string
    objective: string
    status: $Enums.CampaignStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinicId?: string | null
    productId?: string | null
    adSets?: AdSetUncheckedCreateNestedManyWithoutCampaignInput
    metrics?: CampaignMetricsUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type CampaignCreateOrConnectWithoutTagsInput = {
    where: CampaignWhereUniqueInput
    create: XOR<CampaignCreateWithoutTagsInput, CampaignUncheckedCreateWithoutTagsInput>
  }

  export type TagUpsertWithoutCampaignsInput = {
    update: XOR<TagUpdateWithoutCampaignsInput, TagUncheckedUpdateWithoutCampaignsInput>
    create: XOR<TagCreateWithoutCampaignsInput, TagUncheckedCreateWithoutCampaignsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutCampaignsInput, TagUncheckedUpdateWithoutCampaignsInput>
  }

  export type TagUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUpsertWithoutTagsInput = {
    update: XOR<CampaignUpdateWithoutTagsInput, CampaignUncheckedUpdateWithoutTagsInput>
    create: XOR<CampaignCreateWithoutTagsInput, CampaignUncheckedCreateWithoutTagsInput>
    where?: CampaignWhereInput
  }

  export type CampaignUpdateToOneWithWhereWithoutTagsInput = {
    where?: CampaignWhereInput
    data: XOR<CampaignUpdateWithoutTagsInput, CampaignUncheckedUpdateWithoutTagsInput>
  }

  export type CampaignUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCampaignsNestedInput
    metaAccount?: MetaAccountUpdateOneWithoutCampaignsNestedInput
    adAccount?: AdAccountUpdateOneWithoutCampaignsNestedInput
    adSets?: AdSetUpdateManyWithoutCampaignNestedInput
    metrics?: CampaignMetricsUpdateManyWithoutCampaignNestedInput
    clinic?: ClinicUpdateOneWithoutCampaignsNestedInput
    product?: ProductUpdateOneWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    metaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    adAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    adSets?: AdSetUncheckedUpdateManyWithoutCampaignNestedInput
    metrics?: CampaignMetricsUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    metaAccounts?: MetaAccountCreateNestedManyWithoutUserInput
    socialAccounts?: SocialMediaAccountCreateNestedManyWithoutUserInput
    campaigns?: CampaignCreateNestedManyWithoutUserInput
    adsets?: AdSetCreateNestedManyWithoutUserInput
    ads?: AdCreateNestedManyWithoutUserInput
    schedules?: ScheduleCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    invoices?: InvoiceCreateNestedManyWithoutUserInput
    influencers?: InfluencerCreateNestedManyWithoutUserInput
    clinics?: ClinicCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password?: string | null
    name?: string | null
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    metaAccounts?: MetaAccountUncheckedCreateNestedManyWithoutUserInput
    socialAccounts?: SocialMediaAccountUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignUncheckedCreateNestedManyWithoutUserInput
    adsets?: AdSetUncheckedCreateNestedManyWithoutUserInput
    ads?: AdUncheckedCreateNestedManyWithoutUserInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutUserInput
    influencers?: InfluencerUncheckedCreateNestedManyWithoutUserInput
    clinics?: ClinicUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaAccounts?: MetaAccountUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialMediaAccountUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUpdateManyWithoutUserNestedInput
    adsets?: AdSetUpdateManyWithoutUserNestedInput
    ads?: AdUpdateManyWithoutUserNestedInput
    schedules?: ScheduleUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUpdateManyWithoutUserNestedInput
    influencers?: InfluencerUpdateManyWithoutUserNestedInput
    clinics?: ClinicUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaAccounts?: MetaAccountUncheckedUpdateManyWithoutUserNestedInput
    socialAccounts?: SocialMediaAccountUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutUserNestedInput
    adsets?: AdSetUncheckedUpdateManyWithoutUserNestedInput
    ads?: AdUncheckedUpdateManyWithoutUserNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutUserNestedInput
    influencers?: InfluencerUncheckedUpdateManyWithoutUserNestedInput
    clinics?: ClinicUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MetaAccountCreateManyUserInput = {
    id?: string
    metaAccountId: string
    accessToken: string
    refreshToken?: string | null
    tokenExpiresAt?: Date | string | null
    businessName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SocialMediaAccountCreateManyUserInput = {
    id?: string
    platform: $Enums.PlatformType
    accountName: string
    accountId?: string | null
    followers?: number
    accessToken?: string | null
    tokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignCreateManyUserInput = {
    id?: string
    metaAccountId?: string | null
    adAccountId?: string | null
    campaignId?: string | null
    name: string
    objective: string
    status: $Enums.CampaignStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinicId?: string | null
    productId?: string | null
  }

  export type AdSetCreateManyUserInput = {
    id?: string
    campaignId: string
    metaAccountId?: string | null
    adSetId?: string | null
    name: string
    status: $Enums.AdSetStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    bidStrategy?: string | null
    bidAmount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targeting?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdCreateManyUserInput = {
    id?: string
    adSetId: string
    metaAccountId?: string | null
    adId?: string | null
    name: string
    status: $Enums.AdStatus
    headline?: string | null
    description?: string | null
    creativeType?: $Enums.CreativeType | null
    imageUrl?: string | null
    videoUrl?: string | null
    destinationUrl?: string | null
    callToAction?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleCreateManyUserInput = {
    id?: string
    adId?: string | null
    title: string
    startDate: Date | string
    endDate: Date | string
    status: $Enums.ScheduleStatus
    priority?: $Enums.SchedulePriority
    category?: $Enums.ScheduleCategory | null
    clinicId?: string | null
    productId?: string | null
    recurrence?: $Enums.RecurrencePattern | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyUserInput = {
    id?: string
    amount: number
    currency?: string
    status: $Enums.PaymentStatus
    method: $Enums.PaymentMethod
    description?: string | null
    transactionId?: string | null
    receiptUrl?: string | null
    invoiceId?: string | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyUserInput = {
    id?: string
    invoiceNumber: string
    amount: number
    currency?: string
    status: $Enums.InvoiceStatus
    dueDate: Date | string
    issueDate?: Date | string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    title: string
    message: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InfluencerCreateManyUserInput = {
    id?: string
    accountId: string
    name: string
    contactInfo?: string | null
    reach?: number
    engagementRate?: number | null
    niche?: string | null
    cost?: number | null
    status?: $Enums.InfluencerStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicCreateManyUserInput = {
    id?: string
    name: string
    address?: string | null
    city?: string | null
    phone?: string | null
    email?: string | null
    website?: string | null
    description?: string | null
    featured?: boolean
    logoUrl?: string | null
    rating?: number | null
    reviewCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateManyUserInput = {
    id?: string
    name: string
    description?: string | null
    price?: number | null
    sku?: string | null
    imageUrl?: string | null
    featured?: boolean
    category?: string | null
    stock?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MetaAccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    metaAccountId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUpdateManyWithoutMetaAccountNestedInput
    adSets?: AdSetUpdateManyWithoutMetaAccountNestedInput
    ads?: AdUpdateManyWithoutMetaAccountNestedInput
    adAccounts?: AdAccountUpdateManyWithoutMetaAccountNestedInput
  }

  export type MetaAccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    metaAccountId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUncheckedUpdateManyWithoutMetaAccountNestedInput
    adSets?: AdSetUncheckedUpdateManyWithoutMetaAccountNestedInput
    ads?: AdUncheckedUpdateManyWithoutMetaAccountNestedInput
    adAccounts?: AdAccountUncheckedUpdateManyWithoutMetaAccountNestedInput
  }

  export type MetaAccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    metaAccountId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SocialMediaAccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | $Enums.PlatformType
    accountName?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    followers?: IntFieldUpdateOperationsInput | number
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platformMetrics?: PlatformMetricsUpdateManyWithoutAccountNestedInput
    engagementMetrics?: EngagementMetricsUpdateManyWithoutAccountNestedInput
    influencers?: InfluencerUpdateManyWithoutAccountNestedInput
  }

  export type SocialMediaAccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | $Enums.PlatformType
    accountName?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    followers?: IntFieldUpdateOperationsInput | number
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platformMetrics?: PlatformMetricsUncheckedUpdateManyWithoutAccountNestedInput
    engagementMetrics?: EngagementMetricsUncheckedUpdateManyWithoutAccountNestedInput
    influencers?: InfluencerUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type SocialMediaAccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | $Enums.PlatformType
    accountName?: StringFieldUpdateOperationsInput | string
    accountId?: NullableStringFieldUpdateOperationsInput | string | null
    followers?: IntFieldUpdateOperationsInput | number
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    tokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metaAccount?: MetaAccountUpdateOneWithoutCampaignsNestedInput
    adAccount?: AdAccountUpdateOneWithoutCampaignsNestedInput
    adSets?: AdSetUpdateManyWithoutCampaignNestedInput
    tags?: TagsOnCampaignsUpdateManyWithoutCampaignNestedInput
    metrics?: CampaignMetricsUpdateManyWithoutCampaignNestedInput
    clinic?: ClinicUpdateOneWithoutCampaignsNestedInput
    product?: ProductUpdateOneWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    metaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    adAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    adSets?: AdSetUncheckedUpdateManyWithoutCampaignNestedInput
    tags?: TagsOnCampaignsUncheckedUpdateManyWithoutCampaignNestedInput
    metrics?: CampaignMetricsUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    metaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    adAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdSetUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    adSetId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAdSetStatusFieldUpdateOperationsInput | $Enums.AdSetStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    bidStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    bidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targeting?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutAdSetsNestedInput
    metaAccount?: MetaAccountUpdateOneWithoutAdSetsNestedInput
    ads?: AdUpdateManyWithoutAdSetNestedInput
    metrics?: AdSetMetricsUpdateManyWithoutAdSetNestedInput
  }

  export type AdSetUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    metaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    adSetId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAdSetStatusFieldUpdateOperationsInput | $Enums.AdSetStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    bidStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    bidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targeting?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ads?: AdUncheckedUpdateManyWithoutAdSetNestedInput
    metrics?: AdSetMetricsUncheckedUpdateManyWithoutAdSetNestedInput
  }

  export type AdSetUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    metaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    adSetId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAdSetStatusFieldUpdateOperationsInput | $Enums.AdSetStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    bidStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    bidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targeting?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    adId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAdStatusFieldUpdateOperationsInput | $Enums.AdStatus
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creativeType?: NullableEnumCreativeTypeFieldUpdateOperationsInput | $Enums.CreativeType | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    destinationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    callToAction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    adSet?: AdSetUpdateOneRequiredWithoutAdsNestedInput
    metaAccount?: MetaAccountUpdateOneWithoutAdsNestedInput
    metrics?: AdMetricsUpdateManyWithoutAdNestedInput
    schedules?: ScheduleUpdateManyWithoutAdNestedInput
  }

  export type AdUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    adSetId?: StringFieldUpdateOperationsInput | string
    metaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    adId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAdStatusFieldUpdateOperationsInput | $Enums.AdStatus
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creativeType?: NullableEnumCreativeTypeFieldUpdateOperationsInput | $Enums.CreativeType | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    destinationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    callToAction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: AdMetricsUncheckedUpdateManyWithoutAdNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutAdNestedInput
  }

  export type AdUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    adSetId?: StringFieldUpdateOperationsInput | string
    metaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    adId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAdStatusFieldUpdateOperationsInput | $Enums.AdStatus
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creativeType?: NullableEnumCreativeTypeFieldUpdateOperationsInput | $Enums.CreativeType | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    destinationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    callToAction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumScheduleStatusFieldUpdateOperationsInput | $Enums.ScheduleStatus
    priority?: EnumSchedulePriorityFieldUpdateOperationsInput | $Enums.SchedulePriority
    category?: NullableEnumScheduleCategoryFieldUpdateOperationsInput | $Enums.ScheduleCategory | null
    recurrence?: NullableEnumRecurrencePatternFieldUpdateOperationsInput | $Enums.RecurrencePattern | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ad?: AdUpdateOneWithoutSchedulesNestedInput
    clinic?: ClinicUpdateOneWithoutSchedulesNestedInput
    product?: ProductUpdateOneWithoutSchedulesNestedInput
  }

  export type ScheduleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    adId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumScheduleStatusFieldUpdateOperationsInput | $Enums.ScheduleStatus
    priority?: EnumSchedulePriorityFieldUpdateOperationsInput | $Enums.SchedulePriority
    category?: NullableEnumScheduleCategoryFieldUpdateOperationsInput | $Enums.ScheduleCategory | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    recurrence?: NullableEnumRecurrencePatternFieldUpdateOperationsInput | $Enums.RecurrencePattern | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    adId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumScheduleStatusFieldUpdateOperationsInput | $Enums.ScheduleStatus
    priority?: EnumSchedulePriorityFieldUpdateOperationsInput | $Enums.SchedulePriority
    category?: NullableEnumScheduleCategoryFieldUpdateOperationsInput | $Enums.ScheduleCategory | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    recurrence?: NullableEnumRecurrencePatternFieldUpdateOperationsInput | $Enums.RecurrencePattern | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InfluencerUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    reach?: IntFieldUpdateOperationsInput | number
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    niche?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumInfluencerStatusFieldUpdateOperationsInput | $Enums.InfluencerStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: SocialMediaAccountUpdateOneRequiredWithoutInfluencersNestedInput
    campaigns?: InfluencerCampaignsUpdateManyWithoutInfluencerNestedInput
  }

  export type InfluencerUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    reach?: IntFieldUpdateOperationsInput | number
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    niche?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumInfluencerStatusFieldUpdateOperationsInput | $Enums.InfluencerStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: InfluencerCampaignsUncheckedUpdateManyWithoutInfluencerNestedInput
  }

  export type InfluencerUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    reach?: IntFieldUpdateOperationsInput | number
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    niche?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumInfluencerStatusFieldUpdateOperationsInput | $Enums.InfluencerStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUpdateManyWithoutClinicNestedInput
    campaigns?: CampaignUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUncheckedUpdateManyWithoutClinicNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    reviewCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUpdateManyWithoutProductNestedInput
    campaigns?: CampaignUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUncheckedUpdateManyWithoutProductNestedInput
    campaigns?: CampaignUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    featured?: BoolFieldUpdateOperationsInput | boolean
    category?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignCreateManyMetaAccountInput = {
    id?: string
    userId: string
    adAccountId?: string | null
    campaignId?: string | null
    name: string
    objective: string
    status: $Enums.CampaignStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinicId?: string | null
    productId?: string | null
  }

  export type AdSetCreateManyMetaAccountInput = {
    id?: string
    userId: string
    campaignId: string
    adSetId?: string | null
    name: string
    status: $Enums.AdSetStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    bidStrategy?: string | null
    bidAmount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targeting?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdCreateManyMetaAccountInput = {
    id?: string
    userId: string
    adSetId: string
    adId?: string | null
    name: string
    status: $Enums.AdStatus
    headline?: string | null
    description?: string | null
    creativeType?: $Enums.CreativeType | null
    imageUrl?: string | null
    videoUrl?: string | null
    destinationUrl?: string | null
    callToAction?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdAccountCreateManyMetaAccountInput = {
    id?: string
    adAccountId: string
    name: string
    currency: string
    timezone: string
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignUpdateWithoutMetaAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCampaignsNestedInput
    adAccount?: AdAccountUpdateOneWithoutCampaignsNestedInput
    adSets?: AdSetUpdateManyWithoutCampaignNestedInput
    tags?: TagsOnCampaignsUpdateManyWithoutCampaignNestedInput
    metrics?: CampaignMetricsUpdateManyWithoutCampaignNestedInput
    clinic?: ClinicUpdateOneWithoutCampaignsNestedInput
    product?: ProductUpdateOneWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateWithoutMetaAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    adAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    adSets?: AdSetUncheckedUpdateManyWithoutCampaignNestedInput
    tags?: TagsOnCampaignsUncheckedUpdateManyWithoutCampaignNestedInput
    metrics?: CampaignMetricsUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutMetaAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    adAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdSetUpdateWithoutMetaAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    adSetId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAdSetStatusFieldUpdateOperationsInput | $Enums.AdSetStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    bidStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    bidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targeting?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdsetsNestedInput
    campaign?: CampaignUpdateOneRequiredWithoutAdSetsNestedInput
    ads?: AdUpdateManyWithoutAdSetNestedInput
    metrics?: AdSetMetricsUpdateManyWithoutAdSetNestedInput
  }

  export type AdSetUncheckedUpdateWithoutMetaAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    adSetId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAdSetStatusFieldUpdateOperationsInput | $Enums.AdSetStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    bidStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    bidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targeting?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ads?: AdUncheckedUpdateManyWithoutAdSetNestedInput
    metrics?: AdSetMetricsUncheckedUpdateManyWithoutAdSetNestedInput
  }

  export type AdSetUncheckedUpdateManyWithoutMetaAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    adSetId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAdSetStatusFieldUpdateOperationsInput | $Enums.AdSetStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    bidStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    bidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targeting?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdUpdateWithoutMetaAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    adId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAdStatusFieldUpdateOperationsInput | $Enums.AdStatus
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creativeType?: NullableEnumCreativeTypeFieldUpdateOperationsInput | $Enums.CreativeType | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    destinationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    callToAction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdsNestedInput
    adSet?: AdSetUpdateOneRequiredWithoutAdsNestedInput
    metrics?: AdMetricsUpdateManyWithoutAdNestedInput
    schedules?: ScheduleUpdateManyWithoutAdNestedInput
  }

  export type AdUncheckedUpdateWithoutMetaAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    adSetId?: StringFieldUpdateOperationsInput | string
    adId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAdStatusFieldUpdateOperationsInput | $Enums.AdStatus
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creativeType?: NullableEnumCreativeTypeFieldUpdateOperationsInput | $Enums.CreativeType | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    destinationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    callToAction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: AdMetricsUncheckedUpdateManyWithoutAdNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutAdNestedInput
  }

  export type AdUncheckedUpdateManyWithoutMetaAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    adSetId?: StringFieldUpdateOperationsInput | string
    adId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAdStatusFieldUpdateOperationsInput | $Enums.AdStatus
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creativeType?: NullableEnumCreativeTypeFieldUpdateOperationsInput | $Enums.CreativeType | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    destinationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    callToAction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdAccountUpdateWithoutMetaAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    adAccountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUpdateManyWithoutAdAccountNestedInput
  }

  export type AdAccountUncheckedUpdateWithoutMetaAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    adAccountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: CampaignUncheckedUpdateManyWithoutAdAccountNestedInput
  }

  export type AdAccountUncheckedUpdateManyWithoutMetaAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    adAccountId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignCreateManyAdAccountInput = {
    id?: string
    userId: string
    metaAccountId?: string | null
    campaignId?: string | null
    name: string
    objective: string
    status: $Enums.CampaignStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinicId?: string | null
    productId?: string | null
  }

  export type CampaignUpdateWithoutAdAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCampaignsNestedInput
    metaAccount?: MetaAccountUpdateOneWithoutCampaignsNestedInput
    adSets?: AdSetUpdateManyWithoutCampaignNestedInput
    tags?: TagsOnCampaignsUpdateManyWithoutCampaignNestedInput
    metrics?: CampaignMetricsUpdateManyWithoutCampaignNestedInput
    clinic?: ClinicUpdateOneWithoutCampaignsNestedInput
    product?: ProductUpdateOneWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateWithoutAdAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    metaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    adSets?: AdSetUncheckedUpdateManyWithoutCampaignNestedInput
    tags?: TagsOnCampaignsUncheckedUpdateManyWithoutCampaignNestedInput
    metrics?: CampaignMetricsUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutAdAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    metaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdSetCreateManyCampaignInput = {
    id?: string
    userId: string
    metaAccountId?: string | null
    adSetId?: string | null
    name: string
    status: $Enums.AdSetStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    bidStrategy?: string | null
    bidAmount?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    targeting?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagsOnCampaignsCreateManyCampaignInput = {
    tagId: string
    assignedAt?: Date | string
  }

  export type CampaignMetricsCreateManyCampaignInput = {
    id?: string
    date: Date | string
    impressions?: number
    clicks?: number
    reach?: number
    spend?: number
    conversions?: number
    costPerResult?: number | null
    ctr?: number | null
    cpc?: number | null
    cpm?: number | null
    frequency?: number | null
  }

  export type AdSetUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    adSetId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAdSetStatusFieldUpdateOperationsInput | $Enums.AdSetStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    bidStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    bidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targeting?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdsetsNestedInput
    metaAccount?: MetaAccountUpdateOneWithoutAdSetsNestedInput
    ads?: AdUpdateManyWithoutAdSetNestedInput
    metrics?: AdSetMetricsUpdateManyWithoutAdSetNestedInput
  }

  export type AdSetUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    metaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    adSetId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAdSetStatusFieldUpdateOperationsInput | $Enums.AdSetStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    bidStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    bidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targeting?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ads?: AdUncheckedUpdateManyWithoutAdSetNestedInput
    metrics?: AdSetMetricsUncheckedUpdateManyWithoutAdSetNestedInput
  }

  export type AdSetUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    metaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    adSetId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAdSetStatusFieldUpdateOperationsInput | $Enums.AdSetStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    bidStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    bidAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    targeting?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagsOnCampaignsUpdateWithoutCampaignInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: TagUpdateOneRequiredWithoutCampaignsNestedInput
  }

  export type TagsOnCampaignsUncheckedUpdateWithoutCampaignInput = {
    tagId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagsOnCampaignsUncheckedUpdateManyWithoutCampaignInput = {
    tagId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignMetricsUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    reach?: IntFieldUpdateOperationsInput | number
    spend?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    costPerResult?: NullableFloatFieldUpdateOperationsInput | number | null
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    cpc?: NullableFloatFieldUpdateOperationsInput | number | null
    cpm?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CampaignMetricsUncheckedUpdateWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    reach?: IntFieldUpdateOperationsInput | number
    spend?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    costPerResult?: NullableFloatFieldUpdateOperationsInput | number | null
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    cpc?: NullableFloatFieldUpdateOperationsInput | number | null
    cpm?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CampaignMetricsUncheckedUpdateManyWithoutCampaignInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    reach?: IntFieldUpdateOperationsInput | number
    spend?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    costPerResult?: NullableFloatFieldUpdateOperationsInput | number | null
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    cpc?: NullableFloatFieldUpdateOperationsInput | number | null
    cpm?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type AdCreateManyAdSetInput = {
    id?: string
    userId: string
    metaAccountId?: string | null
    adId?: string | null
    name: string
    status: $Enums.AdStatus
    headline?: string | null
    description?: string | null
    creativeType?: $Enums.CreativeType | null
    imageUrl?: string | null
    videoUrl?: string | null
    destinationUrl?: string | null
    callToAction?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdSetMetricsCreateManyAdSetInput = {
    id?: string
    date: Date | string
    impressions?: number
    clicks?: number
    reach?: number
    spend?: number
    conversions?: number
    costPerResult?: number | null
    ctr?: number | null
    cpc?: number | null
    cpm?: number | null
    frequency?: number | null
  }

  export type AdUpdateWithoutAdSetInput = {
    id?: StringFieldUpdateOperationsInput | string
    adId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAdStatusFieldUpdateOperationsInput | $Enums.AdStatus
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creativeType?: NullableEnumCreativeTypeFieldUpdateOperationsInput | $Enums.CreativeType | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    destinationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    callToAction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAdsNestedInput
    metaAccount?: MetaAccountUpdateOneWithoutAdsNestedInput
    metrics?: AdMetricsUpdateManyWithoutAdNestedInput
    schedules?: ScheduleUpdateManyWithoutAdNestedInput
  }

  export type AdUncheckedUpdateWithoutAdSetInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    metaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    adId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAdStatusFieldUpdateOperationsInput | $Enums.AdStatus
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creativeType?: NullableEnumCreativeTypeFieldUpdateOperationsInput | $Enums.CreativeType | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    destinationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    callToAction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: AdMetricsUncheckedUpdateManyWithoutAdNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutAdNestedInput
  }

  export type AdUncheckedUpdateManyWithoutAdSetInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    metaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    adId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumAdStatusFieldUpdateOperationsInput | $Enums.AdStatus
    headline?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    creativeType?: NullableEnumCreativeTypeFieldUpdateOperationsInput | $Enums.CreativeType | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    destinationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    callToAction?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdSetMetricsUpdateWithoutAdSetInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    reach?: IntFieldUpdateOperationsInput | number
    spend?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    costPerResult?: NullableFloatFieldUpdateOperationsInput | number | null
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    cpc?: NullableFloatFieldUpdateOperationsInput | number | null
    cpm?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type AdSetMetricsUncheckedUpdateWithoutAdSetInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    reach?: IntFieldUpdateOperationsInput | number
    spend?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    costPerResult?: NullableFloatFieldUpdateOperationsInput | number | null
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    cpc?: NullableFloatFieldUpdateOperationsInput | number | null
    cpm?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type AdSetMetricsUncheckedUpdateManyWithoutAdSetInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    reach?: IntFieldUpdateOperationsInput | number
    spend?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    costPerResult?: NullableFloatFieldUpdateOperationsInput | number | null
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    cpc?: NullableFloatFieldUpdateOperationsInput | number | null
    cpm?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type AdMetricsCreateManyAdInput = {
    id?: string
    date: Date | string
    impressions?: number
    clicks?: number
    reach?: number
    spend?: number
    conversions?: number
    costPerResult?: number | null
    ctr?: number | null
    cpc?: number | null
    cpm?: number | null
    frequency?: number | null
    engagements?: number
    shares?: number
    comments?: number
    saves?: number
  }

  export type ScheduleCreateManyAdInput = {
    id?: string
    userId: string
    title: string
    startDate: Date | string
    endDate: Date | string
    status: $Enums.ScheduleStatus
    priority?: $Enums.SchedulePriority
    category?: $Enums.ScheduleCategory | null
    clinicId?: string | null
    productId?: string | null
    recurrence?: $Enums.RecurrencePattern | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdMetricsUpdateWithoutAdInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    reach?: IntFieldUpdateOperationsInput | number
    spend?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    costPerResult?: NullableFloatFieldUpdateOperationsInput | number | null
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    cpc?: NullableFloatFieldUpdateOperationsInput | number | null
    cpm?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
    engagements?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    saves?: IntFieldUpdateOperationsInput | number
  }

  export type AdMetricsUncheckedUpdateWithoutAdInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    reach?: IntFieldUpdateOperationsInput | number
    spend?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    costPerResult?: NullableFloatFieldUpdateOperationsInput | number | null
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    cpc?: NullableFloatFieldUpdateOperationsInput | number | null
    cpm?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
    engagements?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    saves?: IntFieldUpdateOperationsInput | number
  }

  export type AdMetricsUncheckedUpdateManyWithoutAdInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    impressions?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    reach?: IntFieldUpdateOperationsInput | number
    spend?: FloatFieldUpdateOperationsInput | number
    conversions?: IntFieldUpdateOperationsInput | number
    costPerResult?: NullableFloatFieldUpdateOperationsInput | number | null
    ctr?: NullableFloatFieldUpdateOperationsInput | number | null
    cpc?: NullableFloatFieldUpdateOperationsInput | number | null
    cpm?: NullableFloatFieldUpdateOperationsInput | number | null
    frequency?: NullableFloatFieldUpdateOperationsInput | number | null
    engagements?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    saves?: IntFieldUpdateOperationsInput | number
  }

  export type ScheduleUpdateWithoutAdInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumScheduleStatusFieldUpdateOperationsInput | $Enums.ScheduleStatus
    priority?: EnumSchedulePriorityFieldUpdateOperationsInput | $Enums.SchedulePriority
    category?: NullableEnumScheduleCategoryFieldUpdateOperationsInput | $Enums.ScheduleCategory | null
    recurrence?: NullableEnumRecurrencePatternFieldUpdateOperationsInput | $Enums.RecurrencePattern | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSchedulesNestedInput
    clinic?: ClinicUpdateOneWithoutSchedulesNestedInput
    product?: ProductUpdateOneWithoutSchedulesNestedInput
  }

  export type ScheduleUncheckedUpdateWithoutAdInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumScheduleStatusFieldUpdateOperationsInput | $Enums.ScheduleStatus
    priority?: EnumSchedulePriorityFieldUpdateOperationsInput | $Enums.SchedulePriority
    category?: NullableEnumScheduleCategoryFieldUpdateOperationsInput | $Enums.ScheduleCategory | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    recurrence?: NullableEnumRecurrencePatternFieldUpdateOperationsInput | $Enums.RecurrencePattern | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUncheckedUpdateManyWithoutAdInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumScheduleStatusFieldUpdateOperationsInput | $Enums.ScheduleStatus
    priority?: EnumSchedulePriorityFieldUpdateOperationsInput | $Enums.SchedulePriority
    category?: NullableEnumScheduleCategoryFieldUpdateOperationsInput | $Enums.ScheduleCategory | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    recurrence?: NullableEnumRecurrencePatternFieldUpdateOperationsInput | $Enums.RecurrencePattern | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlannerItemCreateManyPlannerInput = {
    id?: string
    title: string
    description?: string | null
    platform: $Enums.PlatformType
    format?: string | null
    budget?: number | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    status?: $Enums.PlannerItemStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlannerItemUpdateWithoutPlannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | $Enums.PlatformType
    format?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPlannerItemStatusFieldUpdateOperationsInput | $Enums.PlannerItemStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlannerItemUncheckedUpdateWithoutPlannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | $Enums.PlatformType
    format?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPlannerItemStatusFieldUpdateOperationsInput | $Enums.PlannerItemStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlannerItemUncheckedUpdateManyWithoutPlannerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: EnumPlatformTypeFieldUpdateOperationsInput | $Enums.PlatformType
    format?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumPlannerItemStatusFieldUpdateOperationsInput | $Enums.PlannerItemStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformMetricsCreateManyAccountInput = {
    id?: string
    date: Date | string
    followers?: number
    following?: number
    posts?: number
    impressions?: number
    reach?: number
    profileViews?: number
    websiteClicks?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EngagementMetricsCreateManyAccountInput = {
    id?: string
    date: Date | string
    likes?: number
    comments?: number
    shares?: number
    saves?: number
    clicks?: number
    engagementRate?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InfluencerCreateManyAccountInput = {
    id?: string
    userId: string
    name: string
    contactInfo?: string | null
    reach?: number
    engagementRate?: number | null
    niche?: string | null
    cost?: number | null
    status?: $Enums.InfluencerStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformMetricsUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    followers?: IntFieldUpdateOperationsInput | number
    following?: IntFieldUpdateOperationsInput | number
    posts?: IntFieldUpdateOperationsInput | number
    impressions?: IntFieldUpdateOperationsInput | number
    reach?: IntFieldUpdateOperationsInput | number
    profileViews?: IntFieldUpdateOperationsInput | number
    websiteClicks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformMetricsUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    followers?: IntFieldUpdateOperationsInput | number
    following?: IntFieldUpdateOperationsInput | number
    posts?: IntFieldUpdateOperationsInput | number
    impressions?: IntFieldUpdateOperationsInput | number
    reach?: IntFieldUpdateOperationsInput | number
    profileViews?: IntFieldUpdateOperationsInput | number
    websiteClicks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformMetricsUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    followers?: IntFieldUpdateOperationsInput | number
    following?: IntFieldUpdateOperationsInput | number
    posts?: IntFieldUpdateOperationsInput | number
    impressions?: IntFieldUpdateOperationsInput | number
    reach?: IntFieldUpdateOperationsInput | number
    profileViews?: IntFieldUpdateOperationsInput | number
    websiteClicks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EngagementMetricsUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    saves?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EngagementMetricsUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    saves?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EngagementMetricsUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    likes?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    shares?: IntFieldUpdateOperationsInput | number
    saves?: IntFieldUpdateOperationsInput | number
    clicks?: IntFieldUpdateOperationsInput | number
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InfluencerUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    reach?: IntFieldUpdateOperationsInput | number
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    niche?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumInfluencerStatusFieldUpdateOperationsInput | $Enums.InfluencerStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInfluencersNestedInput
    campaigns?: InfluencerCampaignsUpdateManyWithoutInfluencerNestedInput
  }

  export type InfluencerUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    reach?: IntFieldUpdateOperationsInput | number
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    niche?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumInfluencerStatusFieldUpdateOperationsInput | $Enums.InfluencerStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaigns?: InfluencerCampaignsUncheckedUpdateManyWithoutInfluencerNestedInput
  }

  export type InfluencerUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    reach?: IntFieldUpdateOperationsInput | number
    engagementRate?: NullableFloatFieldUpdateOperationsInput | number | null
    niche?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumInfluencerStatusFieldUpdateOperationsInput | $Enums.InfluencerStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InfluencerCampaignsCreateManyInfluencerInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate?: Date | string | null
    budget: number
    results?: NullableJsonNullValueInput | InputJsonValue
    status: $Enums.InfluencerCampaignStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InfluencerCampaignsUpdateWithoutInfluencerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: FloatFieldUpdateOperationsInput | number
    results?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumInfluencerCampaignStatusFieldUpdateOperationsInput | $Enums.InfluencerCampaignStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InfluencerCampaignsUncheckedUpdateWithoutInfluencerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: FloatFieldUpdateOperationsInput | number
    results?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumInfluencerCampaignStatusFieldUpdateOperationsInput | $Enums.InfluencerCampaignStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InfluencerCampaignsUncheckedUpdateManyWithoutInfluencerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: FloatFieldUpdateOperationsInput | number
    results?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumInfluencerCampaignStatusFieldUpdateOperationsInput | $Enums.InfluencerCampaignStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleCreateManyClinicInput = {
    id?: string
    userId: string
    adId?: string | null
    title: string
    startDate: Date | string
    endDate: Date | string
    status: $Enums.ScheduleStatus
    priority?: $Enums.SchedulePriority
    category?: $Enums.ScheduleCategory | null
    productId?: string | null
    recurrence?: $Enums.RecurrencePattern | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignCreateManyClinicInput = {
    id?: string
    userId: string
    metaAccountId?: string | null
    adAccountId?: string | null
    campaignId?: string | null
    name: string
    objective: string
    status: $Enums.CampaignStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    productId?: string | null
  }

  export type ScheduleUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumScheduleStatusFieldUpdateOperationsInput | $Enums.ScheduleStatus
    priority?: EnumSchedulePriorityFieldUpdateOperationsInput | $Enums.SchedulePriority
    category?: NullableEnumScheduleCategoryFieldUpdateOperationsInput | $Enums.ScheduleCategory | null
    recurrence?: NullableEnumRecurrencePatternFieldUpdateOperationsInput | $Enums.RecurrencePattern | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSchedulesNestedInput
    ad?: AdUpdateOneWithoutSchedulesNestedInput
    product?: ProductUpdateOneWithoutSchedulesNestedInput
  }

  export type ScheduleUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    adId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumScheduleStatusFieldUpdateOperationsInput | $Enums.ScheduleStatus
    priority?: EnumSchedulePriorityFieldUpdateOperationsInput | $Enums.SchedulePriority
    category?: NullableEnumScheduleCategoryFieldUpdateOperationsInput | $Enums.ScheduleCategory | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    recurrence?: NullableEnumRecurrencePatternFieldUpdateOperationsInput | $Enums.RecurrencePattern | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    adId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumScheduleStatusFieldUpdateOperationsInput | $Enums.ScheduleStatus
    priority?: EnumSchedulePriorityFieldUpdateOperationsInput | $Enums.SchedulePriority
    category?: NullableEnumScheduleCategoryFieldUpdateOperationsInput | $Enums.ScheduleCategory | null
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    recurrence?: NullableEnumRecurrencePatternFieldUpdateOperationsInput | $Enums.RecurrencePattern | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCampaignsNestedInput
    metaAccount?: MetaAccountUpdateOneWithoutCampaignsNestedInput
    adAccount?: AdAccountUpdateOneWithoutCampaignsNestedInput
    adSets?: AdSetUpdateManyWithoutCampaignNestedInput
    tags?: TagsOnCampaignsUpdateManyWithoutCampaignNestedInput
    metrics?: CampaignMetricsUpdateManyWithoutCampaignNestedInput
    product?: ProductUpdateOneWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    metaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    adAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
    adSets?: AdSetUncheckedUpdateManyWithoutCampaignNestedInput
    tags?: TagsOnCampaignsUncheckedUpdateManyWithoutCampaignNestedInput
    metrics?: CampaignMetricsUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    metaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    adAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    productId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ScheduleCreateManyProductInput = {
    id?: string
    userId: string
    adId?: string | null
    title: string
    startDate: Date | string
    endDate: Date | string
    status: $Enums.ScheduleStatus
    priority?: $Enums.SchedulePriority
    category?: $Enums.ScheduleCategory | null
    clinicId?: string | null
    recurrence?: $Enums.RecurrencePattern | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignCreateManyProductInput = {
    id?: string
    userId: string
    metaAccountId?: string | null
    adAccountId?: string | null
    campaignId?: string | null
    name: string
    objective: string
    status: $Enums.CampaignStatus
    budget?: number | null
    budgetType?: $Enums.BudgetType | null
    startDate?: Date | string | null
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinicId?: string | null
  }

  export type ScheduleUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumScheduleStatusFieldUpdateOperationsInput | $Enums.ScheduleStatus
    priority?: EnumSchedulePriorityFieldUpdateOperationsInput | $Enums.SchedulePriority
    category?: NullableEnumScheduleCategoryFieldUpdateOperationsInput | $Enums.ScheduleCategory | null
    recurrence?: NullableEnumRecurrencePatternFieldUpdateOperationsInput | $Enums.RecurrencePattern | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSchedulesNestedInput
    ad?: AdUpdateOneWithoutSchedulesNestedInput
    clinic?: ClinicUpdateOneWithoutSchedulesNestedInput
  }

  export type ScheduleUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    adId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumScheduleStatusFieldUpdateOperationsInput | $Enums.ScheduleStatus
    priority?: EnumSchedulePriorityFieldUpdateOperationsInput | $Enums.SchedulePriority
    category?: NullableEnumScheduleCategoryFieldUpdateOperationsInput | $Enums.ScheduleCategory | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    recurrence?: NullableEnumRecurrencePatternFieldUpdateOperationsInput | $Enums.RecurrencePattern | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    adId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumScheduleStatusFieldUpdateOperationsInput | $Enums.ScheduleStatus
    priority?: EnumSchedulePriorityFieldUpdateOperationsInput | $Enums.SchedulePriority
    category?: NullableEnumScheduleCategoryFieldUpdateOperationsInput | $Enums.ScheduleCategory | null
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    recurrence?: NullableEnumRecurrencePatternFieldUpdateOperationsInput | $Enums.RecurrencePattern | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCampaignsNestedInput
    metaAccount?: MetaAccountUpdateOneWithoutCampaignsNestedInput
    adAccount?: AdAccountUpdateOneWithoutCampaignsNestedInput
    adSets?: AdSetUpdateManyWithoutCampaignNestedInput
    tags?: TagsOnCampaignsUpdateManyWithoutCampaignNestedInput
    metrics?: CampaignMetricsUpdateManyWithoutCampaignNestedInput
    clinic?: ClinicUpdateOneWithoutCampaignsNestedInput
  }

  export type CampaignUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    metaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    adAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    adSets?: AdSetUncheckedUpdateManyWithoutCampaignNestedInput
    tags?: TagsOnCampaignsUncheckedUpdateManyWithoutCampaignNestedInput
    metrics?: CampaignMetricsUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type CampaignUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    metaAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    adAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    campaignId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    status?: EnumCampaignStatusFieldUpdateOperationsInput | $Enums.CampaignStatus
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    budgetType?: NullableEnumBudgetTypeFieldUpdateOperationsInput | $Enums.BudgetType | null
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentCreateManyInvoiceInput = {
    id?: string
    userId: string
    amount: number
    currency?: string
    status: $Enums.PaymentStatus
    method: $Enums.PaymentMethod
    description?: string | null
    transactionId?: string | null
    receiptUrl?: string | null
    date?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    description?: NullableStringFieldUpdateOperationsInput | string | null
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagsOnCampaignsCreateManyTagInput = {
    campaignId: string
    assignedAt?: Date | string
  }

  export type TagsOnCampaignsUpdateWithoutTagInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: CampaignUpdateOneRequiredWithoutTagsNestedInput
  }

  export type TagsOnCampaignsUncheckedUpdateWithoutTagInput = {
    campaignId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagsOnCampaignsUncheckedUpdateManyWithoutTagInput = {
    campaignId?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}